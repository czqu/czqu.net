<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Wireshark Basic Usage</title>
      <link href="/posts/20069/"/>
      <url>/posts/20069/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Introduction"><a href="#一、Introduction" class="headerlink" title="一、Introduction"></a>一、Introduction</h2><p>Wireshark is currently one of the most widely used network packet analysis software in the world. The function of network packet analysis software is to listen to network packets and display the most detailed network packet information as much as possible. Wireshark uses Winpcap as the interface to directly exchange data packets with the network card.</p><p>The following figure shows the initial interface after successfully installing Winpcap and Wireshark:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/20069/image-20200608181205658.png" alt="image-20200608181205658"></p><p>In the initial interface of Wireshark, the fluctuating line represents the fluctuation of the information transmitted by the network card. Click the start icon in the upper left corner to enter the packet capture page shown in the following figure:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/20069/image-20200608181307861.png" alt="image-20200608181307861"></p><h2 id="二、Packet-Capture-and-Analysis"><a href="#二、Packet-Capture-and-Analysis" class="headerlink" title="二、Packet Capture and Analysis"></a>二、Packet Capture and Analysis</h2><p>This example demonstrates packet capture using the curl and ping commands.<br>Start capturing with Wireshark, and then, as shown in the following figure, use the curl and ping commands in the terminal to interact with the target address:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/20069/image-20200608173101731.png" alt="image-20200608173101731"></p><p>​                </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/20069/image-20200608174203428.png" alt="image-20200608174203428"></p><blockquote><p> From the response packets of ping, we can see that we received 7 response packets. The IP address of Baidu here is 14.215.177.39.</p></blockquote><p>Returning to Wireshark, filter the packets by IP address in the filter, as shown in the following figure is the result of filtering the packets. The filter command is:</p><pre class="line-numbers language-none"><code class="language-none">ip.addr ==14.215.177.39 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/20069/image-20200608173431410.png" alt="image-20200608173431410"></p><h3 id="1-TCP-Three-Way-Handshake-Analysis"><a href="#1-TCP-Three-Way-Handshake-Analysis" class="headerlink" title="1.TCP Three-Way Handshake Analysis"></a>1.TCP Three-Way Handshake Analysis</h3><p>Viewing the packets, in the above figure, packets 1-3 are using the TCP protocol, and packet 4 is using the HTTP protocol, which is a clear sign of the TCP three-way handshake. The first three packets are the process of the TCP three-way handshake. The following figure shows the detailed packet contents of the TCP three-way handshake, which can be compared with the packet flag bits of the TCP three-way handshake.</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/20069/JSYW201709050_01100.jpg" alt="img"></p><h3 id="2-ICMP-Protocol-Analysis"><a href="#2-ICMP-Protocol-Analysis" class="headerlink" title="2.ICMP Protocol Analysis"></a>2.ICMP Protocol Analysis</h3><p>The ping command belongs to the ICMP protocol. Viewing the ICMP packets in the filtered packets, we can observe 14 packets. As mentioned earlier, 7 response packets were received for the ping destination address.</p><p>ICMP packets have two modes: request and response. See the following figure for details:：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/20069/image-20200608174410800.png" alt="image-20200608174410800"></p><p><strong>The ICMP Request and Reply message formats are as follows:</strong></p><p>Request：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/20069/image-20200608174514228.png" alt="image-20200608174514228"></p><p> Reply：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/20069/image-20200608174532582.png" alt="image-20200608174532582"></p><blockquote><p>Type indicates the type of ICMP message, 8 for request messages and 0 for reply messages;</p><p>Code = 0;</p><p>CheckSum is the checksum from the ICMP header (starting with Type) to the end of the data (ending with the entire packet);</p><p>Identifier is the identifier set by the host, usually set to the process ID. The identifier in the response message is the same as the identifier in the original message;</p><p>Sequence Number is the sequence number set by the host, usually set to an increasing sequence starting from 0. The sequence number in the response message is the same as the sequence number in the original message;</p><p>Data is the data set by the host. The data in the response message is the same as the data in the original message;</p><p>Note: The Identifier and Sequence Number fields are divided into [BE] and [LE]. [BE] is for Linux content, and [LE] is for Windows content. Since this experiment was conducted in a Linux environment, only the [BE] content needs to be viewed.</p></blockquote><p>Request Message Header ：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/20069/image-20200608174737348.png" alt="image-20200608174737348"></p><p>Reply Message Header：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/20069/image-20200608174816396.png" alt="image-20200608174816396"></p><h2 id="三、Introduction-to-Wireshark-filters"><a href="#三、Introduction-to-Wireshark-filters" class="headerlink" title="三、Introduction to Wireshark filters"></a>三、Introduction to Wireshark filters</h2><p>One of the core features of Wireshark is the use of filters. There are three states for display filters: red, yellow, and green. Red means that the display filter expression is incorrect, yellow means that the filter expression can filter packets but may result in unpredictable results, and green means that the filter expression is correct.</p><p>Wireshark filters are divided into two types: display filters and capture filters. Display filters filter captured packets based on filtering rules, while capture filters only capture packets that meet the filtering rules that have been set in advance.</p><p><strong>Capture Filter：</strong></p><p>As shown in the following figure is the capture filter settings. ：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/20069/image-20200608175505369.png" alt="image-20200608175505369">  </p><p>The reason for setting a capture filter is to target situations where the network traffic is very large, such as several gigabytes per second, and most of the traffic is not the data that the analyst is interested in. In this case, a capture filter can be used to capture only the specified data. Useless data can not only interfere with analysis, but also waste storage space and copying time.</p><p><strong>Display filter：</strong></p><p>The following image shows the setting of a display filter ：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/20069/image-20200608175705185.png" alt="image-20200608175705185"></p><blockquote><p>Common syntax of display filters:</p><ol><li><p>Protocol filter, such as http, icmp, etc;</p></li><li><p>Filter by specific port: tcp.port eq 80, displays packets with port 80 whether it is a source or destination port. To filter by the source port, use tcp.srcport eq 80, and to filter by the destination port, use tcp.dstport eq 80;</p></li><li><p>Filter by source IP address: ip.src eq 192.168.1.107, and to filter by the destination, use ip.dst eq 192.168.1.107. To filter by both source and destination, use ip.addr eq 192.168.1.107. MAC address filtering follows the same logic;</p></li><li><p>Filter packets containing a specific string domain name, such as http.host contains “moe”;</p></li><li><p>Multiple filter conditions can be used together, for example, to simultaneously filter for http protocol and port 80, use http &amp;&amp; tcp.port == 80. Combination symbols include AND/&amp;&amp;, OR/||, and NOT/!;</p></li></ol><p>The syntax of capture filters is slightly different from display filters, and some examples are as follows:</p><ol><li>Filter by specific protocol: http</li><li>Filter by specific port: port 80</li><li>Filter by specific IP address: host 192.168.0.115</li><li>Filter by specific domain name: host <a href="http://www.example.com/">www.example.com</a></li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Information Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The issue of SSL certificate being unable to issue due to the CNAME record pointing to Vercel affecting the CAA record.</title>
      <link href="/posts/3655275721/"/>
      <url>/posts/3655275721/</url>
      
        <content type="html"><![CDATA[<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>The most drastic solution is to directly pause all DNS related to Vercel.<br>Or, first pause the resolution of the second-level domain to Vercel, that is, pause example.com-&gt;Vercel,<br>and then pause the Vercel of the affected subdomain, that is, pause a.example.com-&gt;Vercel.</p><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>Today, Alibaba Cloud informed me that an SSL certificate for one of my domains was about to expire. As an experienced developer, I opened the Alibaba Cloud console to apply for a new certificate.</p><p>However, something strange happened. Previously, the certificate could be issued within a minute, but this time it took a long time and it still didn’t work. I decided to take a nap and try again later.</p><p>When I woke up and opened the Alibaba Cloud console, I found that it still wasn’t successful. At this point, I still suspected that it was Alibaba Cloud’s problem. So I applied again using Freessl, but it still wasn’t successful in the afternoon. The result of the test using <a href="https://myssl.com/">myssl.com</a> is as follows:</p><table><thead><tr><th align="left">Region</th><th align="left">Match</th></tr></thead><tbody><tr><td align="left">China</td><td align="left">Not match (Validation failed. Your CAA configuration doesn’t allow the current CA to issue certificates for you. Please modify to: symantec.com or digicert.com)</td></tr><tr><td align="left">Hong Kong</td><td align="left">Not match (Validation failed. Your CAA configuration doesn’t allow the current CA to issue certificates for you. Please modify to: symantec.com or digicert.com)</td></tr><tr><td align="left">United States</td><td align="left">Not match (Validation failed. Your CAA configuration doesn’t allow the current CA to issue certificates for you. Please modify to: symantec.com or digicert.com)</td></tr></tbody></table><p>I haven’t set up any CAA records! </p><p>I thought it couldn’t be a DNS cache issue, right?</p><p> But I still went to the Alibaba Cloud console to temporarily stop resolving all DNS records. As a result, it actually worked! After investigation, I found that the problem was caused by the CNAME record pointing to Vercel. How could Vercel have the permission to set CAA records for me?!</p><h3 id="Reason"><a href="#Reason" class="headerlink" title="Reason"></a>Reason</h3><p>After some searching, I finally figured out the reason, which was caused by the CAA record.</p><blockquote><p> CAA (Certificate Authority Authorization) is a new additional field that can be added to DNS records to create CAA resource records through DNS mechanism, which can limit the connection between the domain name issuing the certificate and the CA (certificate authority). Unauthorized third parties attempting to obtain SSL/TLS certificates for the domain name through other CAs will be rejected. By setting a CAA record for the domain name, website owners can authorize specific CAs to issue certificates for their domain name, thereby preventing HTTPS certificate errors and improving website security.</p></blockquote><p>An additional piece of knowledge is that CNAME records can affect CAA records：</p><p>CAA record checking continues for CNAME records pointing to a different domain. In this example, <a href="http://www.example.com/">www.example.com</a> points to <a href="http://www.example.net/">www.example.net</a>, which also has CAA records:</p><pre class="line-numbers language-plainText" data-language="plainText"><code class="language-plainText">(Example 7 / www.example.com)Domain   Record type  Flags  Tag      Value   www.example.com.   CNAME www.example.netwww.example.net.   CAA           0      issue   ";"(Result: CAA failed)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>The first record redirects the CAA check to <a href="http://www.example.net/">www.example.net</a>. This CAA record can prevent any CA from issuing a certificate, so the certificate authority cannot issue a certificate for <a href="http://www.example.com/">www.example.com</a>.</p><p>If the domain being pointed to (<a href="http://www.example.net/">www.example.net</a>) does not have a CAA record, then the CAA record check will climb up to the parent domain (example.com).</p><pre class="line-numbers language-plainText" data-language="plainText"><code class="language-plainText">(Example 8 / www.example.com)Domain   Record type  Flags  Tag      Value   www.example.com.   CNAME www.example.netexample.com.   CAA           0      issue   "amazon.com"(Result: CAA passed)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>In plain language, it means that because we set a CNAME record to point to Vercel, and Vercel set a CAA record, it affected our domain’s CAA record. After using a tool to check, we confirmed that this was indeed the case.：</p><pre class="line-numbers language-none"><code class="language-none">{  "canIssue": false,  "status": "IssueMismatch",  "domain": "czqu.ren",  "queryAt": "Sep 30, 2021 11:21:55 AM",  "elapsed": 1,  "caaRecordSet": [    {      "domain": "czqu.ren",      "caaRecords": [        {          "issuerCritical": 0,          "tag": "issue",          "value": "letsencrypt.org",          "type": 257,          "dclass": 1,          "ttl": 60        },        {          "issuerCritical": 0,          "tag": "issue",          "value": "globalsign.com",          "type": 257,          "dclass": 1,          "ttl": 60        }      ]    }  ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Backend development </tag>
            
            <tag> Trap </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
