{"title":"git合并丢失代码问题分析与解决(错误操作导致)","slug":"draft/git-merge-problem","date":"2019-03-19T04:16:29.000Z","updated":"2019-03-19T04:16:29.000Z","comments":true,"path":"api/articles/draft/git-merge-problem.json","excerpt":"问题描述我们在主干dev和branch1分支上进行并行开发。当要把branch1功能的代码合并到dev上时，发现dev上开发的部分功能代码找不到了。 那么，是在branch1上，作了删除提交导致的吗？然而，查提交日志，并没有发现删代码的提交记录。 难道一个分支有一个功能，另一个分支没这个功能，git合并时就有可能把这块功能代码丢掉？跟功能添加时间顺序有关系？ 为了解决这个问题和相关的疑问，我们需要先了解下git合并的过程。 git-merge过程稍微了解点git基础的应该都知道，合并是用的git merge命令。它只有两种，一种是快速合并(fast-forward)，还有一种是三方合并(thirdparty merge)。 如上图所示，当两个分支有直系关系时，使用快速合并，git不产生新的commit结点，只是把head进行更新，如dev指向C4。 三方合并稍显复杂点，它会产生一个新的commit结点，并把head指向它。它会先去找这两个要合并分支的最近公有结点，如图中，C3 和 C5的最近公有父结点为C1。然后，git对 C1、C3和C5三个结点进行三方合并产生新结点C6。这里的三方","covers":["/cn/posts/25541/972306-c0cbace0c872146b.png","/cn/posts/25541/972306-2041ea44556fae85.png","/cn/posts/25541/972306-b6cb91c36028672f.png","/cn/posts/25541/972306-1a83be3f1e564eea.png","/cn/posts/25541/972306-0347e3a5dc0b5726.png","/cn/posts/25541/972306-d68ba36ae196a482.png","/cn/posts/25541/972306-d2fd738427b372b5.png"],"content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>我们在主干dev和branch1分支上进行并行开发。当要把branch1功能的代码合并到dev上时，发现dev上开发的部分功能代码找不到了。</p>\n<p>那么，是在branch1上，作了删除提交导致的吗？然而，查提交日志，并没有发现删代码的提交记录。</p>\n<p>难道一个分支有一个功能，另一个分支没这个功能，git合并时就有可能把这块功能代码丢掉？跟功能添加时间顺序有关系？</p>\n<p>为了解决这个问题和相关的疑问，我们需要先了解下git合并的过程。</p>\n<h2 id=\"git-merge过程\"><a href=\"#git-merge过程\" class=\"headerlink\" title=\"git-merge过程\"></a>git-merge过程</h2><p>稍微了解点git基础的应该都知道，合并是用的git merge命令。它只有两种，一种是快速合并(fast-forward)，还有一种是三方合并(thirdparty merge)。</p>\n<p><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/25541/972306-c0cbace0c872146b.png\" alt=\"img\"></p>\n<p>如上图所示，当两个分支有直系关系时，使用快速合并，git不产生新的commit结点，只是把head进行更新，如dev指向<code>C4</code>。</p>\n<p>三方合并稍显复杂点，它会产生一个新的commit结点，并把head指向它。它会先去找这两个要合并分支的最近公有结点，如图中，<code>C3</code> 和 <code>C5</code>的最近公有父结点为<code>C1</code>。然后，git对 <code>C1</code>、<code>C3</code>和<code>C5</code>三个结点进行三方合并产生新结点<code>C6</code>。这里的三方合并，具体来说，就是把 <code>C5</code>相较于<code>C1</code>的 diff差异应用到 <code>C3</code>上，最后产生<code>C6</code> 这个commit结点。</p>\n<p>现在回答上面的疑问，三方合并其实只看三个点的内容，和中间结点无任何关系，更别提跟时间有关系了。在一个分支上删除代码，如果合并时没有冲突的话，合并后是会直接删除的。</p>\n<p>所以，我们找到了问题的初步方向了。dev上的代码合并后没了，一定是branch1分支有问题！！！</p>\n<blockquote>\n<p>注：知道了git-merge的流程后，我们还可以知道，只要我们把这次合并代码丢失问题解决了，后续从branch1分支拉出去的分支代码再合并到dev时，都不用再解决这个代码丢失问题了。因为，合并后的提交结点和branch1分支拉出去分支的后续提交结点的父结点，已经变成branch1的当前结点了。如，<code>C6</code>的后续提交和<code>C5</code>的后续提交结点，公有结点都变成<code>C5</code>了。</p>\n</blockquote>\n<h2 id=\"问题起因及检测\"><a href=\"#问题起因及检测\" class=\"headerlink\" title=\"问题起因及检测\"></a>问题起因及检测</h2><p>为了描述问题方便，我把场景简化，搞了个demo，大家可以去下面地址clone：</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git clone https://git.coding.net/myswift/git-merge.git</span><br></pre></td></tr></tbody></table></figure>\n\n<p>提交记录用sourcetree看，是这样的（你可能已经发现问题了）：</p>\n<p><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/25541/972306-2041ea44556fae85.png\" alt=\"img\"></p>\n<p>dev合并branch1时，dev上，<code>dev func 1</code>部分的提交丢失。</p>\n<p>首先，让我们找最近公共结点吧。如果两个分支并行太久的话，可能不好直接找出来。我们可以使用git merge-base:</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git merge-base 98d19a4 0acedcb</span><br><span class=\"line\">9447776f5ee8c53536c947a1e13bfdead13f002b </span><br></pre></td></tr></tbody></table></figure>\n\n<p>我们发现最近的公共结点是<code>9447776</code>。然而，这个公共结点，并不是我们设想的。我们设想的最近公共结点应该是两个分支刚开始并行的那个结点（如图中<code>c3275e2</code>)。进一步发现，<code>9447776</code>的下一个结点有个Merge，而且是把dev合并到branch1！！！</p>\n<p>这就是问题的根源了，dev主干开发的一般是下个版本的功能，一般是把分支的代码合到主干上，把主干的代码逆向合并到分支上肯定是有问题的！！！</p>\n<p>回到开头的问题，我们看Merge结点变更记录，并没有发现有删除代码的地方啊？原因是，你看到的合并结点的修改记录，是针对一边的。回到介绍三方合并的那个图，把branch1合并到dev产生结点<code>C6</code>，那么<code>C6</code>的提交记录中显示的修改，是<code>C6</code>针对<code>C3</code>结点的。在我们的示例中，合并结点<code>74a8d10</code>的提交变更，显示的是<code>74a8d10</code>对branch1中<code>c26c5e3</code>的变更，而branch1中本来就没有dev中的代码，所以合并后变更根本不会显示删除。</p>\n<p>如果，你去比较合并结点和另一边的变更，你就可以发现问题：</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git diff 9447776 74a8d10</span><br><span class=\"line\">diff --git a/test.c b/test.c</span><br><span class=\"line\">index 150de8d..d19a020 100644</span><br><span class=\"line\">--- a/test.c</span><br><span class=\"line\">+++ b/test.c</span><br><span class=\"line\">@@ -7,8 +7,8 @@ void base_func() {</span><br><span class=\"line\">        printf(\"this is a crash %d\\n\", *p);</span><br><span class=\"line\"> }</span><br><span class=\"line\"></span><br><span class=\"line\">-void dev_func_1() {</span><br><span class=\"line\">-       printf(\"dev func 1\\n\");</span><br><span class=\"line\">+void branch_func_1(){</span><br><span class=\"line\">+       printf(\"branch func1\\n\");</span><br><span class=\"line\"> }</span><br></pre></td></tr></tbody></table></figure>\n\n<p>你可以明显看到，在合并时，把dev中的<code>dev_func_1</code>函数删除掉了。</p>\n<p>总结问题的原因是，在正式合并前，进行了逆向的合并，并在合并中<code>悄悄</code>把主干代码删除掉了。一般如果查看提交记录中，没有看到删除记录，那么很有可能是之前的Merge中把代码删除了。可以使用 <code>merge-base</code>和<code>git diff</code> 工具来进行定位，也可以用来检测是否有问题。</p>\n<blockquote>\n<p>注：很多人可能认为只要管好自己的分支就行了，然后把别的分支合过来，并在合并时或合并后随意删除另一分支的代码。这样当以后再和该分支合并时，就会有问题。好的做法，应该是只把另一个分支上你需要的提交用cherry-pick移过来，而不是直接合并别人的分支，再删除你不需要的代码。如，只把dev上的<code>fec5b84</code>优化cherry-pick复制到branch1上即可。</p>\n</blockquote>\n<h2 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h2><p>既然我们发现了问题的原因，并知道怎么去规避、检测。那么，如果已经发生了问题，怎么去解决呢？这个可能是大家更关心的。</p>\n<p>其实我们最终的目标是，把branch1和dev进行合并，产生一个合并节点，并且这个合并结点的代码是正确的。</p>\n<blockquote>\n<p>注：有些人可能不太明白为什么一定要产生一个git合并记录节点。通过各种手段，只要保证dev上代码正确不就行了？结论是不行，因为如果没有git合并记录的话，从branch1拉出来的所有分支再想合并到dev时，还是要解决下这个代码丢失的问题（没想明白，可以再看下前面git-merge过程部分)，而且如果把branch1分支悬着不合并，也影响分支查看。</p>\n</blockquote>\n<h3 id=\"确保合并后代码正确\"><a href=\"#确保合并后代码正确\" class=\"headerlink\" title=\"确保合并后代码正确\"></a>确保合并后代码正确</h3><p>奔着这个目标，我们首先来确保代码的正确。</p>\n<h4 id=\"1-dev重置到合并前\"><a href=\"#1-dev重置到合并前\" class=\"headerlink\" title=\"1. dev重置到合并前\"></a>1. dev重置到合并前</h4><p>既然最后合并branch1到dev会导致dev丢代码，我们首先把dev重置到合并前。</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git checkout dev</span><br><span class=\"line\"># git reset --hard HEAD~1</span><br></pre></td></tr></tbody></table></figure>\n\n<p><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/25541/972306-b6cb91c36028672f.png\" alt=\"img\"></p>\n<h4 id=\"2-创建tmp分支，绕过错误的合并74a8d10\"><a href=\"#2-创建tmp分支，绕过错误的合并74a8d10\" class=\"headerlink\" title=\"2. 创建tmp分支，绕过错误的合并74a8d10\"></a>2. 创建tmp分支，绕过错误的合并<code>74a8d10</code></h4><p>我们知道branch1是有问题的，因为进行了合并dev的操作。所以，基于branch1创建一个临时分支tmp。</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git checkout branch1</span><br><span class=\"line\"># git checkout -b tmp</span><br></pre></td></tr></tbody></table></figure>\n\n<p><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/25541/972306-1a83be3f1e564eea.png\" alt=\"img\"></p>\n<p>把tmp的提交记录重塑，使tmp分支回到branch1上的，合并dev到branch1那个错误的合并之前的结点，示例中 <code>74a8d10</code>之前的那个<code>c26c5e3</code>结点，并提交一个新记录，这样tmp内容与branch1一样，而完全跟那个<code>74a8d10</code>结点没关系了。</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git checkout tmp</span><br><span class=\"line\"># git reset c26c5e3</span><br><span class=\"line\"># git add .</span><br><span class=\"line\"># git commit -m \"内容与branch1一致\"</span><br></pre></td></tr></tbody></table></figure>\n\n<p><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/25541/972306-0347e3a5dc0b5726.png\" alt=\"img\"></p>\n<blockquote>\n<p>注：reset和reset –hard的区别，可以参考文末资料1。</p>\n</blockquote>\n<h4 id=\"3-合并tmp到dev\"><a href=\"#3-合并tmp到dev\" class=\"headerlink\" title=\"3. 合并tmp到dev\"></a>3. 合并tmp到dev</h4><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git checkout dev</span><br><span class=\"line\"># git merge tmp</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这里dev和tmp合并时，它们的最近公共结点就不是之前错误的<code>9447776</code>了，而是我们设想的、dev和branch1最初分开的，<code>c3275e2</code>结点。</p>\n<p>解决冲突，并add进暂存区后，我们代码就是正确的了（先不急着提交）。</p>\n<p><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/25541/972306-d68ba36ae196a482.png\" alt=\"img\"></p>\n<h3 id=\"产生合并commit对象\"><a href=\"#产生合并commit对象\" class=\"headerlink\" title=\"产生合并commit对象\"></a>产生合并commit对象</h3><p>上面代码正确了，如果我们直接commit的话，这个合并结点，就变成dev和tmp的合并了，而我们要的是dev和branch1的合并。所以，我们要产生一个dev和branch1合并的结点，并且内容是当前dev和tmp合并后的代码。显然，git merge不能满足我们的需求，我们需要更底层的git命令，就是git merge过程中，调用的底层命令。</p>\n<p>需要按序要用到 write-tree -&gt; commit-tree -&gt; update-ref，这三条底层命令。这部分命令，可以查看参考资料2。</p>\n<h4 id=\"1-write-tree产生tree对象\"><a href=\"#1-write-tree产生tree对象\" class=\"headerlink\" title=\"1. write-tree产生tree对象\"></a>1. write-tree产生tree对象</h4><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git add .</span><br><span class=\"line\"># git write-tree</span><br><span class=\"line\">853c36012082314f9463f3819d0a24da49dc5bb1</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我们产生了SHA-1值为 <code>853c360</code>的tree对象。</p>\n<h4 id=\"2-commit-tree产生commit对象\"><a href=\"#2-commit-tree产生commit对象\" class=\"headerlink\" title=\"2. commit-tree产生commit对象\"></a>2. commit-tree产生commit对象</h4><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git commit-tree 853c360 -p 98d19a4 -p 0acedcb -m \"Merge branch 'branch1' into dev\"</span><br><span class=\"line\">675baf3973508ee03306cc5a36fe489d694e107f</span><br></pre></td></tr></tbody></table></figure>\n\n<p>我们把tree对象 <code>853c360</code>进行了提交，并设置它的两个父结点为dev和branch1，产生了commit对象<code>675baf3</code>。我们可以看下这个结点的情况：</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git cat-file 675baf3 -p</span><br><span class=\"line\"></span><br><span class=\"line\">tree 853c36012082314f9463f3819d0a24da49dc5bb1</span><br><span class=\"line\">parent 98d19a4a5913f18a2c0e9821e114df9995b23d82</span><br><span class=\"line\">parent 0acedcb89e4d25a0256fcbe7fba0bbc13de9d92e</span><br><span class=\"line\">author Vincent &lt;xxx&gt; 1498497182 +0800</span><br><span class=\"line\">committer Vincent &lt;xxx&gt; 1498497182 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">Merge branch 'branch1' into dev</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h4 id=\"3-更新head\"><a href=\"#3-更新head\" class=\"headerlink\" title=\"3. 更新head\"></a>3. 更新head</h4><p>使用如下命令，更新dev指向这个新的commit对象, <code>675baf3</code>：</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git update-ref refs/heads/dev 675baf3</span><br></pre></td></tr></tbody></table></figure>\n\n<p>最终合并结果如下：</p>\n<p><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/25541/972306-d2fd738427b372b5.png\" alt=\"img\"></p>\n<p>可以验证，branch1合并到dev了，而且内容是正确的（即不会少<code>dev fun 1</code>部分的代码）。</p>\n<p>这个解决问题的示例代码，也上传到coding了，两份示例代码，之前的结点都是一致的。</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git clone https://git.coding.net/myswift/git-merge2.git</span><br></pre></td></tr></tbody></table></figure>\n\n<blockquote>\n<p>注：知道了git merge这些底层命令，你可以更加灵活地解决git问题，你可以结点随意合并，head随便指，是不是很开心，哈哈。</p>\n</blockquote>\n<h4 id=\"更粗暴的方法\"><a href=\"#更粗暴的方法\" class=\"headerlink\" title=\"更粗暴的方法\"></a>更粗暴的方法</h4><p>如果你觉得底层命令不好理解。你可以：</p>\n<ul>\n<li>先整个目录拷备下工程（包含.git目录)，比如拷贝到bak目录</li>\n<li>在工程中直接合并branch1到dev上，不解决冲突，不提交</li>\n<li>在bak目录，按照上面确保代码正确的方法，在bak目录合并出正确的代码。</li>\n<li>把bak目录中，除了.git目录外的东东，全部拷贝覆盖到原来工程目录中</li>\n<li>在原来工程目录中，提交</li>\n</ul>\n<p>这样比较好理解，缺点是工程如果大的话，拷来拷去花费时间比较长，而且不够优雅。</p>\n<h2 id=\"其他解决思路\"><a href=\"#其他解决思路\" class=\"headerlink\" title=\"其他解决思路\"></a>其他解决思路</h2><p>上面描述的思路，我认为是最行之有效的。也试了其他思路，比如：</p>\n<ul>\n<li>查看git merge的参数，发现并没有可以自由设置base节点的方法，只有设置发现base节点的策略，而且这些策略发现的base节点都是那个错误的合并。</li>\n<li>undo merge。参考资料3。然而，感觉revert merge的能力有限，加-m1参数、和-m2参数，均无法满足要求。</li>\n<li>rebase branch1。错误发生在branch1，那么重建branch1呢？把所有branch1上合并后的提交都重新提交呢？结果发现branch1上有太多合并冲突，rebase时，要把这个合并的冲突重新解决，很麻烦。</li>\n</ul>\n<p>这些思路，大家也可以继续研究下，感觉不能解决问题，也可能是我了解得有问题。当然，你有其他思路，也希望你交流下。</p>\n<h2 id=\"迷思\"><a href=\"#迷思\" class=\"headerlink\" title=\"迷思\"></a>迷思</h2><p>本文中，是因为错误地把dev合并到branch1上，导致了后面合并的问题。但是，我们真实遇到的场景，虽然看起来是一样的，也可以用文中的方法解决，但是也有细微不同，而且不知道如何出现这个问题。</p>\n<p>真实的场景下，也会出现一个dev合并到branch1的Merge提交，但是显示的信息是 “Revert xxx”，据提交人员讲，这个确实是做的Revert操作，不知如何变成Merge结点了。用的sourcetree，提交人员也没法说清怎么必现这个问题。</p>\n<p>如果，你知道怎么操作能出现这个问题，希望你告诉我。。。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>文中描述了一种可能导致git合并代码丢失的错误操作，并讲解了如何规避、检测、解决这种错误。并粗略介绍了，git merge流程，git merge底层过程。</p>\n<p>说简单点，问题是因为<code>悄悄</code>在合并中把代码删除了。解决思路是，<code>悄悄</code>在后面的合并中把代码加回来。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://github.com/geeeeeeeeek/git-recipes/wiki?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\">1. git-recipes</a></p>\n<p><a href=\"http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.2-Git-%E5%AF%B9%E8%B1%A1\">2. Git 内部原理-commit对象</a></p>\n<p><a href=\"https://git-scm.com/blog/2010/03/02/undoing-merges.html\">3. Reverting a Merge</a></p>\n","more":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>我们在主干dev和branch1分支上进行并行开发。当要把branch1功能的代码合并到dev上时，发现dev上开发的部分功能代码找不到了。</p>\n<p>那么，是在branch1上，作了删除提交导致的吗？然而，查提交日志，并没有发现删代码的提交记录。</p>\n<p>难道一个分支有一个功能，另一个分支没这个功能，git合并时就有可能把这块功能代码丢掉？跟功能添加时间顺序有关系？</p>\n<p>为了解决这个问题和相关的疑问，我们需要先了解下git合并的过程。</p>\n<h2 id=\"git-merge过程\"><a href=\"#git-merge过程\" class=\"headerlink\" title=\"git-merge过程\"></a>git-merge过程</h2><p>稍微了解点git基础的应该都知道，合并是用的git merge命令。它只有两种，一种是快速合并(fast-forward)，还有一种是三方合并(thirdparty merge)。</p>\n<p><img src=\"/cn/posts/25541/972306-c0cbace0c872146b.png\" alt=\"img\"></p>\n<p>如上图所示，当两个分支有直系关系时，使用快速合并，git不产生新的commit结点，只是把head进行更新，如dev指向<code>C4</code>。</p>\n<p>三方合并稍显复杂点，它会产生一个新的commit结点，并把head指向它。它会先去找这两个要合并分支的最近公有结点，如图中，<code>C3</code> 和 <code>C5</code>的最近公有父结点为<code>C1</code>。然后，git对 <code>C1</code>、<code>C3</code>和<code>C5</code>三个结点进行三方合并产生新结点<code>C6</code>。这里的三方合并，具体来说，就是把 <code>C5</code>相较于<code>C1</code>的 diff差异应用到 <code>C3</code>上，最后产生<code>C6</code> 这个commit结点。</p>\n<p>现在回答上面的疑问，三方合并其实只看三个点的内容，和中间结点无任何关系，更别提跟时间有关系了。在一个分支上删除代码，如果合并时没有冲突的话，合并后是会直接删除的。</p>\n<p>所以，我们找到了问题的初步方向了。dev上的代码合并后没了，一定是branch1分支有问题！！！</p>\n<blockquote>\n<p>注：知道了git-merge的流程后，我们还可以知道，只要我们把这次合并代码丢失问题解决了，后续从branch1分支拉出去的分支代码再合并到dev时，都不用再解决这个代码丢失问题了。因为，合并后的提交结点和branch1分支拉出去分支的后续提交结点的父结点，已经变成branch1的当前结点了。如，<code>C6</code>的后续提交和<code>C5</code>的后续提交结点，公有结点都变成<code>C5</code>了。</p>\n</blockquote>\n<h2 id=\"问题起因及检测\"><a href=\"#问题起因及检测\" class=\"headerlink\" title=\"问题起因及检测\"></a>问题起因及检测</h2><p>为了描述问题方便，我把场景简化，搞了个demo，大家可以去下面地址clone：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git clone https://git.coding.net/myswift/git-merge.git</span><br></pre></td></tr></table></figure>\n\n<p>提交记录用sourcetree看，是这样的（你可能已经发现问题了）：</p>\n<p><img src=\"/cn/posts/25541/972306-2041ea44556fae85.png\" alt=\"img\"></p>\n<p>dev合并branch1时，dev上，<code>dev func 1</code>部分的提交丢失。</p>\n<p>首先，让我们找最近公共结点吧。如果两个分支并行太久的话，可能不好直接找出来。我们可以使用git merge-base:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git merge-base 98d19a4 0acedcb</span><br><span class=\"line\">9447776f5ee8c53536c947a1e13bfdead13f002b </span><br></pre></td></tr></table></figure>\n\n<p>我们发现最近的公共结点是<code>9447776</code>。然而，这个公共结点，并不是我们设想的。我们设想的最近公共结点应该是两个分支刚开始并行的那个结点（如图中<code>c3275e2</code>)。进一步发现，<code>9447776</code>的下一个结点有个Merge，而且是把dev合并到branch1！！！</p>\n<p>这就是问题的根源了，dev主干开发的一般是下个版本的功能，一般是把分支的代码合到主干上，把主干的代码逆向合并到分支上肯定是有问题的！！！</p>\n<p>回到开头的问题，我们看Merge结点变更记录，并没有发现有删除代码的地方啊？原因是，你看到的合并结点的修改记录，是针对一边的。回到介绍三方合并的那个图，把branch1合并到dev产生结点<code>C6</code>，那么<code>C6</code>的提交记录中显示的修改，是<code>C6</code>针对<code>C3</code>结点的。在我们的示例中，合并结点<code>74a8d10</code>的提交变更，显示的是<code>74a8d10</code>对branch1中<code>c26c5e3</code>的变更，而branch1中本来就没有dev中的代码，所以合并后变更根本不会显示删除。</p>\n<p>如果，你去比较合并结点和另一边的变更，你就可以发现问题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git diff 9447776 74a8d10</span><br><span class=\"line\">diff --git a/test.c b/test.c</span><br><span class=\"line\">index 150de8d..d19a020 100644</span><br><span class=\"line\">--- a/test.c</span><br><span class=\"line\">+++ b/test.c</span><br><span class=\"line\">@@ -7,8 +7,8 @@ void base_func() &#123;</span><br><span class=\"line\">        printf(&quot;this is a crash %d\\n&quot;, *p);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">-void dev_func_1() &#123;</span><br><span class=\"line\">-       printf(&quot;dev func 1\\n&quot;);</span><br><span class=\"line\">+void branch_func_1()&#123;</span><br><span class=\"line\">+       printf(&quot;branch func1\\n&quot;);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>你可以明显看到，在合并时，把dev中的<code>dev_func_1</code>函数删除掉了。</p>\n<p>总结问题的原因是，在正式合并前，进行了逆向的合并，并在合并中<code>悄悄</code>把主干代码删除掉了。一般如果查看提交记录中，没有看到删除记录，那么很有可能是之前的Merge中把代码删除了。可以使用 <code>merge-base</code>和<code>git diff</code> 工具来进行定位，也可以用来检测是否有问题。</p>\n<blockquote>\n<p>注：很多人可能认为只要管好自己的分支就行了，然后把别的分支合过来，并在合并时或合并后随意删除另一分支的代码。这样当以后再和该分支合并时，就会有问题。好的做法，应该是只把另一个分支上你需要的提交用cherry-pick移过来，而不是直接合并别人的分支，再删除你不需要的代码。如，只把dev上的<code>fec5b84</code>优化cherry-pick复制到branch1上即可。</p>\n</blockquote>\n<h2 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h2><p>既然我们发现了问题的原因，并知道怎么去规避、检测。那么，如果已经发生了问题，怎么去解决呢？这个可能是大家更关心的。</p>\n<p>其实我们最终的目标是，把branch1和dev进行合并，产生一个合并节点，并且这个合并结点的代码是正确的。</p>\n<blockquote>\n<p>注：有些人可能不太明白为什么一定要产生一个git合并记录节点。通过各种手段，只要保证dev上代码正确不就行了？结论是不行，因为如果没有git合并记录的话，从branch1拉出来的所有分支再想合并到dev时，还是要解决下这个代码丢失的问题（没想明白，可以再看下前面git-merge过程部分)，而且如果把branch1分支悬着不合并，也影响分支查看。</p>\n</blockquote>\n<h3 id=\"确保合并后代码正确\"><a href=\"#确保合并后代码正确\" class=\"headerlink\" title=\"确保合并后代码正确\"></a>确保合并后代码正确</h3><p>奔着这个目标，我们首先来确保代码的正确。</p>\n<h4 id=\"1-dev重置到合并前\"><a href=\"#1-dev重置到合并前\" class=\"headerlink\" title=\"1. dev重置到合并前\"></a>1. dev重置到合并前</h4><p>既然最后合并branch1到dev会导致dev丢代码，我们首先把dev重置到合并前。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git checkout dev</span><br><span class=\"line\"># git reset --hard HEAD~1</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/cn/posts/25541/972306-b6cb91c36028672f.png\" alt=\"img\"></p>\n<h4 id=\"2-创建tmp分支，绕过错误的合并74a8d10\"><a href=\"#2-创建tmp分支，绕过错误的合并74a8d10\" class=\"headerlink\" title=\"2. 创建tmp分支，绕过错误的合并74a8d10\"></a>2. 创建tmp分支，绕过错误的合并<code>74a8d10</code></h4><p>我们知道branch1是有问题的，因为进行了合并dev的操作。所以，基于branch1创建一个临时分支tmp。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git checkout branch1</span><br><span class=\"line\"># git checkout -b tmp</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/cn/posts/25541/972306-1a83be3f1e564eea.png\" alt=\"img\"></p>\n<p>把tmp的提交记录重塑，使tmp分支回到branch1上的，合并dev到branch1那个错误的合并之前的结点，示例中 <code>74a8d10</code>之前的那个<code>c26c5e3</code>结点，并提交一个新记录，这样tmp内容与branch1一样，而完全跟那个<code>74a8d10</code>结点没关系了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git checkout tmp</span><br><span class=\"line\"># git reset c26c5e3</span><br><span class=\"line\"># git add .</span><br><span class=\"line\"># git commit -m &quot;内容与branch1一致&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/cn/posts/25541/972306-0347e3a5dc0b5726.png\" alt=\"img\"></p>\n<blockquote>\n<p>注：reset和reset –hard的区别，可以参考文末资料1。</p>\n</blockquote>\n<h4 id=\"3-合并tmp到dev\"><a href=\"#3-合并tmp到dev\" class=\"headerlink\" title=\"3. 合并tmp到dev\"></a>3. 合并tmp到dev</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git checkout dev</span><br><span class=\"line\"># git merge tmp</span><br></pre></td></tr></table></figure>\n\n<p>这里dev和tmp合并时，它们的最近公共结点就不是之前错误的<code>9447776</code>了，而是我们设想的、dev和branch1最初分开的，<code>c3275e2</code>结点。</p>\n<p>解决冲突，并add进暂存区后，我们代码就是正确的了（先不急着提交）。</p>\n<p><img src=\"/cn/posts/25541/972306-d68ba36ae196a482.png\" alt=\"img\"></p>\n<h3 id=\"产生合并commit对象\"><a href=\"#产生合并commit对象\" class=\"headerlink\" title=\"产生合并commit对象\"></a>产生合并commit对象</h3><p>上面代码正确了，如果我们直接commit的话，这个合并结点，就变成dev和tmp的合并了，而我们要的是dev和branch1的合并。所以，我们要产生一个dev和branch1合并的结点，并且内容是当前dev和tmp合并后的代码。显然，git merge不能满足我们的需求，我们需要更底层的git命令，就是git merge过程中，调用的底层命令。</p>\n<p>需要按序要用到 write-tree -&gt; commit-tree -&gt; update-ref，这三条底层命令。这部分命令，可以查看参考资料2。</p>\n<h4 id=\"1-write-tree产生tree对象\"><a href=\"#1-write-tree产生tree对象\" class=\"headerlink\" title=\"1. write-tree产生tree对象\"></a>1. write-tree产生tree对象</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git add .</span><br><span class=\"line\"># git write-tree</span><br><span class=\"line\">853c36012082314f9463f3819d0a24da49dc5bb1</span><br></pre></td></tr></table></figure>\n\n<p>我们产生了SHA-1值为 <code>853c360</code>的tree对象。</p>\n<h4 id=\"2-commit-tree产生commit对象\"><a href=\"#2-commit-tree产生commit对象\" class=\"headerlink\" title=\"2. commit-tree产生commit对象\"></a>2. commit-tree产生commit对象</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git commit-tree 853c360 -p 98d19a4 -p 0acedcb -m &quot;Merge branch &#x27;branch1&#x27; into dev&quot;</span><br><span class=\"line\">675baf3973508ee03306cc5a36fe489d694e107f</span><br></pre></td></tr></table></figure>\n\n<p>我们把tree对象 <code>853c360</code>进行了提交，并设置它的两个父结点为dev和branch1，产生了commit对象<code>675baf3</code>。我们可以看下这个结点的情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git cat-file 675baf3 -p</span><br><span class=\"line\"></span><br><span class=\"line\">tree 853c36012082314f9463f3819d0a24da49dc5bb1</span><br><span class=\"line\">parent 98d19a4a5913f18a2c0e9821e114df9995b23d82</span><br><span class=\"line\">parent 0acedcb89e4d25a0256fcbe7fba0bbc13de9d92e</span><br><span class=\"line\">author Vincent &lt;xxx&gt; 1498497182 +0800</span><br><span class=\"line\">committer Vincent &lt;xxx&gt; 1498497182 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">Merge branch &#x27;branch1&#x27; into dev</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-更新head\"><a href=\"#3-更新head\" class=\"headerlink\" title=\"3. 更新head\"></a>3. 更新head</h4><p>使用如下命令，更新dev指向这个新的commit对象, <code>675baf3</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git update-ref refs/heads/dev 675baf3</span><br></pre></td></tr></table></figure>\n\n<p>最终合并结果如下：</p>\n<p><img src=\"/cn/posts/25541/972306-d2fd738427b372b5.png\" alt=\"img\"></p>\n<p>可以验证，branch1合并到dev了，而且内容是正确的（即不会少<code>dev fun 1</code>部分的代码）。</p>\n<p>这个解决问题的示例代码，也上传到coding了，两份示例代码，之前的结点都是一致的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># git clone https://git.coding.net/myswift/git-merge2.git</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注：知道了git merge这些底层命令，你可以更加灵活地解决git问题，你可以结点随意合并，head随便指，是不是很开心，哈哈。</p>\n</blockquote>\n<h4 id=\"更粗暴的方法\"><a href=\"#更粗暴的方法\" class=\"headerlink\" title=\"更粗暴的方法\"></a>更粗暴的方法</h4><p>如果你觉得底层命令不好理解。你可以：</p>\n<ul>\n<li>先整个目录拷备下工程（包含.git目录)，比如拷贝到bak目录</li>\n<li>在工程中直接合并branch1到dev上，不解决冲突，不提交</li>\n<li>在bak目录，按照上面确保代码正确的方法，在bak目录合并出正确的代码。</li>\n<li>把bak目录中，除了.git目录外的东东，全部拷贝覆盖到原来工程目录中</li>\n<li>在原来工程目录中，提交</li>\n</ul>\n<p>这样比较好理解，缺点是工程如果大的话，拷来拷去花费时间比较长，而且不够优雅。</p>\n<h2 id=\"其他解决思路\"><a href=\"#其他解决思路\" class=\"headerlink\" title=\"其他解决思路\"></a>其他解决思路</h2><p>上面描述的思路，我认为是最行之有效的。也试了其他思路，比如：</p>\n<ul>\n<li>查看git merge的参数，发现并没有可以自由设置base节点的方法，只有设置发现base节点的策略，而且这些策略发现的base节点都是那个错误的合并。</li>\n<li>undo merge。参考资料3。然而，感觉revert merge的能力有限，加-m1参数、和-m2参数，均无法满足要求。</li>\n<li>rebase branch1。错误发生在branch1，那么重建branch1呢？把所有branch1上合并后的提交都重新提交呢？结果发现branch1上有太多合并冲突，rebase时，要把这个合并的冲突重新解决，很麻烦。</li>\n</ul>\n<p>这些思路，大家也可以继续研究下，感觉不能解决问题，也可能是我了解得有问题。当然，你有其他思路，也希望你交流下。</p>\n<h2 id=\"迷思\"><a href=\"#迷思\" class=\"headerlink\" title=\"迷思\"></a>迷思</h2><p>本文中，是因为错误地把dev合并到branch1上，导致了后面合并的问题。但是，我们真实遇到的场景，虽然看起来是一样的，也可以用文中的方法解决，但是也有细微不同，而且不知道如何出现这个问题。</p>\n<p>真实的场景下，也会出现一个dev合并到branch1的Merge提交，但是显示的信息是 “Revert xxx”，据提交人员讲，这个确实是做的Revert操作，不知如何变成Merge结点了。用的sourcetree，提交人员也没法说清怎么必现这个问题。</p>\n<p>如果，你知道怎么操作能出现这个问题，希望你告诉我。。。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>文中描述了一种可能导致git合并代码丢失的错误操作，并讲解了如何规避、检测、解决这种错误。并粗略介绍了，git merge流程，git merge底层过程。</p>\n<p>说简单点，问题是因为<code>悄悄</code>在合并中把代码删除了。解决思路是，<code>悄悄</code>在后面的合并中把代码加回来。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://github.com/geeeeeeeeek/git-recipes/wiki?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io\">1. git-recipes</a></p>\n<p><a href=\"http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.2-Git-%E5%AF%B9%E8%B1%A1\">2. Git 内部原理-commit对象</a></p>\n<p><a href=\"https://git-scm.com/blog/2010/03/02/undoing-merges.html\">3. Reverting a Merge</a></p>\n","categories":[],"tags":[{"name":"git","path":"api/tags/git.json"}]}