{"title":"Java学习笔记-基础篇","slug":"draft/2020-8-6-java-note-basic","date":"2020-08-06T08:13:10.000Z","updated":"2020-08-06T08:13:10.000Z","comments":true,"path":"api/articles/draft/2020-8-6-java-note-basic.json","excerpt":"Java程序怎么样运行的Java 程序从源代码到运行一般有下面 3 步：我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。 HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 J","covers":["/cn/posts/53914/2020080614124077.png","/cn/posts/53914/20200806142232905.png","/cn/posts/53914/20200806143410908.png","/cn/posts/53914/20200806152854603.png","/cn/posts/53914/20200806151224399.png","/cn/posts/53914/20200806154245121.png","/cn/posts/53914/20200806155803123.png","/cn/posts/53914/20200806155808662.png","/cn/posts/53914/202008061601321.png","/cn/posts/53914/20200806160323274.png","/cn/posts/53914/20200806160355775.png"],"content":"<h2 id=\"Java程序怎么样运行的\"><a href=\"#Java程序怎么样运行的\" class=\"headerlink\" title=\"Java程序怎么样运行的\"></a><strong>Java程序怎么样运行的</strong></h2><p>Java 程序从源代码到运行一般有下面 3 步：<br><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/53914/2020080614124077.png\" alt=\"在这里插入图片描述\"><br>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p>\n<blockquote>\n<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p>\n</blockquote>\n<p>总结：</p>\n<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>\n<h2 id=\"为什么说-Java-语言“编译与解释并存”？\"><a href=\"#为什么说-Java-语言“编译与解释并存”？\" class=\"headerlink\" title=\"为什么说 Java 语言“编译与解释并存”？\"></a>为什么说 Java 语言“编译与解释并存”？</h2><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p>\n<p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存</p>\n<h2 id=\"java与C语言在字符串结束符上的区别\"><a href=\"#java与C语言在字符串结束符上的区别\" class=\"headerlink\" title=\"java与C语言在字符串结束符上的区别\"></a>java与C语言在字符串结束符上的区别</h2><p>在C语言中字符串或字符数组最后都会有一个额外的字符‘\\0’来表示结束，而在java语言中没有结束符这一概念。<br>参考：<a href=\"https://blog.csdn.net/sszgg2006/article/details/49148189\">https://blog.csdn.net/sszgg2006/article/details/49148189</a></p>\n<blockquote>\n<p><strong>java中无需结束符的原因</strong><br>Java里面一切都是对象，是对象的话，字符串肯定就有长度，即然有长度，编译器就可以确定要输出的字符个数，当然也就没有必要去浪费那1字节的空间用以标明字符串的结束了。比如，数组对象里有一个属性length,就是数组的长度，String类里面有方法length()可以确定字符串的长度，因此对于输出函数来说，有直接的大小可以判断字符串的边界，编译器就没必要再去浪费一个空间标识字符串的结束。</p>\n</blockquote>\n<p><strong>java字符串末尾空字符的处理</strong></p>\n<p>java和c通信的时候，由于c中的char中有结束符的，所以当java收到C发来的字符串时，后面往往会有若干空字符，如果不做处理的话，java会对其一并输出，为了将空字符处理掉不输出，可以采用如下两种方法：</p>\n<p>方法一:</p>\n<p>调用java字符串的trim()方法，该方法会将字符串前后的空字符读去掉。</p>\n<p>方法二：自己实现去掉尾部空字符的方法</p>\n<h2 id=\"字符型常量和字符串常量的区别\"><a href=\"#字符型常量和字符串常量的区别\" class=\"headerlink\" title=\"字符型常量和字符串常量的区别?\"></a>字符型常量和字符串常量的区别?</h2><p>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符<br>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)<br>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</p>\n<blockquote>\n<p>java 编程思想第四版：2.2.2 节<img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/53914/20200806142232905.png\" alt=\"在这里插入图片描述\"><br>JVM内部使用的是UTF-16编码。不管代码文件中char使用的是什么编码，都将被JVM转化为UTF-16而且只用两个字节，也就是说Java中的char占用两个字节，只能表示Unicode中第一层（BMP）中的字符，对于其他字符会报错：Invalid Character Constant, 而String中是可以的。<br>如果一个抽象的字符在 UTF-16 编码下占 4 字节，显然它是不能放到 char 中的。换言之， char 中只能放 UTF-16 编码下只占 2 字节的那些字符。</p>\n</blockquote>\n<p>String.getBytes()是一个用于将String的内码转换为指定的外码的方法。无参数版使用平台的默认编码作为外码，有参数版使用参数指定的编码作为外码；将String的内容用外码编码好，结果放在一个新byte[]返回。<br>getBytes 实际是做编码转换，你应该显式传入一个参数来指定编码，否则它会使用缺省编码来转换。</p>\n<blockquote>\n<p>“字”在 GBK 编码下占 2 字节，在 UTF-16 编码下也占 2 字节，在 UTF-8 编码下占 3 字节，在 UTF-32 编码下占 4 字</p>\n</blockquote>\n<blockquote>\n<p>“ new String(“字”).getBytes().length 返回的是3 ”，这说明缺省编码是 UTF-8. 如果你显式地传入一个参数，比如这样“ new String(“字”).getBytes(“GBK”).length ”，那么返回就是 2.</p>\n</blockquote>\n<p>你可以在启动 JVM 时设置一个缺省编码，</p>\n<blockquote>\n<p>假设你的类叫 Main，那么在命令行中用 java 执行这个类时可以通过 file.encoding 参数设置一个缺省编码。 比如这样：java -Dfile.encoding=GBK Main 这时，你再执行不带参数的 getBytes() 方法时，new String(“字”).getBytes().length 返回的就是 2 了，因为现在缺省编码变成 GBK 了。 当然，如果这时你显式地指定编码，new String(“字”).getBytes(“UTF-8”).length 返回的则依旧是 3.</p>\n</blockquote>\n<p>否则，会使用所在操作系统环境下的缺省编码。</p>\n<blockquote>\n<p>通常，Windows 系统下是 GBK，Linux 和 Mac 是 UTF-8. 但有一点要注意，在 Windows 下使用 IDE 来运行时，比如 Eclipse，如果你的工程的缺省编码是 UTF-8，在 IDE 中运行你的程序时，会加上上述的 -Dfile.encoding=UTF-8 参数，这时，即便你在 Windows 下，缺省编码也是 UTF-8，而不是 GBK。</p>\n</blockquote>\n<p>总结:char在Java占两字节,大于两字节的不能存.在String里,每个字符大小不同。</p>\n<h2 id=\"Java中有哪些常见的关键字？\"><a href=\"#Java中有哪些常见的关键字？\" class=\"headerlink\" title=\"Java中有哪些常见的关键字？\"></a>Java中有哪些常见的关键字？</h2><p><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/53914/20200806143410908.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"Java泛型，以及类型擦除，常用的通配符\"><a href=\"#Java泛型，以及类型擦除，常用的通配符\" class=\"headerlink\" title=\"Java泛型，以及类型擦除，常用的通配符\"></a>Java泛型，以及类型擦除，常用的通配符</h2><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>\n<h3 id=\"Java泛型类型擦除以及类型擦除带来的问题\"><a href=\"#Java泛型类型擦除以及类型擦除带来的问题\" class=\"headerlink\" title=\"Java泛型类型擦除以及类型擦除带来的问题\"></a>Java泛型类型擦除以及类型擦除带来的问题</h3><p><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/53914/20200806152854603.png\" alt=\"在这里插入图片描述\"></p>\n<p><a href=\"https://www.cnblogs.com/wuqinglong/p/9456193.html\">https://www.cnblogs.com/wuqinglong/p/9456193.html</a><br>大家都知道，Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</p>\n<blockquote>\n<p>原始类型 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p>\n</blockquote>\n<p>如在代码中定义List<object>和List<string>等类型，在编译后都会变成List，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法在运行时刻出现的类型转换异常的情况，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。</string></object></p>\n<blockquote>\n<p>在程序中定义了一个ArrayList泛型类型实例化为Integer对象，如果直接调用add()方法，那么只能存储整数数据，不过当我们利用反射调用add()方法的时候，却可以存储字符串，这说明了Integer泛型实例在编译之后被擦除掉了，只保留了原始类型。</p>\n</blockquote>\n<p>在调用泛型方法时，可以指定泛型，也可以不指定泛型。</p>\n<ul>\n<li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object</li>\n<li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</li>\n</ul>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> {  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> {  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**不指定泛型的时候*/</span>  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> Test.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">//这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class=\"line\">        <span class=\"type\">Number</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> Test.add(<span class=\"number\">1</span>, <span class=\"number\">1.2</span>); <span class=\"comment\">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number  </span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> Test.add(<span class=\"number\">1</span>, <span class=\"string\">\"asd\"</span>); <span class=\"comment\">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object  </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**指定泛型的时候*/</span>  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> Test.&lt;Integer&gt;add(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> Test.&lt;Integer&gt;add(<span class=\"number\">1</span>, <span class=\"number\">2.2</span>); <span class=\"comment\">//编译错误，指定了Integer，不能为Float  </span></span><br><span class=\"line\">        <span class=\"type\">Number</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> Test.&lt;Number&gt;add(<span class=\"number\">1</span>, <span class=\"number\">2.2</span>); <span class=\"comment\">//指定为Number，所以可以为Integer和Float  </span></span><br><span class=\"line\">    }  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这是一个简单的泛型方法  </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T <span class=\"title function_\">add</span><span class=\"params\">(T x,T y)</span>{  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> y;  </span><br><span class=\"line\">    }  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为Object，就比如ArrayList中，如果不指定泛型，那么这个ArrayList可以存储任意的对象。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> {  </span><br><span class=\"line\">    <span class=\"type\">ArrayList</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();  </span><br><span class=\"line\">    list.add(<span class=\"number\">1</span>);  </span><br><span class=\"line\">    list.add(<span class=\"string\">\"121\"</span>);  </span><br><span class=\"line\">    list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());  </span><br><span class=\"line\">}  </span><br></pre></td></tr></tbody></table></figure>\n<h4 id=\"类型擦除引起的问题及解决方法\"><a href=\"#类型擦除引起的问题及解决方法\" class=\"headerlink\" title=\"类型擦除引起的问题及解决方法\"></a>类型擦除引起的问题及解决方法</h4><h5 id=\"3-1-先检查，再编译以及编译的对象和引用传递问题\"><a href=\"#3-1-先检查，再编译以及编译的对象和引用传递问题\" class=\"headerlink\" title=\"3-1.先检查，再编译以及编译的对象和引用传递问题\"></a>3-1.先检查，再编译以及编译的对象和引用传递问题</h5><p>Q: 既然说类型变量会在编译的时候擦除掉，那为什么我们往 ArrayList 创建的对象中添加整数会报错呢？不是说泛型变量String会在编译的时候变为Object类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？</p>\n<p>A: Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。</p>\n<p>那么，这个类型检查是针对谁的呢？我们先看看参数化类型和原始类型的兼容。</p>\n<p>以 ArrayList举例子，以前的写法:</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ArrayList</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();  </span><br></pre></td></tr></tbody></table></figure>\n\n<p>现在的写法:</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></tbody></table></figure>\n\n<p>如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; list1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>(); <span class=\"comment\">//第一种 情况</span></span><br><span class=\"line\"><span class=\"type\">ArrayList</span> <span class=\"variable\">list2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;(); <span class=\"comment\">//第二种 情况</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>这样是没有错误的，不过会有个编译时警告。</p>\n<p>不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。</p>\n<p>因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正设计类型检查的是它的引用，因为我们是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。</p>\n<p>举例子：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> {  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> {  </span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList&lt;String&gt; list1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();  </span><br><span class=\"line\">        list1.add(<span class=\"string\">\"1\"</span>); <span class=\"comment\">//编译通过  </span></span><br><span class=\"line\">        list1.add(<span class=\"number\">1</span>); <span class=\"comment\">//编译错误  </span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str1</span> <span class=\"operator\">=</span> list1.get(<span class=\"number\">0</span>); <span class=\"comment\">//返回类型就是String  </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ArrayList</span> <span class=\"variable\">list2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();  </span><br><span class=\"line\">        list2.add(<span class=\"string\">\"1\"</span>); <span class=\"comment\">//编译通过  </span></span><br><span class=\"line\">        list2.add(<span class=\"number\">1</span>); <span class=\"comment\">//编译通过  </span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> list2.get(<span class=\"number\">0</span>); <span class=\"comment\">//返回类型就是Object  </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;().add(<span class=\"string\">\"11\"</span>); <span class=\"comment\">//编译通过  </span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;().add(<span class=\"number\">22</span>); <span class=\"comment\">//编译错误  </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;().get(<span class=\"number\">0</span>); <span class=\"comment\">//返回类型就是String  </span></span><br><span class=\"line\">    }  </span><br><span class=\"line\"></span><br><span class=\"line\">}  </span><br></pre></td></tr></tbody></table></figure>\n\n<p>通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。</p>\n<p>泛型中参数话类型为什么不考虑继承关系？</p>\n<p>在Java中，像下面形式的引用传递是不允许的:</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; list1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Object&gt;(); <span class=\"comment\">//编译错误  </span></span><br><span class=\"line\">ArrayList&lt;Object&gt; list2 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;(); <span class=\"comment\">//编译错误</span></span><br><span class=\"line\">我们先看第一种情况，将第一种情况拓展成下面的形式：</span><br><span class=\"line\"></span><br><span class=\"line\">ArrayList&lt;Object&gt; list1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Object&gt;();  </span><br><span class=\"line\">list1.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>());  </span><br><span class=\"line\">list1.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>());  </span><br><span class=\"line\">ArrayList&lt;String&gt; list2 = list1; <span class=\"comment\">//编译错误</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>实际上，在第4行代码的时候，就会有编译错误。那么，我们先假设它编译没错。那么当我们使用list2引用用get()方法取值的时候，返回的都是String类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了Object类型的对象，这样就会有ClassCastException了。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。</p>\n<p>再看第二种情况，将第二种情况拓展成下面的形式：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; list1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();  </span><br><span class=\"line\">list1.add(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>());  </span><br><span class=\"line\">list1.add(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">ArrayList&lt;Object&gt; list2 = list1; <span class=\"comment\">//编译错误</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>没错，这样的情况比第一种情况好的多，最起码，在我们用list2取值的时候不会出现ClassCastException，因为是从String转换为Object。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，你如果又用list2往里面add()新的对象，那么到时候取得时候，我怎么知道我取出来的到底是String类型的，还是Object类型的呢？</p>\n<p>所以，要格外注意，泛型中的引用传递的问题。</p>\n<h5 id=\"3-2-自动类型转换\"><a href=\"#3-2-自动类型转换\" class=\"headerlink\" title=\"3-2.自动类型转换\"></a>3-2.自动类型转换</h5><p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。</p>\n<p>既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？</p>\n<p>看下ArrayList.get()方法：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> {  </span><br><span class=\"line\"></span><br><span class=\"line\">    RangeCheck(index);  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (E) elementData[index];  </span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>可以看到，在return之前，会根据泛型变量进行强转。假设泛型类型变量为Date，虽然泛型信息会被擦除掉，但是会将(E) elementData[index]，编译为(Date)elementData[index]。所以我们不用自己进行强转。当存取一个泛型域时也会自动插入强制类型转换。假设Pair类的value域是public的，那么表达式：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">date</span> <span class=\"operator\">=</span> pair.value;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>也会自动地在结果字节码中插入强制类型转换。</p>\n<h5 id=\"3-3-类型擦除与多态的冲突和解决方法\"><a href=\"#3-3-类型擦除与多态的冲突和解决方法\" class=\"headerlink\" title=\"3-3.类型擦除与多态的冲突和解决方法\"></a>3-3.类型擦除与多态的冲突和解决方法</h5><p>现在有这样一个泛型类：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Pair</span>&lt;T&gt; {  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> T value;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"title function_\">getValue</span><span class=\"params\">()</span> {  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;  </span><br><span class=\"line\">    }  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(T value)</span> {  </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = value;  </span><br><span class=\"line\">    }  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>然后我们想要一个子类继承它。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DateInter</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Pair</span>&lt;Date&gt; {  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(Date value)</span> {  </span><br><span class=\"line\">        <span class=\"built_in\">super</span>.setValue(value);  </span><br><span class=\"line\">    }  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Date <span class=\"title function_\">getValue</span><span class=\"params\">()</span> {  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getValue();  </span><br><span class=\"line\">    }  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>在这个子类中，我们设定父类的泛型类型为Pair<date>，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型。</date></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Date <span class=\"title function_\">getValue</span><span class=\"params\">()</span> {  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;  </span><br><span class=\"line\">}  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(Date value)</span> {  </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value = value;  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的@Override标签中也可以看到，一点问题也没有，实际上是这样的吗？</p>\n<p>分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类编译之后会变成下面的样子：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Pair</span> {  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object value;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">getValue</span><span class=\"params\">()</span> {  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;  </span><br><span class=\"line\">    }  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(Object  value)</span> {  </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = value;  </span><br><span class=\"line\">    }  </span><br><span class=\"line\">}  </span><br></pre></td></tr></tbody></table></figure>\n\n<p>再看子类的两个重写的方法的类型：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(Date value)</span> {  </span><br><span class=\"line\">    <span class=\"built_in\">super</span>.setValue(value);  </span><br><span class=\"line\">}  </span><br><span class=\"line\"><span class=\"meta\">@Override</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> Date <span class=\"title function_\">getValue</span><span class=\"params\">()</span> {  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getValue();  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>先来分析setValue方法，父类的类型是Object，而子类的类型是Date，参数类型不一样，这如果是在普通的继承关系中，根本就不会是重写，而是重载。<br>　　<br>我们在一个main方法测试一下：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException {  </span><br><span class=\"line\">        <span class=\"type\">DateInter</span> <span class=\"variable\">dateInter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DateInter</span>();  </span><br><span class=\"line\">        dateInter.setValue(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());                  </span><br><span class=\"line\">        dateInter.setValue(<span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>()); <span class=\"comment\">//编译错误  </span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>如果是重载，那么子类中两个setValue方法，一个是参数Object类型，一个是Date类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，确实是重写了，而不是重载了。</p>\n<p>为什么会这样呢？</p>\n<p>原因是这样的，我们传入父类的泛型类型是Date，Pair<date>，我们的本意是将泛型类变为如下：</date></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Pair</span> {  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date value;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Date <span class=\"title function_\">getValue</span><span class=\"params\">()</span> {  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;  </span><br><span class=\"line\">    }  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(Date value)</span> {  </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = value;  </span><br><span class=\"line\">    }  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>然后再子类中重写参数类型为Date的那两个方法，实现继承中的多态。</p>\n<p>可是由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的Date类型参数的方法啊。</p>\n<p>于是JVM采用了一个特殊的方法，来完成这项功能，那就是桥方法。</p>\n<p>首先，我们用javap -c className的方式反编译下DateInter子类的字节码，结果如下：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">com</span>.tao.test.DateInter <span class=\"keyword\">extends</span> <span class=\"title class_\">com</span>.tao.test.Pair&lt;java.util.Date&gt; {  </span><br><span class=\"line\">  com.tao.test.DateInter();  </span><br><span class=\"line\">    Code:  </span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0  </span><br><span class=\"line\">       <span class=\"number\">1</span>: invokespecial #<span class=\"number\">8</span>                  <span class=\"comment\">// Method com/tao/test/Pair.\"&lt;init&gt;\":()V  </span></span><br><span class=\"line\">       <span class=\"number\">4</span>: <span class=\"keyword\">return</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(java.util.Date)</span>;  <span class=\"comment\">//我们重写的setValue方法  </span></span><br><span class=\"line\">    Code:  </span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0  </span><br><span class=\"line\">       <span class=\"number\">1</span>: aload_1  </span><br><span class=\"line\">       <span class=\"number\">2</span>: invokespecial #<span class=\"number\">16</span>                 <span class=\"comment\">// Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  </span></span><br><span class=\"line\">       <span class=\"number\">5</span>: <span class=\"keyword\">return</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> java.util.Date <span class=\"title function_\">getValue</span><span class=\"params\">()</span>;    <span class=\"comment\">//我们重写的getValue方法  </span></span><br><span class=\"line\">    Code:  </span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0  </span><br><span class=\"line\">       <span class=\"number\">1</span>: invokespecial #<span class=\"number\">23</span>                 <span class=\"comment\">// Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  </span></span><br><span class=\"line\">       <span class=\"number\">4</span>: checkcast     #<span class=\"number\">26</span>                 <span class=\"comment\">// class java/util/Date  </span></span><br><span class=\"line\">       <span class=\"number\">7</span>: areturn  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> java.lang.Object <span class=\"title function_\">getValue</span><span class=\"params\">()</span>;     <span class=\"comment\">//编译时由编译器生成的巧方法  </span></span><br><span class=\"line\">    Code:  </span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0  </span><br><span class=\"line\">       <span class=\"number\">1</span>: invokevirtual #<span class=\"number\">28</span>                 <span class=\"comment\">// Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  </span></span><br><span class=\"line\">       <span class=\"number\">4</span>: areturn  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(java.lang.Object)</span>;   <span class=\"comment\">//编译时由编译器生成的巧方法  </span></span><br><span class=\"line\">    Code:  </span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0  </span><br><span class=\"line\">       <span class=\"number\">1</span>: aload_1  </span><br><span class=\"line\">       <span class=\"number\">2</span>: checkcast     #<span class=\"number\">26</span>                 <span class=\"comment\">// class java/util/Date  </span></span><br><span class=\"line\">       <span class=\"number\">5</span>: invokevirtual #<span class=\"number\">30</span>                 <span class=\"comment\">// Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  </span></span><br><span class=\"line\">       <span class=\"number\">8</span>: <span class=\"keyword\">return</span>  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>从编译的结果来看，我们本意重写setValue和getValue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。</p>\n<p>所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。</p>\n<p>不过，要提到一点，这里面的setValue和getValue这两个桥方法的意义又有不同。</p>\n<p>setValue方法是为了解决类型擦除与多态之间的冲突。</p>\n<p>而getValue却有普遍的意义，怎么说呢，如果这是一个普通的继承关系：</p>\n<p>那么父类的setValue方法如下：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ObjectgetValue</span><span class=\"params\">()</span> {  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getValue();  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>而子类重写的方法是：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Date <span class=\"title function_\">getValue</span><span class=\"params\">()</span> {  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getValue();  </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>其实这在普通的类继承中也是普遍存在的重写，这就是协变。<br><a href=\"https://extremegtr.github.io/2016/07/11/Covariance-And-Contravariance-In-Java/\">https://extremegtr.github.io/2016/07/11/Covariance-And-Contravariance-In-Java/</a></p>\n<blockquote>\n<p>协变 / 共变（covariance）指的是子类型关系在类型变换的作用下保持原样。<br>不可变（invariance） 表示子类型关系在类型变换的作用下，既没有协变的效果，也没有逆变的效果。<br>逆变 / 反变（contravariance）指的是子类型关系在类型变换的作用下发生逆转。<br>双变（bivariance）表示子类型关系在类型变换的作用下同时拥有协变与逆变2种效果。<br><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/53914/20200806151224399.png\" alt=\"在这里插入图片描述\"><br>Java支持协变数组，你可能会问Java支持逆变数组吗？答案是：Java不支持逆变数组。<br><a href=\"https://codingnote.com/2020/03/08/java-covariant-contravariant-invariant/\">https://codingnote.com/2020/03/08/java-covariant-contravariant-invariant/</a><br><a href=\"https://extremegtr.github.io/2016/05/30/JavaSE-study-advanced-generics/#u901A_u914D_u7B26_uFF08Wildcard_uFF09\">https://extremegtr.github.io/2016/05/30/JavaSE-study-advanced-generics/#u901A_u914D_u7B26_uFF08Wildcard_uFF09</a><br>Java下限通配符实现逆变<br>由于Java泛型的不可变性，generateIntegers() 生成的List<integer>不能放到输入参数output指定的List<number>中。那么有没有办法把 List<integer> 放到List<number>中呢？<br>答案是使用下限通配符来实现逆变。<br>正如大家所熟知的一个概念：在Java中，所有类型的父类型都是Object类型，方法的形参类型是Object，那这个方法就能接受任何类型的参数传递进来。这个推论正是实现该需求的关键所在。<br>根据上面的推导，我们可能会这么认为：既然Object是所有类型的父类型，那么List<object>肯定是所有List参数化类型的父类型。但事实却不是这样的，即2个类型实参之间具有子类型关系，但使用它们对同一泛型进行参数化后的类型并没有保持这种子类型关系。与上文描述一致。<br>List<object>表示的只是它能够存储任意元素类型，而并没有表示它是所有参数化类型的父类型。所以这种解决方案是完全行不通的。</object></object></number></integer></number></integer></p>\n</blockquote>\n<p>并且，还有一点也许会有疑问，子类中的桥方法Object getValue()和Date getValue()是同 时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。</p>\n<p>总结：</p>\n<p>   在Java中，数组具有协变性，简单点来说就是子类型数组可以赋值给父类型数组进行使用，比如将Integer数组赋值给Object数组，这样来使用数组不会有警告甚至报错，但会存在运行时出错的风险，所以数组的协变性是具有瑕疵的，虽然它能这么用，但我们必须为此而承受一定风险。</p>\n<p>Java泛型就不可以做出像数组这样的行为，因为泛型没有内建的协变类型，Java泛型具有不可变性（不具备协变性和逆变性）。但是，为了兼容遗留代码而被保留下来的原生类型确实可以做出这样的行为，但同时我们也非常清楚使用它就像使用数组的协变性一样意味着代码变得不再安全。</p>\n<p>　　所以，制定Java标准的那群人想出了个法子使得泛型像数组一样具有这些特性，同时这种代替原生类型的方案必须是绝对安全的：他们通过给泛型增加通配符特性使得泛型在参数化后具有协变性或逆变性。</p>\n<h5 id=\"3-4-泛型类型变量不能是基本数据类型\"><a href=\"#3-4-泛型类型变量不能是基本数据类型\" class=\"headerlink\" title=\"3-4.泛型类型变量不能是基本数据类型\"></a>3-4.泛型类型变量不能是基本数据类型</h5><p>不能用类型参数替换基本类型。就比如，没有ArrayList<double>，只有ArrayList<double>。因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储double值，只能引用Double的值。</double></double></p>\n<h5 id=\"3-5-编译时集合的instanceof\"><a href=\"#3-5-编译时集合的instanceof\" class=\"headerlink\" title=\"3-5.编译时集合的instanceof\"></a>3-5.编译时集合的instanceof</h5><figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; arrayList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></tbody></table></figure>\n\n<p>因为类型擦除之后，ArrayList<string>只剩下原始类型，泛型信息String不存在了。</string></p>\n<p>那么，编译时进行类型查询的时候使用下面的方法是错误的</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>( arrayList <span class=\"keyword\">instanceof</span> ArrayList&lt;String&gt;)</span><br></pre></td></tr></tbody></table></figure>\n<h5 id=\"3-6-泛型在静态方法和静态类中的问题\"><a href=\"#3-6-泛型在静态方法和静态类中的问题\" class=\"headerlink\" title=\"3-6.泛型在静态方法和静态类中的问题\"></a>3-6.泛型在静态方法和静态类中的问题</h5><p>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数</p>\n<p>举例说明：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test2</span>&lt;T&gt; {    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> T one;   <span class=\"comment\">//编译错误    </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span>  T <span class=\"title function_\">show</span><span class=\"params\">(T one)</span>{ <span class=\"comment\">//编译错误    </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;    </span><br><span class=\"line\">    }    </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。</p>\n<p>但是要注意区分下面的一种情况：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test2</span>&lt;T&gt; {    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T &gt;T <span class=\"title function_\">show</span><span class=\"params\">(T one)</span>{ <span class=\"comment\">//这是正确的    </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;    </span><br><span class=\"line\">    }    </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的 T，而不是泛型类中的T。</p>\n<p>==和equals的区别</p>\n<p>== : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)<br>equals() 方法存在两种使用情况：</p>\n<ul>\n<li><p>情况 1：类没有覆盖 equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。使用的默认是 Object类equals()方法。</p>\n</li>\n<li><p>情况 2：类覆盖了 equals()方法。一般，我们都覆盖 equals()方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</p>\n</li>\n<li><p>String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</p>\n</li>\n<li><p>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</p>\n</li>\n</ul>\n<h2 id=\"hashCode-与-equals\"><a href=\"#hashCode-与-equals\" class=\"headerlink\" title=\"hashCode()与 equals()\"></a>hashCode()与 equals()</h2><h3 id=\"hashCode-介绍\"><a href=\"#hashCode-介绍\" class=\"headerlink\" title=\"hashCode()介绍:\"></a>hashCode()介绍:</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>\n<blockquote>\n<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>\n</blockquote>\n<h3 id=\"为什么要有-hashCode？\"><a href=\"#为什么要有-hashCode？\" class=\"headerlink\" title=\"为什么要有 hashCode？\"></a>为什么要有 hashCode？</h3><p>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode？</p>\n<p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（Head fist java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>\n<p>为什么重写 equals 时必须重写 hashCode 方法？</p>\n<p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。</p>\n<blockquote>\n<p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>\n</blockquote>\n<p>String类对hashcode的重写</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a hash code for this string. The hash code for a</span></span><br><span class=\"line\"><span class=\"comment\"> * {<span class=\"doctag\">@code</span> String} object is computed as</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * using {<span class=\"doctag\">@code</span> int} arithmetic, where {<span class=\"doctag\">@code</span> s[i]} is the</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;i&gt;i&lt;/i&gt;th character of the string, {<span class=\"doctag\">@code</span> n} is the length of</span></span><br><span class=\"line\"><span class=\"comment\"> * the string, and {<span class=\"doctag\">@code</span> ^} indicates exponentiation.</span></span><br><span class=\"line\"><span class=\"comment\"> * (The hash value of the empty string is zero.)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span>  a hash code value for this object.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"type\">char</span> val[] = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; value.length; i++) {</span><br><span class=\"line\">            h = <span class=\"number\">31</span> * h + val[i];</span><br><span class=\"line\">        }</span><br><span class=\"line\">        hash = h;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p>在《Effective Java》第 42 页就有对 hashCode 为什么采用 31 做了说明：之所以使用 31， 是因为他是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补0）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 31 有个很好的性能，即用移位和减法来代替乘法，可以得到更好的性能： 31 * i == (i &lt;&lt; 5）- i， 现代的 VM 可以自动完成这种优化。这个公式可以很简单的推导出来。<br>31可以由31 * i ==  (i &lt;&lt; 5) - i来表示，现在很多虚拟机里面都有做相关优化，使用31的原因可能是为了更好的分配hash地址，并且31只占用5bits！在java乘法中如果数字相乘过大会导致溢出的问题，从而导致数据的丢失，而31则是素数（质数）而且不是很长的数字，最终它被选择为相乘的系数的原因。</p>\n</blockquote>\n<h2 id=\"Java中的几种基本数据类型\"><a href=\"#Java中的几种基本数据类型\" class=\"headerlink\" title=\"Java中的几种基本数据类型\"></a>Java中的几种基本数据类型</h2><p><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/53914/20200806154245121.png\" alt=\"在这里插入图片描述\"><br>注意：</p>\n<ul>\n<li>Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析：</li>\n<li>char a = ‘h’char :单引号，String a = “hello” :双引号</li>\n</ul>\n<p>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Boolean <span class=\"title function_\">valueOf</span><span class=\"params\">(<span class=\"type\">boolean</span> b)</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (b ? TRUE : FALSE);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CharacterCache</span> {         </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">CharacterCache</span><span class=\"params\">()</span>{}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Character cache[] = <span class=\"keyword\">new</span> <span class=\"title class_\">Character</span>[<span class=\"number\">127</span> + <span class=\"number\">1</span>];          </span><br><span class=\"line\">    <span class=\"keyword\">static</span> {             </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; cache.length; i++)                 </span><br><span class=\"line\">            cache[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">Character</span>((<span class=\"type\">char</span>)i);         </span><br><span class=\"line\">    }   </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title function_\">valueOf</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(i);</span><br><span class=\"line\">    }</span><br></pre></td></tr></tbody></table></figure>\n\n<blockquote>\n<p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。<br>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。<br>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。<br>（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。 </p>\n</blockquote>\n<blockquote>\n<p>为啥把缓存设置为[-128，127]区间？<br>1.技术规范。JLS7 5.1.7：If the value p being boxed is an integer literal of type int between -128 and 127 inclusive (§3.10.1), or the boolean literal true or false (§3.10.3), or a character literal between ‘\\u0000’ and ‘\\u007f’ inclusive (§3.10.4), then let a and b be the results of any two boxing conversions of p . It is always the case that a == b .<br>2.性能和资源之间的权衡（当然也可以调整缓存的正向最大值，自己看 IntegerCache 类的实现）。</p>\n<p><strong>如果超出了范围，会从堆区new一个Integer对象来存放值。</strong></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">a1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">12</span>);</span><br><span class=\"line\">     <span class=\"type\">Integer</span> <span class=\"variable\">a2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">12</span>);</span><br><span class=\"line\">     <span class=\"type\">Integer</span> <span class=\"variable\">b1</span> <span class=\"operator\">=</span> -<span class=\"number\">129</span>;</span><br><span class=\"line\">     <span class=\"type\">Integer</span> <span class=\"variable\">b2</span> <span class=\"operator\">=</span> -<span class=\"number\">129</span>;</span><br><span class=\"line\">     <span class=\"type\">Integer</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> <span class=\"number\">128</span>;</span><br><span class=\"line\">     <span class=\"type\">Integer</span> <span class=\"variable\">c2</span> <span class=\"operator\">=</span> -<span class=\"number\">128</span>;</span><br><span class=\"line\">     System.out.println(a1 == a2);   <span class=\"comment\">//false</span></span><br><span class=\"line\">     System.out.println(b1==b2);     <span class=\"comment\">//false </span></span><br><span class=\"line\">     System.out.println(c1 == c2);   <span class=\"comment\">//false</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。</strong></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i1</span> <span class=\"operator\">=</span> <span class=\"number\">33</span>;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i2</span> <span class=\"operator\">=</span> <span class=\"number\">33</span>;</span><br><span class=\"line\">System.out.println(i1 == i2);<span class=\"comment\">// 输出 true</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i11</span> <span class=\"operator\">=</span> <span class=\"number\">333</span>;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i22</span> <span class=\"operator\">=</span> <span class=\"number\">333</span>;</span><br><span class=\"line\">System.out.println(i11 == i22);<span class=\"comment\">// 输出 false</span></span><br><span class=\"line\"><span class=\"type\">Double</span> <span class=\"variable\">i3</span> <span class=\"operator\">=</span> <span class=\"number\">1.2</span>;</span><br><span class=\"line\"><span class=\"type\">Double</span> <span class=\"variable\">i4</span> <span class=\"operator\">=</span> <span class=\"number\">1.2</span>;</span><br><span class=\"line\">System.out.println(i3 == i4);<span class=\"comment\">// 输出 false</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"方法（函数）\"><a href=\"#方法（函数）\" class=\"headerlink\" title=\"方法（函数）\"></a>方法（函数）</h2><p>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。<br>在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>\n<p>而对象引用作为参数就不一样</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span>[] arr = { <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> };</span><br><span class=\"line\">    System.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    change(arr);</span><br><span class=\"line\">    System.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">change</span><span class=\"params\">(<span class=\"type\">int</span>[] array)</span> {</span><br><span class=\"line\">    <span class=\"comment\">// 将数组的第一个元素变为0</span></span><br><span class=\"line\">    array[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>结果：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br></pre></td></tr></tbody></table></figure>\n<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>\n<p>我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</p>\n<p>很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> {</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> {</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">\"小张\"</span>);</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">\"小李\"</span>);</span><br><span class=\"line\">        Test.swap(s1, s2);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"s1:\"</span> + s1.getName());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"s2:\"</span> + s2.getName());</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(Student x, Student y)</span> {</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> x;</span><br><span class=\"line\">        x = y;</span><br><span class=\"line\">        y = temp;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"x:\"</span> + x.getName());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"y:\"</span> + y.getName());</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>结果：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x:小李</span><br><span class=\"line\">y:小张</span><br><span class=\"line\">s1:小张</span><br><span class=\"line\">s2:小李</span><br></pre></td></tr></tbody></table></figure>\n<p>解析：</p>\n<p>交换之前：</p>\n<p><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/53914/20200806155803123.png\" alt=\"在这里插入图片描述\"></p>\n<p>交换之后：</p>\n<p><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/53914/20200806155808662.png\" alt=\"在这里插入图片描述\"></p>\n<p>通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</p>\n<p><strong>总结</strong></p>\n<p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的。</p>\n<p>下面再总结一下 Java 中方法参数的使用情况：</p>\n<ul>\n<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li>\n<li>一个方法可以改变一个对象参数的状态。</li>\n<li>一个方法不能让对象参数引用一个新的对象。</li>\n</ul>\n<p><strong>参考：</strong></p>\n<p>《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节</p>\n<h2 id=\"重载和重写\"><a href=\"#重载和重写\" class=\"headerlink\" title=\"重载和重写\"></a>重载和重写</h2><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>\n<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法<br>《Java 核心技术》中是这么说的<br><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/53914/202008061601321.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>综上</strong>：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>\n<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>\n<ul>\n<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>\n<li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>\n<li>构造方法无法被重写</li>\n</ul>\n<p><strong>综上</strong>：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</p>\n<p><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/53914/20200806160323274.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"深拷贝-vs-浅拷贝\"><a href=\"#深拷贝-vs-浅拷贝\" class=\"headerlink\" title=\"深拷贝 vs 浅拷贝\"></a>深拷贝 vs 浅拷贝</h2><p>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。<br>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。<br><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/53914/20200806160355775.png\" alt=\"在这里插入图片描述\"></p>\n","more":"<h2 id=\"Java程序怎么样运行的\"><a href=\"#Java程序怎么样运行的\" class=\"headerlink\" title=\"Java程序怎么样运行的\"></a><strong>Java程序怎么样运行的</strong></h2><p>Java 程序从源代码到运行一般有下面 3 步：<br><img src=\"/cn/posts/53914/2020080614124077.png\" alt=\"在这里插入图片描述\"><br>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p>\n<blockquote>\n<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p>\n</blockquote>\n<p>总结：</p>\n<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>\n<h2 id=\"为什么说-Java-语言“编译与解释并存”？\"><a href=\"#为什么说-Java-语言“编译与解释并存”？\" class=\"headerlink\" title=\"为什么说 Java 语言“编译与解释并存”？\"></a>为什么说 Java 语言“编译与解释并存”？</h2><p>高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p>\n<p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存</p>\n<h2 id=\"java与C语言在字符串结束符上的区别\"><a href=\"#java与C语言在字符串结束符上的区别\" class=\"headerlink\" title=\"java与C语言在字符串结束符上的区别\"></a>java与C语言在字符串结束符上的区别</h2><p>在C语言中字符串或字符数组最后都会有一个额外的字符‘\\0’来表示结束，而在java语言中没有结束符这一概念。<br>参考：<a href=\"https://blog.csdn.net/sszgg2006/article/details/49148189\">https://blog.csdn.net/sszgg2006/article/details/49148189</a></p>\n<blockquote>\n<p><strong>java中无需结束符的原因</strong><br>Java里面一切都是对象，是对象的话，字符串肯定就有长度，即然有长度，编译器就可以确定要输出的字符个数，当然也就没有必要去浪费那1字节的空间用以标明字符串的结束了。比如，数组对象里有一个属性length,就是数组的长度，String类里面有方法length()可以确定字符串的长度，因此对于输出函数来说，有直接的大小可以判断字符串的边界，编译器就没必要再去浪费一个空间标识字符串的结束。</p>\n</blockquote>\n<p><strong>java字符串末尾空字符的处理</strong></p>\n<p>java和c通信的时候，由于c中的char中有结束符的，所以当java收到C发来的字符串时，后面往往会有若干空字符，如果不做处理的话，java会对其一并输出，为了将空字符处理掉不输出，可以采用如下两种方法：</p>\n<p>方法一:</p>\n<p>调用java字符串的trim()方法，该方法会将字符串前后的空字符读去掉。</p>\n<p>方法二：自己实现去掉尾部空字符的方法</p>\n<h2 id=\"字符型常量和字符串常量的区别\"><a href=\"#字符型常量和字符串常量的区别\" class=\"headerlink\" title=\"字符型常量和字符串常量的区别?\"></a>字符型常量和字符串常量的区别?</h2><p>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符<br>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)<br>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</p>\n<blockquote>\n<p>java 编程思想第四版：2.2.2 节<img src=\"/cn/posts/53914/20200806142232905.png\" alt=\"在这里插入图片描述\"><br>JVM内部使用的是UTF-16编码。不管代码文件中char使用的是什么编码，都将被JVM转化为UTF-16而且只用两个字节，也就是说Java中的char占用两个字节，只能表示Unicode中第一层（BMP）中的字符，对于其他字符会报错：Invalid Character Constant, 而String中是可以的。<br>如果一个抽象的字符在 UTF-16 编码下占 4 字节，显然它是不能放到 char 中的。换言之， char 中只能放 UTF-16 编码下只占 2 字节的那些字符。</p>\n</blockquote>\n<p>String.getBytes()是一个用于将String的内码转换为指定的外码的方法。无参数版使用平台的默认编码作为外码，有参数版使用参数指定的编码作为外码；将String的内容用外码编码好，结果放在一个新byte[]返回。<br>getBytes 实际是做编码转换，你应该显式传入一个参数来指定编码，否则它会使用缺省编码来转换。</p>\n<blockquote>\n<p>“字”在 GBK 编码下占 2 字节，在 UTF-16 编码下也占 2 字节，在 UTF-8 编码下占 3 字节，在 UTF-32 编码下占 4 字</p>\n</blockquote>\n<blockquote>\n<p>“ new String(“字”).getBytes().length 返回的是3 ”，这说明缺省编码是 UTF-8. 如果你显式地传入一个参数，比如这样“ new String(“字”).getBytes(“GBK”).length ”，那么返回就是 2.</p>\n</blockquote>\n<p>你可以在启动 JVM 时设置一个缺省编码，</p>\n<blockquote>\n<p>假设你的类叫 Main，那么在命令行中用 java 执行这个类时可以通过 file.encoding 参数设置一个缺省编码。 比如这样：java -Dfile.encoding=GBK Main 这时，你再执行不带参数的 getBytes() 方法时，new String(“字”).getBytes().length 返回的就是 2 了，因为现在缺省编码变成 GBK 了。 当然，如果这时你显式地指定编码，new String(“字”).getBytes(“UTF-8”).length 返回的则依旧是 3.</p>\n</blockquote>\n<p>否则，会使用所在操作系统环境下的缺省编码。</p>\n<blockquote>\n<p>通常，Windows 系统下是 GBK，Linux 和 Mac 是 UTF-8. 但有一点要注意，在 Windows 下使用 IDE 来运行时，比如 Eclipse，如果你的工程的缺省编码是 UTF-8，在 IDE 中运行你的程序时，会加上上述的 -Dfile.encoding=UTF-8 参数，这时，即便你在 Windows 下，缺省编码也是 UTF-8，而不是 GBK。</p>\n</blockquote>\n<p>总结:char在Java占两字节,大于两字节的不能存.在String里,每个字符大小不同。</p>\n<h2 id=\"Java中有哪些常见的关键字？\"><a href=\"#Java中有哪些常见的关键字？\" class=\"headerlink\" title=\"Java中有哪些常见的关键字？\"></a>Java中有哪些常见的关键字？</h2><p><img src=\"/cn/posts/53914/20200806143410908.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"Java泛型，以及类型擦除，常用的通配符\"><a href=\"#Java泛型，以及类型擦除，常用的通配符\" class=\"headerlink\" title=\"Java泛型，以及类型擦除，常用的通配符\"></a>Java泛型，以及类型擦除，常用的通配符</h2><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>\n<h3 id=\"Java泛型类型擦除以及类型擦除带来的问题\"><a href=\"#Java泛型类型擦除以及类型擦除带来的问题\" class=\"headerlink\" title=\"Java泛型类型擦除以及类型擦除带来的问题\"></a>Java泛型类型擦除以及类型擦除带来的问题</h3><p><img src=\"/cn/posts/53914/20200806152854603.png\" alt=\"在这里插入图片描述\"></p>\n<p><a href=\"https://www.cnblogs.com/wuqinglong/p/9456193.html\">https://www.cnblogs.com/wuqinglong/p/9456193.html</a><br>大家都知道，Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。</p>\n<blockquote>\n<p>原始类型 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p>\n</blockquote>\n<p>如在代码中定义List<Object>和List<String>等类型，在编译后都会变成List，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法在运行时刻出现的类型转换异常的情况，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。</String></Object></p>\n<blockquote>\n<p>在程序中定义了一个ArrayList泛型类型实例化为Integer对象，如果直接调用add()方法，那么只能存储整数数据，不过当我们利用反射调用add()方法的时候，却可以存储字符串，这说明了Integer泛型实例在编译之后被擦除掉了，只保留了原始类型。</p>\n</blockquote>\n<p>在调用泛型方法时，可以指定泛型，也可以不指定泛型。</p>\n<ul>\n<li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object</li>\n<li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**不指定泛型的时候*/</span>  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> Test.add(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">//这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class=\"line\">        <span class=\"type\">Number</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> Test.add(<span class=\"number\">1</span>, <span class=\"number\">1.2</span>); <span class=\"comment\">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number  </span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> Test.add(<span class=\"number\">1</span>, <span class=\"string\">&quot;asd&quot;</span>); <span class=\"comment\">//这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object  </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**指定泛型的时候*/</span>  </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> Test.&lt;Integer&gt;add(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> Test.&lt;Integer&gt;add(<span class=\"number\">1</span>, <span class=\"number\">2.2</span>); <span class=\"comment\">//编译错误，指定了Integer，不能为Float  </span></span><br><span class=\"line\">        <span class=\"type\">Number</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> Test.&lt;Number&gt;add(<span class=\"number\">1</span>, <span class=\"number\">2.2</span>); <span class=\"comment\">//指定为Number，所以可以为Integer和Float  </span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这是一个简单的泛型方法  </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T <span class=\"title function_\">add</span><span class=\"params\">(T x,T y)</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> y;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为Object，就比如ArrayList中，如果不指定泛型，那么这个ArrayList可以存储任意的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;  </span><br><span class=\"line\">    <span class=\"type\">ArrayList</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();  </span><br><span class=\"line\">    list.add(<span class=\"number\">1</span>);  </span><br><span class=\"line\">    list.add(<span class=\"string\">&quot;121&quot;</span>);  </span><br><span class=\"line\">    list.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h4 id=\"类型擦除引起的问题及解决方法\"><a href=\"#类型擦除引起的问题及解决方法\" class=\"headerlink\" title=\"类型擦除引起的问题及解决方法\"></a>类型擦除引起的问题及解决方法</h4><h5 id=\"3-1-先检查，再编译以及编译的对象和引用传递问题\"><a href=\"#3-1-先检查，再编译以及编译的对象和引用传递问题\" class=\"headerlink\" title=\"3-1.先检查，再编译以及编译的对象和引用传递问题\"></a>3-1.先检查，再编译以及编译的对象和引用传递问题</h5><p>Q: 既然说类型变量会在编译的时候擦除掉，那为什么我们往 ArrayList 创建的对象中添加整数会报错呢？不是说泛型变量String会在编译的时候变为Object类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？</p>\n<p>A: Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。</p>\n<p>那么，这个类型检查是针对谁的呢？我们先看看参数化类型和原始类型的兼容。</p>\n<p>以 ArrayList举例子，以前的写法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ArrayList</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();  </span><br></pre></td></tr></table></figure>\n\n<p>现在的写法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; list1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>(); <span class=\"comment\">//第一种 情况</span></span><br><span class=\"line\"><span class=\"type\">ArrayList</span> <span class=\"variable\">list2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;(); <span class=\"comment\">//第二种 情况</span></span><br></pre></td></tr></table></figure>\n\n<p>这样是没有错误的，不过会有个编译时警告。</p>\n<p>不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。</p>\n<p>因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正设计类型检查的是它的引用，因为我们是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。</p>\n<p>举例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">        ArrayList&lt;String&gt; list1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();  </span><br><span class=\"line\">        list1.add(<span class=\"string\">&quot;1&quot;</span>); <span class=\"comment\">//编译通过  </span></span><br><span class=\"line\">        list1.add(<span class=\"number\">1</span>); <span class=\"comment\">//编译错误  </span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str1</span> <span class=\"operator\">=</span> list1.get(<span class=\"number\">0</span>); <span class=\"comment\">//返回类型就是String  </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ArrayList</span> <span class=\"variable\">list2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();  </span><br><span class=\"line\">        list2.add(<span class=\"string\">&quot;1&quot;</span>); <span class=\"comment\">//编译通过  </span></span><br><span class=\"line\">        list2.add(<span class=\"number\">1</span>); <span class=\"comment\">//编译通过  </span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> list2.get(<span class=\"number\">0</span>); <span class=\"comment\">//返回类型就是Object  </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;().add(<span class=\"string\">&quot;11&quot;</span>); <span class=\"comment\">//编译通过  </span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;().add(<span class=\"number\">22</span>); <span class=\"comment\">//编译错误  </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;().get(<span class=\"number\">0</span>); <span class=\"comment\">//返回类型就是String  </span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。</p>\n<p>泛型中参数话类型为什么不考虑继承关系？</p>\n<p>在Java中，像下面形式的引用传递是不允许的:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; list1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Object&gt;(); <span class=\"comment\">//编译错误  </span></span><br><span class=\"line\">ArrayList&lt;Object&gt; list2 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;(); <span class=\"comment\">//编译错误</span></span><br><span class=\"line\">我们先看第一种情况，将第一种情况拓展成下面的形式：</span><br><span class=\"line\"></span><br><span class=\"line\">ArrayList&lt;Object&gt; list1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Object&gt;();  </span><br><span class=\"line\">list1.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>());  </span><br><span class=\"line\">list1.add(<span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>());  </span><br><span class=\"line\">ArrayList&lt;String&gt; list2 = list1; <span class=\"comment\">//编译错误</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上，在第4行代码的时候，就会有编译错误。那么，我们先假设它编译没错。那么当我们使用list2引用用get()方法取值的时候，返回的都是String类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了Object类型的对象，这样就会有ClassCastException了。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。</p>\n<p>再看第二种情况，将第二种情况拓展成下面的形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; list1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();  </span><br><span class=\"line\">list1.add(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>());  </span><br><span class=\"line\">list1.add(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">ArrayList&lt;Object&gt; list2 = list1; <span class=\"comment\">//编译错误</span></span><br></pre></td></tr></table></figure>\n\n<p>没错，这样的情况比第一种情况好的多，最起码，在我们用list2取值的时候不会出现ClassCastException，因为是从String转换为Object。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，你如果又用list2往里面add()新的对象，那么到时候取得时候，我怎么知道我取出来的到底是String类型的，还是Object类型的呢？</p>\n<p>所以，要格外注意，泛型中的引用传递的问题。</p>\n<h5 id=\"3-2-自动类型转换\"><a href=\"#3-2-自动类型转换\" class=\"headerlink\" title=\"3-2.自动类型转换\"></a>3-2.自动类型转换</h5><p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。</p>\n<p>既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？</p>\n<p>看下ArrayList.get()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    RangeCheck(index);  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (E) elementData[index];  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在return之前，会根据泛型变量进行强转。假设泛型类型变量为Date，虽然泛型信息会被擦除掉，但是会将(E) elementData[index]，编译为(Date)elementData[index]。所以我们不用自己进行强转。当存取一个泛型域时也会自动插入强制类型转换。假设Pair类的value域是public的，那么表达式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">date</span> <span class=\"operator\">=</span> pair.value;</span><br></pre></td></tr></table></figure>\n\n<p>也会自动地在结果字节码中插入强制类型转换。</p>\n<h5 id=\"3-3-类型擦除与多态的冲突和解决方法\"><a href=\"#3-3-类型擦除与多态的冲突和解决方法\" class=\"headerlink\" title=\"3-3.类型擦除与多态的冲突和解决方法\"></a>3-3.类型擦除与多态的冲突和解决方法</h5><p>现在有这样一个泛型类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Pair</span>&lt;T&gt; &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> T value;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"title function_\">getValue</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(T value)</span> &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = value;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们想要一个子类继承它。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DateInter</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Pair</span>&lt;Date&gt; &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(Date value)</span> &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">super</span>.setValue(value);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Date <span class=\"title function_\">getValue</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getValue();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个子类中，我们设定父类的泛型类型为Pair<Date>，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型。</Date></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Date <span class=\"title function_\">getValue</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(Date value)</span> &#123;  </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value = value;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的@Override标签中也可以看到，一点问题也没有，实际上是这样的吗？</p>\n<p>分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类编译之后会变成下面的样子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Pair</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object value;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">getValue</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(Object  value)</span> &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = value;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>再看子类的两个重写的方法的类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(Date value)</span> &#123;  </span><br><span class=\"line\">    <span class=\"built_in\">super</span>.setValue(value);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"meta\">@Override</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> Date <span class=\"title function_\">getValue</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getValue();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先来分析setValue方法，父类的类型是Object，而子类的类型是Date，参数类型不一样，这如果是在普通的继承关系中，根本就不会是重写，而是重载。<br>　　<br>我们在一个main方法测试一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException &#123;  </span><br><span class=\"line\">        <span class=\"type\">DateInter</span> <span class=\"variable\">dateInter</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DateInter</span>();  </span><br><span class=\"line\">        dateInter.setValue(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());                  </span><br><span class=\"line\">        dateInter.setValue(<span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>()); <span class=\"comment\">//编译错误  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果是重载，那么子类中两个setValue方法，一个是参数Object类型，一个是Date类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，确实是重写了，而不是重载了。</p>\n<p>为什么会这样呢？</p>\n<p>原因是这样的，我们传入父类的泛型类型是Date，Pair<Date>，我们的本意是将泛型类变为如下：</Date></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Pair</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date value;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Date <span class=\"title function_\">getValue</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(Date value)</span> &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = value;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后再子类中重写参数类型为Date的那两个方法，实现继承中的多态。</p>\n<p>可是由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的Date类型参数的方法啊。</p>\n<p>于是JVM采用了一个特殊的方法，来完成这项功能，那就是桥方法。</p>\n<p>首先，我们用javap -c className的方式反编译下DateInter子类的字节码，结果如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">com</span>.tao.test.DateInter <span class=\"keyword\">extends</span> <span class=\"title class_\">com</span>.tao.test.Pair&lt;java.util.Date&gt; &#123;  </span><br><span class=\"line\">  com.tao.test.DateInter();  </span><br><span class=\"line\">    Code:  </span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0  </span><br><span class=\"line\">       <span class=\"number\">1</span>: invokespecial #<span class=\"number\">8</span>                  <span class=\"comment\">// Method com/tao/test/Pair.&quot;&lt;init&gt;&quot;:()V  </span></span><br><span class=\"line\">       <span class=\"number\">4</span>: <span class=\"keyword\">return</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(java.util.Date)</span>;  <span class=\"comment\">//我们重写的setValue方法  </span></span><br><span class=\"line\">    Code:  </span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0  </span><br><span class=\"line\">       <span class=\"number\">1</span>: aload_1  </span><br><span class=\"line\">       <span class=\"number\">2</span>: invokespecial #<span class=\"number\">16</span>                 <span class=\"comment\">// Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  </span></span><br><span class=\"line\">       <span class=\"number\">5</span>: <span class=\"keyword\">return</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> java.util.Date <span class=\"title function_\">getValue</span><span class=\"params\">()</span>;    <span class=\"comment\">//我们重写的getValue方法  </span></span><br><span class=\"line\">    Code:  </span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0  </span><br><span class=\"line\">       <span class=\"number\">1</span>: invokespecial #<span class=\"number\">23</span>                 <span class=\"comment\">// Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  </span></span><br><span class=\"line\">       <span class=\"number\">4</span>: checkcast     #<span class=\"number\">26</span>                 <span class=\"comment\">// class java/util/Date  </span></span><br><span class=\"line\">       <span class=\"number\">7</span>: areturn  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> java.lang.Object <span class=\"title function_\">getValue</span><span class=\"params\">()</span>;     <span class=\"comment\">//编译时由编译器生成的巧方法  </span></span><br><span class=\"line\">    Code:  </span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0  </span><br><span class=\"line\">       <span class=\"number\">1</span>: invokevirtual #<span class=\"number\">28</span>                 <span class=\"comment\">// Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  </span></span><br><span class=\"line\">       <span class=\"number\">4</span>: areturn  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setValue</span><span class=\"params\">(java.lang.Object)</span>;   <span class=\"comment\">//编译时由编译器生成的巧方法  </span></span><br><span class=\"line\">    Code:  </span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0  </span><br><span class=\"line\">       <span class=\"number\">1</span>: aload_1  </span><br><span class=\"line\">       <span class=\"number\">2</span>: checkcast     #<span class=\"number\">26</span>                 <span class=\"comment\">// class java/util/Date  </span></span><br><span class=\"line\">       <span class=\"number\">5</span>: invokevirtual #<span class=\"number\">30</span>                 <span class=\"comment\">// Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  </span></span><br><span class=\"line\">       <span class=\"number\">8</span>: <span class=\"keyword\">return</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从编译的结果来看，我们本意重写setValue和getValue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。</p>\n<p>所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。</p>\n<p>不过，要提到一点，这里面的setValue和getValue这两个桥方法的意义又有不同。</p>\n<p>setValue方法是为了解决类型擦除与多态之间的冲突。</p>\n<p>而getValue却有普遍的意义，怎么说呢，如果这是一个普通的继承关系：</p>\n<p>那么父类的setValue方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ObjectgetValue</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getValue();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而子类重写的方法是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Date <span class=\"title function_\">getValue</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.getValue();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实这在普通的类继承中也是普遍存在的重写，这就是协变。<br><a href=\"https://extremegtr.github.io/2016/07/11/Covariance-And-Contravariance-In-Java/\">https://extremegtr.github.io/2016/07/11/Covariance-And-Contravariance-In-Java/</a></p>\n<blockquote>\n<p>协变 / 共变（covariance）指的是子类型关系在类型变换的作用下保持原样。<br>不可变（invariance） 表示子类型关系在类型变换的作用下，既没有协变的效果，也没有逆变的效果。<br>逆变 / 反变（contravariance）指的是子类型关系在类型变换的作用下发生逆转。<br>双变（bivariance）表示子类型关系在类型变换的作用下同时拥有协变与逆变2种效果。<br><img src=\"/cn/posts/53914/20200806151224399.png\" alt=\"在这里插入图片描述\"><br>Java支持协变数组，你可能会问Java支持逆变数组吗？答案是：Java不支持逆变数组。<br><a href=\"https://codingnote.com/2020/03/08/java-covariant-contravariant-invariant/\">https://codingnote.com/2020/03/08/java-covariant-contravariant-invariant/</a><br><a href=\"https://extremegtr.github.io/2016/05/30/JavaSE-study-advanced-generics/#u901A_u914D_u7B26_uFF08Wildcard_uFF09\">https://extremegtr.github.io/2016/05/30/JavaSE-study-advanced-generics/#u901A_u914D_u7B26_uFF08Wildcard_uFF09</a><br>Java下限通配符实现逆变<br>由于Java泛型的不可变性，generateIntegers() 生成的List<Integer>不能放到输入参数output指定的List<Number>中。那么有没有办法把 List<Integer> 放到List<Number>中呢？<br>答案是使用下限通配符来实现逆变。<br>正如大家所熟知的一个概念：在Java中，所有类型的父类型都是Object类型，方法的形参类型是Object，那这个方法就能接受任何类型的参数传递进来。这个推论正是实现该需求的关键所在。<br>根据上面的推导，我们可能会这么认为：既然Object是所有类型的父类型，那么List<Object>肯定是所有List参数化类型的父类型。但事实却不是这样的，即2个类型实参之间具有子类型关系，但使用它们对同一泛型进行参数化后的类型并没有保持这种子类型关系。与上文描述一致。<br>List<Object>表示的只是它能够存储任意元素类型，而并没有表示它是所有参数化类型的父类型。所以这种解决方案是完全行不通的。</Object></Object></Number></Integer></Number></Integer></p>\n</blockquote>\n<p>并且，还有一点也许会有疑问，子类中的桥方法Object getValue()和Date getValue()是同 时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。</p>\n<p>总结：</p>\n<p>   在Java中，数组具有协变性，简单点来说就是子类型数组可以赋值给父类型数组进行使用，比如将Integer数组赋值给Object数组，这样来使用数组不会有警告甚至报错，但会存在运行时出错的风险，所以数组的协变性是具有瑕疵的，虽然它能这么用，但我们必须为此而承受一定风险。</p>\n<p>Java泛型就不可以做出像数组这样的行为，因为泛型没有内建的协变类型，Java泛型具有不可变性（不具备协变性和逆变性）。但是，为了兼容遗留代码而被保留下来的原生类型确实可以做出这样的行为，但同时我们也非常清楚使用它就像使用数组的协变性一样意味着代码变得不再安全。</p>\n<p>　　所以，制定Java标准的那群人想出了个法子使得泛型像数组一样具有这些特性，同时这种代替原生类型的方案必须是绝对安全的：他们通过给泛型增加通配符特性使得泛型在参数化后具有协变性或逆变性。</p>\n<h5 id=\"3-4-泛型类型变量不能是基本数据类型\"><a href=\"#3-4-泛型类型变量不能是基本数据类型\" class=\"headerlink\" title=\"3-4.泛型类型变量不能是基本数据类型\"></a>3-4.泛型类型变量不能是基本数据类型</h5><p>不能用类型参数替换基本类型。就比如，没有ArrayList<double>，只有ArrayList<Double>。因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储double值，只能引用Double的值。</Double></double></p>\n<h5 id=\"3-5-编译时集合的instanceof\"><a href=\"#3-5-编译时集合的instanceof\" class=\"headerlink\" title=\"3-5.编译时集合的instanceof\"></a>3-5.编译时集合的instanceof</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; arrayList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>因为类型擦除之后，ArrayList<String>只剩下原始类型，泛型信息String不存在了。</String></p>\n<p>那么，编译时进行类型查询的时候使用下面的方法是错误的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>( arrayList <span class=\"keyword\">instanceof</span> ArrayList&lt;String&gt;)</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-6-泛型在静态方法和静态类中的问题\"><a href=\"#3-6-泛型在静态方法和静态类中的问题\" class=\"headerlink\" title=\"3-6.泛型在静态方法和静态类中的问题\"></a>3-6.泛型在静态方法和静态类中的问题</h5><p>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数</p>\n<p>举例说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test2</span>&lt;T&gt; &#123;    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> T one;   <span class=\"comment\">//编译错误    </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span>  T <span class=\"title function_\">show</span><span class=\"params\">(T one)</span>&#123; <span class=\"comment\">//编译错误    </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;    </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。</p>\n<p>但是要注意区分下面的一种情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test2</span>&lt;T&gt; &#123;    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T &gt;T <span class=\"title function_\">show</span><span class=\"params\">(T one)</span>&#123; <span class=\"comment\">//这是正确的    </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;    </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的 T，而不是泛型类中的T。</p>\n<p>==和equals的区别</p>\n<p>== : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)<br>equals() 方法存在两种使用情况：</p>\n<ul>\n<li><p>情况 1：类没有覆盖 equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。使用的默认是 Object类equals()方法。</p>\n</li>\n<li><p>情况 2：类覆盖了 equals()方法。一般，我们都覆盖 equals()方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。</p>\n</li>\n<li><p>String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</p>\n</li>\n<li><p>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</p>\n</li>\n</ul>\n<h2 id=\"hashCode-与-equals\"><a href=\"#hashCode-与-equals\" class=\"headerlink\" title=\"hashCode()与 equals()\"></a>hashCode()与 equals()</h2><h3 id=\"hashCode-介绍\"><a href=\"#hashCode-介绍\" class=\"headerlink\" title=\"hashCode()介绍:\"></a>hashCode()介绍:</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>\n<blockquote>\n<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>\n</blockquote>\n<h3 id=\"为什么要有-hashCode？\"><a href=\"#为什么要有-hashCode？\" class=\"headerlink\" title=\"为什么要有 hashCode？\"></a>为什么要有 hashCode？</h3><p>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode？</p>\n<p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（Head fist java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>\n<p>为什么重写 equals 时必须重写 hashCode 方法？</p>\n<p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。</p>\n<blockquote>\n<p>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>\n</blockquote>\n<p>String类对hashcode的重写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns a hash code for this string. The hash code for a</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> String&#125; object is computed as</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * using &#123;<span class=\"doctag\">@code</span> int&#125; arithmetic, where &#123;<span class=\"doctag\">@code</span> s[i]&#125; is the</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;i&gt;i&lt;/i&gt;th character of the string, &#123;<span class=\"doctag\">@code</span> n&#125; is the length of</span></span><br><span class=\"line\"><span class=\"comment\"> * the string, and &#123;<span class=\"doctag\">@code</span> ^&#125; indicates exponentiation.</span></span><br><span class=\"line\"><span class=\"comment\"> * (The hash value of the empty string is zero.)</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span>  a hash code value for this object.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hashCode</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> hash;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"number\">0</span> &amp;&amp; value.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> val[] = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; value.length; i++) &#123;</span><br><span class=\"line\">            h = <span class=\"number\">31</span> * h + val[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        hash = h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在《Effective Java》第 42 页就有对 hashCode 为什么采用 31 做了说明：之所以使用 31， 是因为他是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补0）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 31 有个很好的性能，即用移位和减法来代替乘法，可以得到更好的性能： 31 * i == (i &lt;&lt; 5）- i， 现代的 VM 可以自动完成这种优化。这个公式可以很简单的推导出来。<br>31可以由31 * i ==  (i &lt;&lt; 5) - i来表示，现在很多虚拟机里面都有做相关优化，使用31的原因可能是为了更好的分配hash地址，并且31只占用5bits！在java乘法中如果数字相乘过大会导致溢出的问题，从而导致数据的丢失，而31则是素数（质数）而且不是很长的数字，最终它被选择为相乘的系数的原因。</p>\n</blockquote>\n<h2 id=\"Java中的几种基本数据类型\"><a href=\"#Java中的几种基本数据类型\" class=\"headerlink\" title=\"Java中的几种基本数据类型\"></a>Java中的几种基本数据类型</h2><p><img src=\"/cn/posts/53914/20200806154245121.png\" alt=\"在这里插入图片描述\"><br>注意：</p>\n<ul>\n<li>Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析：</li>\n<li>char a = ‘h’char :单引号，String a = “hello” :双引号</li>\n</ul>\n<p>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Boolean <span class=\"title function_\">valueOf</span><span class=\"params\">(<span class=\"type\">boolean</span> b)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (b ? TRUE : FALSE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CharacterCache</span> &#123;         </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">CharacterCache</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Character cache[] = <span class=\"keyword\">new</span> <span class=\"title class_\">Character</span>[<span class=\"number\">127</span> + <span class=\"number\">1</span>];          </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;             </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; cache.length; i++)                 </span><br><span class=\"line\">            cache[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">Character</span>((<span class=\"type\">char</span>)i);         </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title function_\">valueOf</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(i);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。<br>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。<br>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。<br>（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。 </p>\n</blockquote>\n<blockquote>\n<p>为啥把缓存设置为[-128，127]区间？<br>1.技术规范。JLS7 5.1.7：If the value p being boxed is an integer literal of type int between -128 and 127 inclusive (§3.10.1), or the boolean literal true or false (§3.10.3), or a character literal between ‘\\u0000’ and ‘\\u007f’ inclusive (§3.10.4), then let a and b be the results of any two boxing conversions of p . It is always the case that a == b .<br>2.性能和资源之间的权衡（当然也可以调整缓存的正向最大值，自己看 IntegerCache 类的实现）。</p>\n<p><strong>如果超出了范围，会从堆区new一个Integer对象来存放值。</strong></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">a1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">12</span>);</span><br><span class=\"line\">     <span class=\"type\">Integer</span> <span class=\"variable\">a2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Integer</span>(<span class=\"number\">12</span>);</span><br><span class=\"line\">     <span class=\"type\">Integer</span> <span class=\"variable\">b1</span> <span class=\"operator\">=</span> -<span class=\"number\">129</span>;</span><br><span class=\"line\">     <span class=\"type\">Integer</span> <span class=\"variable\">b2</span> <span class=\"operator\">=</span> -<span class=\"number\">129</span>;</span><br><span class=\"line\">     <span class=\"type\">Integer</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> <span class=\"number\">128</span>;</span><br><span class=\"line\">     <span class=\"type\">Integer</span> <span class=\"variable\">c2</span> <span class=\"operator\">=</span> -<span class=\"number\">128</span>;</span><br><span class=\"line\">     System.out.println(a1 == a2);   <span class=\"comment\">//false</span></span><br><span class=\"line\">     System.out.println(b1==b2);     <span class=\"comment\">//false </span></span><br><span class=\"line\">     System.out.println(c1 == c2);   <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i1</span> <span class=\"operator\">=</span> <span class=\"number\">33</span>;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i2</span> <span class=\"operator\">=</span> <span class=\"number\">33</span>;</span><br><span class=\"line\">System.out.println(i1 == i2);<span class=\"comment\">// 输出 true</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i11</span> <span class=\"operator\">=</span> <span class=\"number\">333</span>;</span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">i22</span> <span class=\"operator\">=</span> <span class=\"number\">333</span>;</span><br><span class=\"line\">System.out.println(i11 == i22);<span class=\"comment\">// 输出 false</span></span><br><span class=\"line\"><span class=\"type\">Double</span> <span class=\"variable\">i3</span> <span class=\"operator\">=</span> <span class=\"number\">1.2</span>;</span><br><span class=\"line\"><span class=\"type\">Double</span> <span class=\"variable\">i4</span> <span class=\"operator\">=</span> <span class=\"number\">1.2</span>;</span><br><span class=\"line\">System.out.println(i3 == i4);<span class=\"comment\">// 输出 false</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"方法（函数）\"><a href=\"#方法（函数）\" class=\"headerlink\" title=\"方法（函数）\"></a>方法（函数）</h2><p>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。<br>在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>\n<p>而对象引用作为参数就不一样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] arr = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">    System.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    change(arr);</span><br><span class=\"line\">    System.out.println(arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">change</span><span class=\"params\">(<span class=\"type\">int</span>[] array)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将数组的第一个元素变为0</span></span><br><span class=\"line\">    array[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>\n<p>我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</p>\n<p>很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;小张&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Student</span>(<span class=\"string\">&quot;小李&quot;</span>);</span><br><span class=\"line\">        Test.swap(s1, s2);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;s1:&quot;</span> + s1.getName());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;s2:&quot;</span> + s2.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(Student x, Student y)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Student</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> x;</span><br><span class=\"line\">        x = y;</span><br><span class=\"line\">        y = temp;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;x:&quot;</span> + x.getName());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;y:&quot;</span> + y.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x:小李</span><br><span class=\"line\">y:小张</span><br><span class=\"line\">s1:小张</span><br><span class=\"line\">s2:小李</span><br></pre></td></tr></table></figure>\n<p>解析：</p>\n<p>交换之前：</p>\n<p><img src=\"/cn/posts/53914/20200806155803123.png\" alt=\"在这里插入图片描述\"></p>\n<p>交换之后：</p>\n<p><img src=\"/cn/posts/53914/20200806155808662.png\" alt=\"在这里插入图片描述\"></p>\n<p>通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</p>\n<p><strong>总结</strong></p>\n<p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的。</p>\n<p>下面再总结一下 Java 中方法参数的使用情况：</p>\n<ul>\n<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li>\n<li>一个方法可以改变一个对象参数的状态。</li>\n<li>一个方法不能让对象参数引用一个新的对象。</li>\n</ul>\n<p><strong>参考：</strong></p>\n<p>《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节</p>\n<h2 id=\"重载和重写\"><a href=\"#重载和重写\" class=\"headerlink\" title=\"重载和重写\"></a>重载和重写</h2><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>\n<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法<br>《Java 核心技术》中是这么说的<br><img src=\"/cn/posts/53914/202008061601321.png\" alt=\"在这里插入图片描述\"></p>\n<p><strong>综上</strong>：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>\n<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>\n<ul>\n<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>\n<li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>\n<li>构造方法无法被重写</li>\n</ul>\n<p><strong>综上</strong>：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</p>\n<p><img src=\"/cn/posts/53914/20200806160323274.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"深拷贝-vs-浅拷贝\"><a href=\"#深拷贝-vs-浅拷贝\" class=\"headerlink\" title=\"深拷贝 vs 浅拷贝\"></a>深拷贝 vs 浅拷贝</h2><p>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。<br>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。<br><img src=\"/cn/posts/53914/20200806160355775.png\" alt=\"在这里插入图片描述\"></p>\n","categories":[],"tags":[{"name":"基础","path":"api/tags/基础.json"},{"name":"Jvm","path":"api/tags/Jvm.json"},{"name":"Java","path":"api/tags/Java.json"},{"name":"泛型","path":"api/tags/泛型.json"}]}