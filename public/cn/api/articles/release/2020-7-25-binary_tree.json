{"title":"算法与数据结构学习笔记：二叉树","slug":"release/2020-7-25-binary_tree","date":"2020-08-06T01:13:10.000Z","updated":"2020-08-06T01:13:10.000Z","comments":true,"path":"api/articles/release/2020-7-25-binary_tree.json","excerpt":"知识点二叉树遍历前序遍历：先访问根节点，再前序遍历左子树，再前序遍历右子树 中序遍历：先中序遍历左子树，再访问根节点，再中序遍历右子树 后序遍历：先后序遍历左子树，再后序遍历右子树，再访问根节点 注意点 以根访问顺序决定是什么遍历 左子树都是优先右子树 前序遍历例题：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/ 递归123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; ans; vector&lt;int&gt; preorderTraversal(TreeNo","covers":["/cn/posts/49261/binarytree.png"],"content":"<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><h3 id=\"二叉树遍历\"><a href=\"#二叉树遍历\" class=\"headerlink\" title=\"二叉树遍历\"></a>二叉树遍历</h3><p>前序遍历：先访问根节点，再前序遍历左子树，再前序遍历右子树 中序遍历：先中序遍历左子树，再访问根节点，再中序遍历右子树 后序遍历：先后序遍历左子树，再后序遍历右子树，再访问根节点</p>\n<p>注意点</p>\n<ul>\n<li>以根访问顺序决定是什么遍历</li>\n<li>左子树都是优先右子树</li>\n</ul>\n<h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p>例题：<a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</a></p>\n<h5 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h5><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode {</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class=\"line\"><span class=\"comment\"> * };</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>{</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 先访问根再访问左右</span></span><br><span class=\"line\">        ans.<span class=\"built_in\">push_back</span>(root-&gt;val);</span><br><span class=\"line\">        <span class=\"built_in\">preorderTraversal</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">preorderTraversal</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\"></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"非递归\"><a href=\"#非递归\" class=\"headerlink\" title=\"非递归\"></a>非递归</h5><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode {</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class=\"line\"><span class=\"comment\"> * };</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>{</span><br><span class=\"line\">       vector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        stack&lt;TreeNode*&gt; st;</span><br><span class=\"line\">        TreeNode *cur=root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">NULL</span>||!st.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            {</span><br><span class=\"line\">                ans.<span class=\"built_in\">push_back</span>(cur-&gt;val);</span><br><span class=\"line\">                st.<span class=\"built_in\">push</span>(cur);</span><br><span class=\"line\">                cur=cur-&gt;left;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            cur=st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            cur=cur-&gt;right;</span><br><span class=\"line\"></span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">       </span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<p>也可以这么写</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode {</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class=\"line\"><span class=\"comment\"> * };</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>{</span><br><span class=\"line\">       vector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        stack&lt;TreeNode*&gt; st;</span><br><span class=\"line\">        st.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!st.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> cur=st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(cur-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur-&gt;right)</span><br><span class=\"line\">                st.<span class=\"built_in\">push</span>(cur-&gt;right);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur-&gt;left)</span><br><span class=\"line\">                st.<span class=\"built_in\">push</span>(cur-&gt;left);</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;       </span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p>例题：<a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p>\n<h5 id=\"递归-1\"><a href=\"#递归-1\" class=\"headerlink\" title=\"递归\"></a>递归</h5><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode {</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class=\"line\"><span class=\"comment\"> * };</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:   </span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt;ans;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;       </span><br><span class=\"line\">        <span class=\"built_in\">inorderTraversal</span>(root-&gt;left);</span><br><span class=\"line\">        ans.<span class=\"built_in\">push_back</span>(root-&gt;val);</span><br><span class=\"line\">        <span class=\"built_in\">inorderTraversal</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">       </span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"后序遍历：\"><a href=\"#后序遍历：\" class=\"headerlink\" title=\"后序遍历：\"></a>后序遍历：</h4><p>例题：<a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p>\n<h5 id=\"递归：\"><a href=\"#递归：\" class=\"headerlink\" title=\"递归：\"></a>递归：</h5><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode {</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class=\"line\"><span class=\"comment\"> * };</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        <span class=\"built_in\">postorderTraversal</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">postorderTraversal</span>(root-&gt;right);</span><br><span class=\"line\">        ans.<span class=\"built_in\">push_back</span>(root-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\"></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"分治法应用\"><a href=\"#分治法应用\" class=\"headerlink\" title=\"分治法应用\"></a>分治法应用</h3><p>先分别处理局部，再合并结果</p>\n<p>适用场景</p>\n<ul>\n<li>快速排序</li>\n<li>归并排序</li>\n<li>二叉树相关问题</li>\n</ul>\n<p>分治法模板</p>\n<ul>\n<li>递归返回条件</li>\n<li>分段处理</li>\n<li>合并结果</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ResultType <span class=\"title\">traversal</span><span class=\"params\">(TreeNode *root)</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">// nil or leaf</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) {</span><br><span class=\"line\">        <span class=\"comment\">// do something and return</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Divide</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> left = <span class=\"built_in\">traversal</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> right = <span class=\"built_in\">traversal</span>(root-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Conquer</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> result = <span class=\"built_in\">merge</span>(left, right);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"典型示例\"><a href=\"#典型示例\" class=\"headerlink\" title=\"典型示例\"></a>典型示例</h4><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// V2：通过分治法遍历二叉树</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">preOrderTraversal</span><span class=\"params\">(TreeNode *root)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">divideAndConquer</span>(root);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">divideAndConquer</span><span class=\"params\">(TreeNode *root)</span> </span>{</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 分治(Divide)</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> left = <span class=\"built_in\">divideAndConquer</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> right = <span class=\"built_in\">divideAndConquer</span>(root-&gt;right);</span><br><span class=\"line\">    <span class=\"comment\">// 合并结果(Conquer)</span></span><br><span class=\"line\">    result.<span class=\"built_in\">push_back</span>(root-&gt;val);</span><br><span class=\"line\">    result.<span class=\"built_in\">insert</span>(result.<span class=\"built_in\">end</span>(), left.<span class=\"built_in\">begin</span>(), left.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    result.<span class=\"built_in\">insert</span>(result.<span class=\"built_in\">end</span>(), right.<span class=\"built_in\">begin</span>(), right.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">MergeSort</span><span class=\"params\">(T arr[], <span class=\"type\">int</span> len)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> tmp = <span class=\"keyword\">new</span> T[len];</span><br><span class=\"line\">    <span class=\"built_in\">mergeSort</span>(arr, <span class=\"number\">0</span>, len - <span class=\"number\">1</span>, tmp);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] tmp;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(T arr[], <span class=\"type\">int</span> begin, <span class=\"type\">int</span> end, T tmp[])</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (begin + <span class=\"number\">1</span> &gt;= end) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> mid = begin + (end - begin) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> begin1 = begin;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> end1 = mid;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> begin2 = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> end2 = end;</span><br><span class=\"line\">    <span class=\"built_in\">mergeSort</span>(arr, begin1, end1, tmp);</span><br><span class=\"line\">    <span class=\"built_in\">mergeSort</span>(arr, begin2, end2, tmp);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// merge two parts</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> index = begin;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) {</span><br><span class=\"line\">        tmp[index++] = arr[begin1] &lt; arr[begin2] ? arr[begin1++] : arr[begin2++];</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (begin1 &lt;= end1) {</span><br><span class=\"line\">        tmp[index++] = arr[begin1++];</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (begin2 &lt;= end2) {</span><br><span class=\"line\">        tmp[index++] = arr[begin2++];</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = begin; i &lt;= end; ++i) {</span><br><span class=\"line\">        arr[i] = tmp[i];</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">QuickSort</span><span class=\"params\">(T arr[], <span class=\"type\">int</span> len)</span> </span>{</span><br><span class=\"line\">    <span class=\"built_in\">quickSort</span>(arr, <span class=\"number\">0</span>, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(T arr[], <span class=\"type\">int</span> begin, <span class=\"type\">int</span> end)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (begin &gt;= end) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> pivot = <span class=\"built_in\">partition</span>(arr, begin, end);</span><br><span class=\"line\">    <span class=\"built_in\">quickSort</span>(arr, begin, pivot - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">quickSort</span>(arr, pivot + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">partition</span><span class=\"params\">(T arr[], <span class=\"type\">int</span> begin, <span class=\"type\">int</span> end)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> base = arr[end];</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> lessInsert = begin;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = begin; i &lt; end; ++i) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; base) {</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(arr[lessInsert++], arr[i]);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(arr[lessInsert], arr[end]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lessInsert;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"常见题目示例\"><a href=\"#常见题目示例\" class=\"headerlink\" title=\"常见题目示例\"></a>常见题目示例</h4><h5 id=\"104-二叉树的最大深度\"><a href=\"#104-二叉树的最大深度\" class=\"headerlink\" title=\"104. 二叉树的最大深度\"></a><a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\">104. 二叉树的最大深度</a></h5><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode {</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class=\"line\"><span class=\"comment\"> * };</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode* root)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> left=<span class=\"built_in\">maxDepth</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"type\">int</span> right=<span class=\"built_in\">maxDepth</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left&gt;right)</span><br><span class=\"line\">             <span class=\"keyword\">return</span> left<span class=\"number\">+1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> right<span class=\"number\">+1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"110-平衡二叉树\"><a href=\"#110-平衡二叉树\" class=\"headerlink\" title=\"110. 平衡二叉树\"></a><a href=\"https://leetcode-cn.com/problems/balanced-binary-tree/\">110. 平衡二叉树</a></h5><blockquote>\n<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>\n<p>本题中，一棵高度平衡二叉树定义为：</p>\n<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>\n<p>示例 1:</p>\n<p>给定二叉树 [3,9,20,null,null,15,7]</p>\n<p> 3<br>/ <br>9  20<br> /  <br>15   7<br>返回 true 。</p>\n<p>示例 2:</p>\n<p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>\n<pre><code>1\n</code></pre>\n<p>   / <br>  2   2<br> / <br>3   3<br>/ <br>4   4<br>返回 false 。</p>\n</blockquote>\n<h6 id=\"从底至顶\"><a href=\"#从底至顶\" class=\"headerlink\" title=\"从底至顶\"></a>从底至顶</h6><p>思路：分治法，左边平衡 &amp;&amp; 右边平衡 &amp;&amp; 左右两边高度 &lt;= 1， 因为需要返回是否平衡及高度，要么返回两个数据，要么合并两个数据， 所以用-1 表示不平衡，&gt;0 表示树高度（二义性：一个变量有两种含义）。</p>\n<p>注意</p>\n<blockquote>\n<p>一般工程中，结果通过两个变量来返回，不建议用一个变量表示两种含义</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode {</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class=\"line\"><span class=\"comment\"> * };</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isBalanced</span><span class=\"params\">(TreeNode* root)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">maxDepth</span>(root)==<span class=\"number\">-1</span>)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode *root)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">      <span class=\"type\">int</span> left=<span class=\"built_in\">maxDepth</span>(root-&gt;left);</span><br><span class=\"line\">      <span class=\"type\">int</span> right=<span class=\"built_in\">maxDepth</span>(root-&gt;right);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(left==<span class=\"number\">-1</span>||right==<span class=\"number\">-1</span>||left-right&gt;<span class=\"number\">1</span>||right-left&gt;<span class=\"number\">1</span>)</span><br><span class=\"line\">      {</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">      }</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(left&gt;right)</span><br><span class=\"line\">      {</span><br><span class=\"line\">          <span class=\"keyword\">return</span> left<span class=\"number\">+1</span>;</span><br><span class=\"line\">      }</span><br><span class=\"line\">      <span class=\"keyword\">return</span> right<span class=\"number\">+1</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"124-二叉树中的最大路径和\"><a href=\"#124-二叉树中的最大路径和\" class=\"headerlink\" title=\"124. 二叉树中的最大路径和\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/\">124. 二叉树中的最大路径和</a></h5><blockquote>\n<p>给定一个非空二叉树，返回其最大路径和。</p>\n<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>\n<p>示例 1:</p>\n<p>输入: [1,2,3]</p>\n<pre><code>1\n</code></pre>\n<p>   / <br>  2   3</p>\n<p>输出: 6<br>示例 2:</p>\n<p>输入: [-10,9,20,null,null,15,7]</p>\n<p>-10<br>/ <br>9  20<br> /  <br>15   7</p>\n<p>输出: 42</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode {</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class=\"line\"><span class=\"comment\"> * };</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxPathSum</span><span class=\"params\">(TreeNode* root)</span> </span>{</span><br><span class=\"line\">        <span class=\"type\">int</span> res=INT_MIN;</span><br><span class=\"line\">        <span class=\"built_in\">helper</span>(root,res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode*root,<span class=\"type\">int</span> &amp;val)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> left=<span class=\"built_in\">max</span>(<span class=\"number\">0</span>,<span class=\"built_in\">helper</span>(root-&gt;left,val));</span><br><span class=\"line\">        <span class=\"type\">int</span> right=<span class=\"built_in\">max</span>(<span class=\"number\">0</span>,<span class=\"built_in\">helper</span>(root-&gt;right,val));</span><br><span class=\"line\">        <span class=\"type\">int</span> lmr=root-&gt;val+left+right;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret=root-&gt;val+<span class=\"built_in\">max</span>(left,right);</span><br><span class=\"line\">        val=<span class=\"built_in\">max</span>(val,<span class=\"built_in\">max</span>(lmr,ret));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"236-二叉树的最近公共祖先\"><a href=\"#236-二叉树的最近公共祖先\" class=\"headerlink\" title=\"236. 二叉树的最近公共祖先\"></a><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/\">236. 二叉树的最近公共祖先</a></h5><blockquote>\n<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>\n<p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p>\n<p><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/49261/binarytree.png\" alt=\"img\"></p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class=\"line\">输出: 5</span><br><span class=\"line\">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></tbody></table></figure>\n</blockquote>\n<p>思路：分治法，有左子树的公共祖先或者有右子树的公共祖先，就返回子树的祖先，否则返回根节点</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode {</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class=\"line\"><span class=\"comment\"> * };</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">         <span class=\"comment\">// 相等 直接返回root节点即可</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==p||root==q)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> left=<span class=\"built_in\">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> right=<span class=\"built_in\">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class=\"line\">          <span class=\"comment\">// 左右两边都不为空，则根节点为祖先</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left!=<span class=\"literal\">NULL</span>&amp;&amp;right!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(right!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"BFS-层次应用\"><a href=\"#BFS-层次应用\" class=\"headerlink\" title=\"BFS 层次应用\"></a>BFS 层次应用</h3><h5 id=\"102-二叉树的层序遍历\"><a href=\"#102-二叉树的层序遍历\" class=\"headerlink\" title=\"102. 二叉树的层序遍历\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\">102. 二叉树的层序遍历</a></h5><blockquote>\n<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode {</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class=\"line\"><span class=\"comment\"> * };</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">levelOrder</span>(TreeNode* root) {</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        queue&lt;TreeNode *&gt; q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        {</span><br><span class=\"line\">           <span class=\"type\">int</span> currentLevelSize=q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">           vector&lt;<span class=\"type\">int</span>&gt; level;</span><br><span class=\"line\">           <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;currentLevelSize;i++)</span><br><span class=\"line\">           {</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> cur=q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                level.<span class=\"built_in\">push_back</span>(cur-&gt;val);</span><br><span class=\"line\">                q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;left)</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;right)</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;right);               </span><br><span class=\"line\">           }</span><br><span class=\"line\">           res.<span class=\"built_in\">push_back</span>(level);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"107-二叉树的层次遍历-II\"><a href=\"#107-二叉树的层次遍历-II\" class=\"headerlink\" title=\"107. 二叉树的层次遍历 II\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/\">107. 二叉树的层次遍历 II</a></h5><blockquote>\n<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>\n</blockquote>\n<p>思路：在层级遍历的基础上，翻转一下结果即可</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode {</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class=\"line\"><span class=\"comment\"> * };</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">levelOrderBottom</span>(TreeNode* root) {</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        queue&lt;TreeNode*&gt;q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"type\">int</span> curLevelSize=q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            vector&lt;<span class=\"type\">int</span>&gt; curLevel;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;curLevelSize;i++)</span><br><span class=\"line\">            {</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> cur=q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                curLevel.<span class=\"built_in\">push_back</span>(cur-&gt;val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;left)</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;right)            </span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;right);</span><br><span class=\"line\">                </span><br><span class=\"line\">            }</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(curLevel);</span><br><span class=\"line\">            </span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"built_in\">reverse</span>(res.<span class=\"built_in\">begin</span>(),res.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"103-二叉树的锯齿形层次遍历\"><a href=\"#103-二叉树的锯齿形层次遍历\" class=\"headerlink\" title=\"103. 二叉树的锯齿形层次遍历\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/\">103. 二叉树的锯齿形层次遍历</a></h5><blockquote>\n<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>\n<p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>\n<p> 3<br>/ <br>9  20<br> /  <br>15   7<br>返回锯齿形层次遍历如下：</p>\n<p>[<br>[3],<br>[20,9],<br>[15,7]<br>]</p>\n</blockquote>\n<p>思路：特定层结果翻转即可</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode {</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class=\"line\"><span class=\"comment\"> * };</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">zigzagLevelOrder</span>(TreeNode* root) {</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"type\">bool</span> toggle=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"type\">int</span> curLevelSize=q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            vector&lt;<span class=\"type\">int</span>&gt; curLevel;            </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;curLevelSize;i++)</span><br><span class=\"line\">            {</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> cur=q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                curLevel.<span class=\"built_in\">push_back</span>(cur-&gt;val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;left)</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;right)</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;right);                               </span><br><span class=\"line\"></span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(toggle)</span><br><span class=\"line\">            {</span><br><span class=\"line\">                <span class=\"built_in\">reverse</span>(curLevel.<span class=\"built_in\">begin</span>(),curLevel.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">            }               </span><br><span class=\"line\">            toggle=!toggle;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(curLevel);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"二叉搜索树应用\"><a href=\"#二叉搜索树应用\" class=\"headerlink\" title=\"二叉搜索树应用\"></a>二叉搜索树应用</h3><h5 id=\"98-验证二叉搜索树\"><a href=\"#98-验证二叉搜索树\" class=\"headerlink\" title=\"98. 验证二叉搜索树\"></a><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\">98. 验证二叉搜索树</a></h5><blockquote>\n<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>\n<p>假设一个二叉搜索树具有如下特征：</p>\n<p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>\n</blockquote>\n<h6 id=\"中序遍历-1\"><a href=\"#中序遍历-1\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h6><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode {</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class=\"line\"><span class=\"comment\"> * };</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode* root)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt;res;</span><br><span class=\"line\">        <span class=\"built_in\">inOrder</span>(root,res);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;res.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(res[i]&gt;=res[i<span class=\"number\">+1</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inOrder</span><span class=\"params\">(TreeNode*root,vector&lt;<span class=\"type\">int</span>&gt; &amp;res)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">inOrder</span>(root-&gt;left,res);</span><br><span class=\"line\">        res.<span class=\"built_in\">push_back</span>(root-&gt;val);</span><br><span class=\"line\">        <span class=\"built_in\">inOrder</span>(root-&gt;right,res);</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"701-二叉搜索树中的插入操作\"><a href=\"#701-二叉搜索树中的插入操作\" class=\"headerlink\" title=\"701. 二叉搜索树中的插入操作\"></a><a href=\"https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/\">701. 二叉搜索树中的插入操作</a></h5><blockquote>\n<p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。</p>\n<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode {</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class=\"line\"><span class=\"comment\"> * };</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">insertIntoBST</span><span class=\"params\">(TreeNode* root, <span class=\"type\">int</span> val)</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;val&lt;val)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            root-&gt;right=<span class=\"built_in\">insertIntoBST</span>(root-&gt;right,val);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        {</span><br><span class=\"line\">            root-&gt;left=<span class=\"built_in\">insertIntoBST</span>(root-&gt;left,val);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        </span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>","more":"<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><h3 id=\"二叉树遍历\"><a href=\"#二叉树遍历\" class=\"headerlink\" title=\"二叉树遍历\"></a>二叉树遍历</h3><p>前序遍历：先访问根节点，再前序遍历左子树，再前序遍历右子树 中序遍历：先中序遍历左子树，再访问根节点，再中序遍历右子树 后序遍历：先后序遍历左子树，再后序遍历右子树，再访问根节点</p>\n<p>注意点</p>\n<ul>\n<li>以根访问顺序决定是什么遍历</li>\n<li>左子树都是优先右子树</li>\n</ul>\n<h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p>例题：<a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</a></p>\n<h5 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 先访问根再访问左右</span></span><br><span class=\"line\">        ans.<span class=\"built_in\">push_back</span>(root-&gt;val);</span><br><span class=\"line\">        <span class=\"built_in\">preorderTraversal</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">preorderTraversal</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"非递归\"><a href=\"#非递归\" class=\"headerlink\" title=\"非递归\"></a>非递归</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">       vector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        stack&lt;TreeNode*&gt; st;</span><br><span class=\"line\">        TreeNode *cur=root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">NULL</span>||!st.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans.<span class=\"built_in\">push_back</span>(cur-&gt;val);</span><br><span class=\"line\">                st.<span class=\"built_in\">push</span>(cur);</span><br><span class=\"line\">                cur=cur-&gt;left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur=st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            cur=cur-&gt;right;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>也可以这么写</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">       vector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        stack&lt;TreeNode*&gt; st;</span><br><span class=\"line\">        st.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!st.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> cur=st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(cur-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur-&gt;right)</span><br><span class=\"line\">                st.<span class=\"built_in\">push</span>(cur-&gt;right);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur-&gt;left)</span><br><span class=\"line\">                st.<span class=\"built_in\">push</span>(cur-&gt;left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><p>例题：<a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p>\n<h5 id=\"递归-1\"><a href=\"#递归-1\" class=\"headerlink\" title=\"递归\"></a>递归</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:   </span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt;ans;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;       </span><br><span class=\"line\">        <span class=\"built_in\">inorderTraversal</span>(root-&gt;left);</span><br><span class=\"line\">        ans.<span class=\"built_in\">push_back</span>(root-&gt;val);</span><br><span class=\"line\">        <span class=\"built_in\">inorderTraversal</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"后序遍历：\"><a href=\"#后序遍历：\" class=\"headerlink\" title=\"后序遍历：\"></a>后序遍历：</h4><p>例题：<a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p>\n<h5 id=\"递归：\"><a href=\"#递归：\" class=\"headerlink\" title=\"递归：\"></a>递归：</h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; ans;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        <span class=\"built_in\">postorderTraversal</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">postorderTraversal</span>(root-&gt;right);</span><br><span class=\"line\">        ans.<span class=\"built_in\">push_back</span>(root-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分治法应用\"><a href=\"#分治法应用\" class=\"headerlink\" title=\"分治法应用\"></a>分治法应用</h3><p>先分别处理局部，再合并结果</p>\n<p>适用场景</p>\n<ul>\n<li>快速排序</li>\n<li>归并排序</li>\n<li>二叉树相关问题</li>\n</ul>\n<p>分治法模板</p>\n<ul>\n<li>递归返回条件</li>\n<li>分段处理</li>\n<li>合并结果</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ResultType <span class=\"title\">traversal</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// nil or leaf</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something and return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Divide</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> left = <span class=\"built_in\">traversal</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> right = <span class=\"built_in\">traversal</span>(root-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Conquer</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> result = <span class=\"built_in\">merge</span>(left, right);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"典型示例\"><a href=\"#典型示例\" class=\"headerlink\" title=\"典型示例\"></a>典型示例</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// V2：通过分治法遍历二叉树</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">preOrderTraversal</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">divideAndConquer</span>(root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">divideAndConquer</span><span class=\"params\">(TreeNode *root)</span> </span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 分治(Divide)</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> left = <span class=\"built_in\">divideAndConquer</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> right = <span class=\"built_in\">divideAndConquer</span>(root-&gt;right);</span><br><span class=\"line\">    <span class=\"comment\">// 合并结果(Conquer)</span></span><br><span class=\"line\">    result.<span class=\"built_in\">push_back</span>(root-&gt;val);</span><br><span class=\"line\">    result.<span class=\"built_in\">insert</span>(result.<span class=\"built_in\">end</span>(), left.<span class=\"built_in\">begin</span>(), left.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    result.<span class=\"built_in\">insert</span>(result.<span class=\"built_in\">end</span>(), right.<span class=\"built_in\">begin</span>(), right.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">MergeSort</span><span class=\"params\">(T arr[], <span class=\"type\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> tmp = <span class=\"keyword\">new</span> T[len];</span><br><span class=\"line\">    <span class=\"built_in\">mergeSort</span>(arr, <span class=\"number\">0</span>, len - <span class=\"number\">1</span>, tmp);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(T arr[], <span class=\"type\">int</span> begin, <span class=\"type\">int</span> end, T tmp[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (begin + <span class=\"number\">1</span> &gt;= end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> mid = begin + (end - begin) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> begin1 = begin;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> end1 = mid;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> begin2 = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> end2 = end;</span><br><span class=\"line\">    <span class=\"built_in\">mergeSort</span>(arr, begin1, end1, tmp);</span><br><span class=\"line\">    <span class=\"built_in\">mergeSort</span>(arr, begin2, end2, tmp);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// merge two parts</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> index = begin;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123;</span><br><span class=\"line\">        tmp[index++] = arr[begin1] &lt; arr[begin2] ? arr[begin1++] : arr[begin2++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (begin1 &lt;= end1) &#123;</span><br><span class=\"line\">        tmp[index++] = arr[begin1++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (begin2 &lt;= end2) &#123;</span><br><span class=\"line\">        tmp[index++] = arr[begin2++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = begin; i &lt;= end; ++i) &#123;</span><br><span class=\"line\">        arr[i] = tmp[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">QuickSort</span><span class=\"params\">(T arr[], <span class=\"type\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">quickSort</span>(arr, <span class=\"number\">0</span>, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(T arr[], <span class=\"type\">int</span> begin, <span class=\"type\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (begin &gt;= end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> pivot = <span class=\"built_in\">partition</span>(arr, begin, end);</span><br><span class=\"line\">    <span class=\"built_in\">quickSort</span>(arr, begin, pivot - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">quickSort</span>(arr, pivot + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">partition</span><span class=\"params\">(T arr[], <span class=\"type\">int</span> begin, <span class=\"type\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> base = arr[end];</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> lessInsert = begin;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = begin; i &lt; end; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; base) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(arr[lessInsert++], arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(arr[lessInsert], arr[end]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lessInsert;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"常见题目示例\"><a href=\"#常见题目示例\" class=\"headerlink\" title=\"常见题目示例\"></a>常见题目示例</h4><h5 id=\"104-二叉树的最大深度\"><a href=\"#104-二叉树的最大深度\" class=\"headerlink\" title=\"104. 二叉树的最大深度\"></a><a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\">104. 二叉树的最大深度</a></h5><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> left=<span class=\"built_in\">maxDepth</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"type\">int</span> right=<span class=\"built_in\">maxDepth</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left&gt;right)</span><br><span class=\"line\">             <span class=\"keyword\">return</span> left<span class=\"number\">+1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> right<span class=\"number\">+1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"110-平衡二叉树\"><a href=\"#110-平衡二叉树\" class=\"headerlink\" title=\"110. 平衡二叉树\"></a><a href=\"https://leetcode-cn.com/problems/balanced-binary-tree/\">110. 平衡二叉树</a></h5><blockquote>\n<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>\n<p>本题中，一棵高度平衡二叉树定义为：</p>\n<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>\n<p>示例 1:</p>\n<p>给定二叉树 [3,9,20,null,null,15,7]</p>\n<p> 3<br>/ <br>9  20<br> /  <br>15   7<br>返回 true 。</p>\n<p>示例 2:</p>\n<p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>\n<pre><code>1\n</code></pre>\n<p>   / <br>  2   2<br> / <br>3   3<br>/ <br>4   4<br>返回 false 。</p>\n</blockquote>\n<h6 id=\"从底至顶\"><a href=\"#从底至顶\" class=\"headerlink\" title=\"从底至顶\"></a>从底至顶</h6><p>思路：分治法，左边平衡 &amp;&amp; 右边平衡 &amp;&amp; 左右两边高度 &lt;= 1， 因为需要返回是否平衡及高度，要么返回两个数据，要么合并两个数据， 所以用-1 表示不平衡，&gt;0 表示树高度（二义性：一个变量有两种含义）。</p>\n<p>注意</p>\n<blockquote>\n<p>一般工程中，结果通过两个变量来返回，不建议用一个变量表示两种含义</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isBalanced</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">maxDepth</span>(root)==<span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode *root)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"type\">int</span> left=<span class=\"built_in\">maxDepth</span>(root-&gt;left);</span><br><span class=\"line\">      <span class=\"type\">int</span> right=<span class=\"built_in\">maxDepth</span>(root-&gt;right);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(left==<span class=\"number\">-1</span>||right==<span class=\"number\">-1</span>||left-right&gt;<span class=\"number\">1</span>||right-left&gt;<span class=\"number\">1</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(left&gt;right)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> left<span class=\"number\">+1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> right<span class=\"number\">+1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"124-二叉树中的最大路径和\"><a href=\"#124-二叉树中的最大路径和\" class=\"headerlink\" title=\"124. 二叉树中的最大路径和\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/\">124. 二叉树中的最大路径和</a></h5><blockquote>\n<p>给定一个非空二叉树，返回其最大路径和。</p>\n<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>\n<p>示例 1:</p>\n<p>输入: [1,2,3]</p>\n<pre><code>1\n</code></pre>\n<p>   / <br>  2   3</p>\n<p>输出: 6<br>示例 2:</p>\n<p>输入: [-10,9,20,null,null,15,7]</p>\n<p>-10<br>/ <br>9  20<br> /  <br>15   7</p>\n<p>输出: 42</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxPathSum</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> res=INT_MIN;</span><br><span class=\"line\">        <span class=\"built_in\">helper</span>(root,res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">helper</span><span class=\"params\">(TreeNode*root,<span class=\"type\">int</span> &amp;val)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> left=<span class=\"built_in\">max</span>(<span class=\"number\">0</span>,<span class=\"built_in\">helper</span>(root-&gt;left,val));</span><br><span class=\"line\">        <span class=\"type\">int</span> right=<span class=\"built_in\">max</span>(<span class=\"number\">0</span>,<span class=\"built_in\">helper</span>(root-&gt;right,val));</span><br><span class=\"line\">        <span class=\"type\">int</span> lmr=root-&gt;val+left+right;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret=root-&gt;val+<span class=\"built_in\">max</span>(left,right);</span><br><span class=\"line\">        val=<span class=\"built_in\">max</span>(val,<span class=\"built_in\">max</span>(lmr,ret));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"236-二叉树的最近公共祖先\"><a href=\"#236-二叉树的最近公共祖先\" class=\"headerlink\" title=\"236. 二叉树的最近公共祖先\"></a><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/\">236. 二叉树的最近公共祖先</a></h5><blockquote>\n<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>\n<p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p>\n<p><img src=\"/cn/posts/49261/binarytree.png\" alt=\"img\"></p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class=\"line\">输出: 5</span><br><span class=\"line\">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>思路：分治法，有左子树的公共祖先或者有右子树的公共祖先，就返回子树的祖先，否则返回根节点</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">         <span class=\"comment\">// 相等 直接返回root节点即可</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==p||root==q)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> left=<span class=\"built_in\">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> right=<span class=\"built_in\">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class=\"line\">          <span class=\"comment\">// 左右两边都不为空，则根节点为祖先</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left!=<span class=\"literal\">NULL</span>&amp;&amp;right!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(right!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"BFS-层次应用\"><a href=\"#BFS-层次应用\" class=\"headerlink\" title=\"BFS 层次应用\"></a>BFS 层次应用</h3><h5 id=\"102-二叉树的层序遍历\"><a href=\"#102-二叉树的层序遍历\" class=\"headerlink\" title=\"102. 二叉树的层序遍历\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\">102. 二叉树的层序遍历</a></h5><blockquote>\n<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">levelOrder</span>(TreeNode* root) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        queue&lt;TreeNode *&gt; q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">           <span class=\"type\">int</span> currentLevelSize=q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">           vector&lt;<span class=\"type\">int</span>&gt; level;</span><br><span class=\"line\">           <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;currentLevelSize;i++)</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> cur=q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                level.<span class=\"built_in\">push_back</span>(cur-&gt;val);</span><br><span class=\"line\">                q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;left)</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;right)</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;right);               </span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           res.<span class=\"built_in\">push_back</span>(level);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"107-二叉树的层次遍历-II\"><a href=\"#107-二叉树的层次遍历-II\" class=\"headerlink\" title=\"107. 二叉树的层次遍历 II\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/\">107. 二叉树的层次遍历 II</a></h5><blockquote>\n<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>\n</blockquote>\n<p>思路：在层级遍历的基础上，翻转一下结果即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        queue&lt;TreeNode*&gt;q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> curLevelSize=q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            vector&lt;<span class=\"type\">int</span>&gt; curLevel;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;curLevelSize;i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> cur=q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                curLevel.<span class=\"built_in\">push_back</span>(cur-&gt;val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;left)</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;right)            </span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;right);</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(curLevel);</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">reverse</span>(res.<span class=\"built_in\">begin</span>(),res.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"103-二叉树的锯齿形层次遍历\"><a href=\"#103-二叉树的锯齿形层次遍历\" class=\"headerlink\" title=\"103. 二叉树的锯齿形层次遍历\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/\">103. 二叉树的锯齿形层次遍历</a></h5><blockquote>\n<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>\n<p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>\n<p> 3<br>/ <br>9  20<br> /  <br>15   7<br>返回锯齿形层次遍历如下：</p>\n<p>[<br>[3],<br>[20,9],<br>[15,7]<br>]</p>\n</blockquote>\n<p>思路：特定层结果翻转即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"type\">bool</span> toggle=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> curLevelSize=q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            vector&lt;<span class=\"type\">int</span>&gt; curLevel;            </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;curLevelSize;i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> cur=q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                curLevel.<span class=\"built_in\">push_back</span>(cur-&gt;val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;left)</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;right)</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;right);                               </span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(toggle)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">reverse</span>(curLevel.<span class=\"built_in\">begin</span>(),curLevel.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">            &#125;               </span><br><span class=\"line\">            toggle=!toggle;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(curLevel);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二叉搜索树应用\"><a href=\"#二叉搜索树应用\" class=\"headerlink\" title=\"二叉搜索树应用\"></a>二叉搜索树应用</h3><h5 id=\"98-验证二叉搜索树\"><a href=\"#98-验证二叉搜索树\" class=\"headerlink\" title=\"98. 验证二叉搜索树\"></a><a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\">98. 验证二叉搜索树</a></h5><blockquote>\n<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>\n<p>假设一个二叉搜索树具有如下特征：</p>\n<p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>\n</blockquote>\n<h6 id=\"中序遍历-1\"><a href=\"#中序遍历-1\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h6><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt;res;</span><br><span class=\"line\">        <span class=\"built_in\">inOrder</span>(root,res);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;res.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(res[i]&gt;=res[i<span class=\"number\">+1</span>])</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inOrder</span><span class=\"params\">(TreeNode*root,vector&lt;<span class=\"type\">int</span>&gt; &amp;res)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">inOrder</span>(root-&gt;left,res);</span><br><span class=\"line\">        res.<span class=\"built_in\">push_back</span>(root-&gt;val);</span><br><span class=\"line\">        <span class=\"built_in\">inOrder</span>(root-&gt;right,res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"701-二叉搜索树中的插入操作\"><a href=\"#701-二叉搜索树中的插入操作\" class=\"headerlink\" title=\"701. 二叉搜索树中的插入操作\"></a><a href=\"https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/\">701. 二叉搜索树中的插入操作</a></h5><blockquote>\n<p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。</p>\n<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">insertIntoBST</span><span class=\"params\">(TreeNode* root, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;val&lt;val)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            root-&gt;right=<span class=\"built_in\">insertIntoBST</span>(root-&gt;right,val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            root-&gt;left=<span class=\"built_in\">insertIntoBST</span>(root-&gt;left,val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","categories":[],"tags":[{"name":"cpp","path":"api/tags/cpp.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"数据结构","path":"api/tags/数据结构.json"},{"name":"二叉树","path":"api/tags/二叉树.json"}]}