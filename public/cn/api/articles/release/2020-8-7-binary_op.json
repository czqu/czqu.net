{"title":"算法与数据结构学习笔记：二进制","slug":"release/2020-8-7-binary_op","date":"2020-09-07T04:55:01.000Z","updated":"2020-09-07T04:55:01.000Z","comments":true,"path":"api/articles/release/2020-8-7-binary_op.json","excerpt":"常见二进制操作C++位运算符下表显示了 C++ 支持的位运算符。 假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 则： 运算符 描述 实例 &amp; 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 (A &amp; B) 将得到 12，即为 0000 1100 | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。 (A | B) 将得到 61，即为 0011 1101 ^ 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。 (A ^ B) 将得到 49，即为 0011 0001 ~ 二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。 (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 &lt;&lt; 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。 A &lt;&lt; 2 将得到 240，即为 1111 0000 &gt;&gt; 二进制右移运算符。左操作","covers":["/cn/posts/48007/image-20200807111500764.png","/cn/posts/48007/image-20200807111619453.png"],"content":"<h1 id=\"常见二进制操作\"><a href=\"#常见二进制操作\" class=\"headerlink\" title=\"常见二进制操作\"></a>常见二进制操作</h1><h2 id=\"C-位运算符\"><a href=\"#C-位运算符\" class=\"headerlink\" title=\"C++位运算符\"></a>C++位运算符</h2><p>下表显示了 C++ 支持的位运算符。</p>\n<p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p>\n<p>A = 0011 1100</p>\n<p>B = 0000 1101</p>\n<p>则：</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;</td>\n<td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>\n<td>(A &amp; B) 将得到 12，即为 0000 1100</td>\n</tr>\n<tr>\n<td>|</td>\n<td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>\n<td>(A | B) 将得到 61，即为 0011 1101</td>\n</tr>\n<tr>\n<td>^</td>\n<td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>\n<td>(A ^ B) 将得到 49，即为 0011 0001</td>\n</tr>\n<tr>\n<td>~</td>\n<td>二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。</td>\n<td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>\n<td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>\n<td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td>\n</tr>\n</tbody></table>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><p>a=0^a=a^0</p>\n<p>0=a^a</p>\n<p>由上面两个推导出：a=a^b^b</p>\n<h2 id=\"交换两个数\"><a href=\"#交换两个数\" class=\"headerlink\" title=\"交换两个数\"></a>交换两个数</h2><p>a=a^b</p>\n<p>b=a^b</p>\n<p>a=a^b</p>\n<h2 id=\"移除最后一个-1\"><a href=\"#移除最后一个-1\" class=\"headerlink\" title=\"移除最后一个 1\"></a>移除最后一个 1</h2><p>a=n&amp;(n-1)</p>\n<h2 id=\"获取最后一个-1\"><a href=\"#获取最后一个-1\" class=\"headerlink\" title=\"获取最后一个 1\"></a>获取最后一个 1</h2><p>diff=(n&amp;(n-1))^n</p>\n<h1 id=\"常见题目\"><a href=\"#常见题目\" class=\"headerlink\" title=\"常见题目\"></a>常见题目</h1><h4 id=\"136-只出现一次的数字\"><a href=\"#136-只出现一次的数字\" class=\"headerlink\" title=\"136. 只出现一次的数字\"></a><a href=\"https://leetcode-cn.com/problems/single-number/\">136. 只出现一次的数字</a></h4><blockquote>\n<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>\n<p>说明：</p>\n<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\n<p>示例 1:</p>\n<p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p>\n<p>输入: [4,1,2,1,2]<br>输出: 4</p>\n</blockquote>\n<p><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/48007/image-20200807111500764.png\" alt=\"image-20200807111500764\"></p>\n<p><img src= \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" data-lazy-src=\"/cn/posts/48007/image-20200807111619453.png\" alt=\"image-20200807111619453\"></p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class=\"line\">        <span class=\"type\">int</span> ret=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> num:nums)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            ret^=num;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"137-只出现一次的数字-II\"><a href=\"#137-只出现一次的数字-II\" class=\"headerlink\" title=\"137. 只出现一次的数字 II\"></a><a href=\"https://leetcode-cn.com/problems/single-number-ii/\">137. 只出现一次的数字 II</a></h4><blockquote>\n<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>\n<p><strong>说明：</strong></p>\n<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [2,2,3,2]</span><br><span class=\"line\">输出: 3</span><br></pre></td></tr></tbody></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [0,1,0,1,0,1,99]</span><br><span class=\"line\">输出: 99</span><br></pre></td></tr></tbody></table></figure>\n</blockquote>\n<h5 id=\"遍历统计\"><a href=\"#遍历统计\" class=\"headerlink\" title=\"遍历统计\"></a>遍历统计</h5><p>如果所有数字都出现了 3 次，那么每一列的 1 的个数就一定是 3 的倍数。之所以有的列不是 3 的倍数，就是因为只出现了 1 次的数贡献出了 1。所以所有不是 3 的倍数的列写 1，其他列写 0 ，就找到了这个出现 1 次的数。</p>\n<blockquote>\n<p>假如例子是 1 2 6 1 1 2 2 3 3 3, 3 个 1, 3 个 2, 3 个 3,1 个 6<br>1 0 0 1<br>2 0 1 0<br>6 1 1 0<br>1 0 0 1<br>1 0 0 1<br>2 0 1 0<br>2 0 1 0<br>3 0 1 1<br>3 0 1 1<br>3 0 1 1<br>看最右边的一列 1001100111 有 6 个 1<br>再往前看一列 0110011111 有 7 个 1<br>再往前看一列 0010000 有 1 个 1<br>我们只需要把是 3 的倍数的对应列写 0，不是 3 的倍数的对应列写 1<br>也就是 1 1 0,也就是 6。</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class=\"line\">        <span class=\"type\">int</span> ret=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">32</span>;i++)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"type\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;nums.<span class=\"built_in\">size</span>();j++)</span><br><span class=\"line\">            {</span><br><span class=\"line\">                sum+=(nums[j]&gt;&gt;i)&amp;<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            }</span><br><span class=\"line\">            ret^=(sum%<span class=\"number\">3</span>)&lt;&lt;i;</span><br><span class=\"line\"></span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"有限状态自动机\"><a href=\"#有限状态自动机\" class=\"headerlink\" title=\"有限状态自动机\"></a>有限状态自动机</h5>","more":"<h1 id=\"常见二进制操作\"><a href=\"#常见二进制操作\" class=\"headerlink\" title=\"常见二进制操作\"></a>常见二进制操作</h1><h2 id=\"C-位运算符\"><a href=\"#C-位运算符\" class=\"headerlink\" title=\"C++位运算符\"></a>C++位运算符</h2><p>下表显示了 C++ 支持的位运算符。</p>\n<p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p>\n<p>A = 0011 1100</p>\n<p>B = 0000 1101</p>\n<p>则：</p>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;</td>\n<td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>\n<td>(A &amp; B) 将得到 12，即为 0000 1100</td>\n</tr>\n<tr>\n<td>|</td>\n<td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>\n<td>(A | B) 将得到 61，即为 0011 1101</td>\n</tr>\n<tr>\n<td>^</td>\n<td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>\n<td>(A ^ B) 将得到 49，即为 0011 0001</td>\n</tr>\n<tr>\n<td>~</td>\n<td>二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。</td>\n<td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>\n<td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td>\n</tr>\n<tr>\n<td>&gt;&gt;</td>\n<td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>\n<td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td>\n</tr>\n</tbody></table>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><p>a=0^a=a^0</p>\n<p>0=a^a</p>\n<p>由上面两个推导出：a=a^b^b</p>\n<h2 id=\"交换两个数\"><a href=\"#交换两个数\" class=\"headerlink\" title=\"交换两个数\"></a>交换两个数</h2><p>a=a^b</p>\n<p>b=a^b</p>\n<p>a=a^b</p>\n<h2 id=\"移除最后一个-1\"><a href=\"#移除最后一个-1\" class=\"headerlink\" title=\"移除最后一个 1\"></a>移除最后一个 1</h2><p>a=n&amp;(n-1)</p>\n<h2 id=\"获取最后一个-1\"><a href=\"#获取最后一个-1\" class=\"headerlink\" title=\"获取最后一个 1\"></a>获取最后一个 1</h2><p>diff=(n&amp;(n-1))^n</p>\n<h1 id=\"常见题目\"><a href=\"#常见题目\" class=\"headerlink\" title=\"常见题目\"></a>常见题目</h1><h4 id=\"136-只出现一次的数字\"><a href=\"#136-只出现一次的数字\" class=\"headerlink\" title=\"136. 只出现一次的数字\"></a><a href=\"https://leetcode-cn.com/problems/single-number/\">136. 只出现一次的数字</a></h4><blockquote>\n<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>\n<p>说明：</p>\n<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\n<p>示例 1:</p>\n<p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p>\n<p>输入: [4,1,2,1,2]<br>输出: 4</p>\n</blockquote>\n<p><img src=\"/cn/posts/48007/image-20200807111500764.png\" alt=\"image-20200807111500764\"></p>\n<p><img src=\"/cn/posts/48007/image-20200807111619453.png\" alt=\"image-20200807111619453\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> num:nums)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ret^=num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"137-只出现一次的数字-II\"><a href=\"#137-只出现一次的数字-II\" class=\"headerlink\" title=\"137. 只出现一次的数字 II\"></a><a href=\"https://leetcode-cn.com/problems/single-number-ii/\">137. 只出现一次的数字 II</a></h4><blockquote>\n<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>\n<p><strong>说明：</strong></p>\n<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [2,2,3,2]</span><br><span class=\"line\">输出: 3</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [0,1,0,1,0,1,99]</span><br><span class=\"line\">输出: 99</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h5 id=\"遍历统计\"><a href=\"#遍历统计\" class=\"headerlink\" title=\"遍历统计\"></a>遍历统计</h5><p>如果所有数字都出现了 3 次，那么每一列的 1 的个数就一定是 3 的倍数。之所以有的列不是 3 的倍数，就是因为只出现了 1 次的数贡献出了 1。所以所有不是 3 的倍数的列写 1，其他列写 0 ，就找到了这个出现 1 次的数。</p>\n<blockquote>\n<p>假如例子是 1 2 6 1 1 2 2 3 3 3, 3 个 1, 3 个 2, 3 个 3,1 个 6<br>1 0 0 1<br>2 0 1 0<br>6 1 1 0<br>1 0 0 1<br>1 0 0 1<br>2 0 1 0<br>2 0 1 0<br>3 0 1 1<br>3 0 1 1<br>3 0 1 1<br>看最右边的一列 1001100111 有 6 个 1<br>再往前看一列 0110011111 有 7 个 1<br>再往前看一列 0010000 有 1 个 1<br>我们只需要把是 3 的倍数的对应列写 0，不是 3 的倍数的对应列写 1<br>也就是 1 1 0,也就是 6。</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">32</span>;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;nums.<span class=\"built_in\">size</span>();j++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                sum+=(nums[j]&gt;&gt;i)&amp;<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ret^=(sum%<span class=\"number\">3</span>)&lt;&lt;i;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"有限状态自动机\"><a href=\"#有限状态自动机\" class=\"headerlink\" title=\"有限状态自动机\"></a>有限状态自动机</h5>","categories":[],"tags":[{"name":"cpp","path":"api/tags/cpp.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"数据结构","path":"api/tags/数据结构.json"},{"name":"二进制","path":"api/tags/二进制.json"}]}