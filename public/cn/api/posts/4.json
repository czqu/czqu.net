{"total":67,"pageSize":10,"pageCount":7,"data":[{"title":"C语言程序设计现代方法答案","slug":null,"date":"2020-11-13T04:46:33.000Z","updated":"2020-11-13T04:46:33.000Z","comments":null,"path":"api/articles/draft/C-Programming-A-Modern-Approach-key.json","excerpt":"Chapter 2Answers to Selected Exercises2. [was #2] (a) The program contains one directive (#include) and four statements (three calls of printf and one return). (b) 123Parkinson's Law:Work expands so as to fill the timeavailable for its completion. 3. [was #4] 1234567891011121314#include &lt;stdio.h&gt; int main(void){ int height = 8, length = 12, width = 10, volume; volume = height * length * width; printf(\"Dimensions: %dx%dx%d\\n\", length, width, height); printf(\"Volume (cubic inches): %d\\n\", vo","keywords":null,"cover":null,"content":null,"raw":null,"categories":null,"tags":null},{"title":"Linux内存管理","slug":null,"date":"2020-11-13T04:27:41.000Z","updated":"2020-11-13T04:27:41.000Z","comments":null,"path":"api/articles/draft/Linux-memory-Manage.json","excerpt":"前言： 在 32 位的系统上，线性地址空间为 4GB，其中用户进程占有 3GB 线性地址空间，内核占有 1GB 线性地址空间。由于虚拟内存的引入，使的每个进程都可拥有 3GB 的虚拟内存。 用户进程的虚拟地址空间包含若干区域，这些区域的分布方式因体系结构的差异而不同，但所有的方式都包含下列成分： （1） 代码段：可执行文件的二进制代码 （2） 数据段：存储全局变量 （3） 栈：用于保存局部变量和实现函数调用 （4） 环境变量和命令行参数 （5） 程序使用的动态库的代码 （6） 用于映射文件内容的区域为便于描述，系统中进程的虚拟内存空间被划分为若干不同的区域，每个区域都有其相关的属性和用途，一个合法的地址总是落在某个区域当中的，这些区域也不会重叠。在 Linux 内核中，这样的区域被称为虚拟内存区域(virtual memory areas，VMA)。一个 VMA 是一块连续的线性地址空间的抽象，它拥有自身的权限(可读，可写，可执行等) ，对进程而言，VMA 其实是虚拟空间的内存块，一个进程的所有资源由多个内存块组成。 每一个虚拟内存区域都由一个相关的 struct vm_area_st","keywords":null,"cover":"/cn/posts/53930/image-20200608163648953.png","content":null,"raw":null,"categories":null,"tags":null},{"title":"h5别踩白块游戏","slug":null,"date":"2020-11-05T07:01:00.000Z","updated":"2020-11-05T07:01:00.000Z","comments":null,"path":"api/articles/release/2020-11-5-Do-not-Tap-The-White-Tile.json","excerpt":"内容介绍1.简介别踩白块这个游戏相信很多人都在手机上玩过，今天我们就来做一个网页版的，先上一张游戏效果图： 属于简化版别踩白块，代码相对较为简单易学，主要涉及通过 javascript 操作元素节点的增删以及属性节点（class）的操作。 2.知识点 HTML/CSS JavaScript 元素节点增删 属性节点操作 3.项目架构1234puzzle |index.html |css/index.css |js/index.js 项目原理在开始编程之前，让我们先来分析下整个游戏的流程：一定的速度下移，点击黑块，黑块消失，新的黑块出现在普通游戏玩家眼中，应该是游戏开始，黑块不断向下移动，若黑块触底则游戏结束； 而以开发者来说，应将每一个黑块和白块抽象成一个个的数据结构，黑块的消失和出现其实就是数据结构的创造和销毁，我们来看一张游戏的流程图，对于要编写的功能有一个大概的了解: 实现步骤页面布局可以用 div+css 布局来实现别踩白块的静态效果展示，直接上 HTML 代码，我来简要说下 HTML 思路，将主界面分解成一个 4x4 的大矩形格子，每一个方块代表其中一个小的矩形格，其中每一行的","keywords":null,"cover":"/cn/posts/59750/uid1133717-20191017-1571294959274.gif","content":null,"raw":null,"categories":null,"tags":null},{"title":"h5拼图小游戏","slug":null,"date":"2020-11-05T07:00:00.000Z","updated":"2020-11-05T07:00:00.000Z","comments":null,"path":"api/articles/release/2020-11-5-h5-ping-tu-1.json","excerpt":"内容介绍1.1 学习内容本项目是基于 HTML+CSS+JavaScript 实现网页版的拼图游戏。实现过程中将用到 HTML5，CSS3 及 JavaScript 相关知识。完成这个项目，可以进一步扎实前端基础知识。 九宫格拼图相信大家都玩过了，看似简单的小游戏，但实现起来其实并不那么简单。在以前，写程序是程序员的专利，只有他们才能做出一个软件来。但是现在不同了。科技的进步和经济的发展，使得每个人都可以使用计算机。特别是 HTML5 和 CSS3 的流行，使得制作一个基本的游戏变得简单。 下面我们就来做一个九宫格拼图。它的玩法是移动空格块旁边的方块，使得它们按照方块上面标的数字顺序排好。最终的效果： 1.2 实验知识点本实验涉及以下知识点： HTML5 CSS3 JavaScript 1.3 实验环境 Vscode 1.4 适合人群本项目难度一般，适合刚学完前端基础（HTML+CSS+JavaScript）的同学作为练手项目。 1.5 代码获取附件： 1puzzle.zip 项目原理根据下面的效果图来观察思考，我们要做的就是设置一个大 DIV 用来包裹里面的小 DIV，然后在里面设置","keywords":null,"cover":"/cn/posts/22493/document-uid920932labid465timestamp1551234014316.png","content":null,"raw":null,"categories":null,"tags":null},{"title":"删除Win10此电脑里的设备和驱动器中的图标","slug":null,"date":"2020-11-01T07:11:45.000Z","updated":"2020-11-01T07:11:45.000Z","comments":null,"path":"api/articles/draft/Remove-ICONS-from-devices-and-drives-in-Windows-10.json","excerpt":"删除Win10此电脑里的设备和驱动器中的百度云图标，同样方法还可以删除暴风影音，迅雷等。 不知从何时起，资源管理器“此电脑(Win10)/这台电脑(Win8/Win8.1)/计算机(Win7)”的“设备和驱动器”中就开始流行被植入一些第三方项目。客观上说，这些项目给经常使用这些软件的用户提供了很大便利。但有些用户则并不需要这种“便利”，因为这些项目之所以能够出现在这种位置，完全是软件自身设置的原因，并非用户有意安排。而且鉴于这种现象越来越普遍，导致某些用户“此电脑”中“设备和驱动器”项目数量十分壮观。 虽然这些软件的设置中也都有移除这些“入口”的选项，但如果这些项目过多，挨个删除未免太过麻烦。有没有什么办法能够一次性删除所有多余项目呢?答案是肯定的，在注册表中就可以实现。需要提醒各位的是，注册表操作需谨慎，最好提前进行备份，以防止误操作带来的麻烦。 具体方法如下： 1、在开始-运行输入regedit后回车 2、定位到 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameS","keywords":null,"cover":"/cn/posts/39253/20200608130032138.png","content":null,"raw":null,"categories":null,"tags":null},{"title":"如何让手机点到广告的时候不会自动安装拼多多","slug":null,"date":"2020-09-15T04:56:16.000Z","updated":"2020-09-15T04:56:16.000Z","comments":null,"path":"api/articles/draft/prevent-Pinduoduo.json","excerpt":"今天真的很烦，打开某app，就会马上跳转到应用商店自动下载拼多多。于是乎我直接做了一个和拼多多包名一样的app，这样误点到广告的时候就不会自动安装拼多多了。原理非常简单，大佬勿喷，我不是专门做安卓的 当然有需要的童鞋也可以点下面的链接下载，没有申请任何权限，很干净。 蓝奏云下载 https://www.lanzoux.com/iZbxPgnlf3i 或者百度云链接：https://pan.baidu.com/s/17Rbrn9AXGf5knsWSZZzqqg 提取码：g77c","keywords":null,"cover":null,"content":null,"raw":null,"categories":null,"tags":null},{"title":"算法与数据结构学习笔记：二分法","slug":null,"date":"2020-09-11T14:00:00.000Z","updated":"2020-09-11T14:00:00.000Z","comments":null,"path":"api/articles/release/2020-8-9-binary-search.json","excerpt":"二分搜索模板给一个有序数组和目标值，找第一次/最后一次/任何一次出现的索引，如果没有出现返回-1 模板四点要素 1、初始化：start=0、end=len-1 2、循环退出条件：start + 1 &lt; end 3、比较中点和目标值：A[mid] ==、 &lt;、&gt; target 4、判断最后两个元素是否符合：A[start]、A[end] ? target 注意：为了防止overflow，超过int范围，左中位数（a+b)=a+(b-a)/2,右中位数（a+b)=a+(b-a+1)/2如果有mid*mid,mid用int注意溢出 时间复杂度 O(logn)，使用场景一般是有序数组的查找 典型示例 704. 二分查找 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 1234567891011121314151617181920212223242526class Solution {public: int search(vector&lt;int&gt;","keywords":null,"cover":null,"content":null,"raw":null,"categories":null,"tags":null},{"title":"算法与数据结构学习笔记：动态规划","slug":null,"date":"2020-09-11T03:40:00.000Z","updated":"2020-09-11T03:40:00.000Z","comments":null,"path":"api/articles/release/2020-8-9-Dynamic-Programming.json","excerpt":"线性 DP最经典单串300. 最长上升子序列 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 输入: [10,9,2,5,3,7,101,18]输出: 4解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 12345678910111213141516171819class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int maxLength=0; vector&lt;int&gt; dp(nums.size(),1); for(int i=0;i&lt;nums.size();i++) { for(int j=0;j&lt;i;j++) { if(nums[i]&gt;nums[j]&amp;&amp;dp[i]&lt;(dp[j]+1)) { dp[i]=dp[j]+1; } } maxLength=max(maxLength,dp[i]); } return maxLength; }}; 最经典双串：1143. 最长公共子序列12345678910111213","keywords":null,"cover":null,"content":null,"raw":null,"categories":null,"tags":null},{"title":"算法与数据结构学习笔记：栈和队列","slug":null,"date":"2020-09-11T03:00:00.000Z","updated":"2020-09-11T03:00:00.000Z","comments":null,"path":"api/articles/release/2020-8-6-stack-and-queue.json","excerpt":"简介栈的特点是后入先出，根据这个特点可以临时保存一些数据，之后用到依次再弹出来，常用于 DFS 深度搜索 队列一般常用于 BFS 广度搜索，类似一层一层的搜索 栈155. 最小栈 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。pop() —— 删除栈顶的元素。top() —— 获取栈顶元素。getMin() —— 检索栈中的最小元素。 辅助栈12345678910111213141516171819202122232425262728293031323334353637383940class MinStack {public: /** initialize your data structure here. */ stack&lt;int&gt; minStack; stack&lt;int&gt; dataStack; MinStack() { minStack.push(INT_MAX); } void push(int x) { dataStack.push(x); minStack.push(","keywords":null,"cover":null,"content":null,"raw":null,"categories":null,"tags":null},{"title":"算法与数据结构学习笔记：二进制","slug":null,"date":"2020-09-07T04:55:01.000Z","updated":"2020-09-07T04:55:01.000Z","comments":null,"path":"api/articles/release/2020-8-7-binary_op.json","excerpt":"常见二进制操作C++位运算符下表显示了 C++ 支持的位运算符。 假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 则： 运算符 描述 实例 &amp; 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 (A &amp; B) 将得到 12，即为 0000 1100 | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。 (A | B) 将得到 61，即为 0011 1101 ^ 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。 (A ^ B) 将得到 49，即为 0011 0001 ~ 二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。 (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 &lt;&lt; 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。 A &lt;&lt; 2 将得到 240，即为 1111 0000 &gt;&gt; 二进制右移运算符。左操作","keywords":null,"cover":"/cn/posts/48007/image-20200807111500764.png","content":null,"raw":null,"categories":null,"tags":null}]}