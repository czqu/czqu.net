{"total":67,"pageSize":10,"pageCount":7,"data":[{"title":"Java学习笔记-基础篇","slug":null,"date":"2020-08-06T08:13:10.000Z","updated":"2020-08-06T08:13:10.000Z","comments":null,"path":"api/articles/release/2020-8-6-java-note-basic.json","excerpt":"Java程序怎么样运行的Java 程序从源代码到运行一般有下面 3 步：我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。 HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 J","keywords":null,"cover":"/cn/posts/53914/2020080614124077.png","content":null,"raw":null,"categories":null,"tags":null},{"title":"算法与数据结构学习笔记：二叉树","slug":null,"date":"2020-08-06T01:13:10.000Z","updated":"2020-08-06T01:13:10.000Z","comments":null,"path":"api/articles/release/2020-7-25-binary_tree.json","excerpt":"知识点二叉树遍历前序遍历：先访问根节点，再前序遍历左子树，再前序遍历右子树 中序遍历：先中序遍历左子树，再访问根节点，再中序遍历右子树 后序遍历：先后序遍历左子树，再后序遍历右子树，再访问根节点 注意点 以根访问顺序决定是什么遍历 左子树都是优先右子树 前序遍历例题：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/ 递归123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; ans; vector&lt;int&gt; preorderTraversal(TreeNo","keywords":null,"cover":"/cn/posts/49261/binarytree.png","content":null,"raw":null,"categories":null,"tags":null},{"title":"Rest Client在idea的使用","slug":null,"date":"2020-08-06T01:13:10.000Z","updated":"2020-08-06T01:13:10.000Z","comments":null,"path":"api/articles/release/2020-7-26-using-rest-client-in-idea.json","excerpt":"1.安装首先，打开IntelliJ IDEA或pycharm，安装Rest Client。 File -&gt; Setting -&gt; Plug-ins -&gt; Browse Repository 搜索Rest Client，点击右侧的install，稍等片刻会提醒要重启IDEA，重启后安装结束。 2.使用使用时候，从顶层工具栏依次Tools -&gt; HTTP Client -&gt; Test RESTFUL Web Service 打开 之后，IDEA REST Client控制台的界面如下样子。 这个控制台展示的功能区有请求方式，请求参数和请求头的填充等等。 如果需要用户名、密码验证，点击右侧按钮，会弹出填充用户名和密码的窗口。 填完后会自动补充到Authorization 的header里面去。 Rest Client插件会自动将最近执行的50个请求保存到http-requests-log.http 文件中。 该文件存储在项目的.idea /httpRequests/目录下。 使用请求历史记录，用户可以快速导航到特定响应并再次发出请求。 除了构建请求，发起REST","keywords":null,"cover":"/cn/posts/34566/dc6420f5bfcb4f0caaa4612c0a77f7da.jpeg","content":null,"raw":null,"categories":null,"tags":null},{"title":"算法与数据结构学习笔记：链表","slug":null,"date":"2020-07-24T04:01:00.000Z","updated":"2020-07-24T04:01:00.000Z","comments":null,"path":"api/articles/release/2020-7-12-linked_list.json","excerpt":"核心知识点 null异常处理 dummy node 哑巴节点 双指针/快慢指针 插入一个节点到排序链表 从一个链表中移除一个节点 翻转链表 合并两个链表 找到链表的中间节点 例题：83. 删除排序链表中的重复元素 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1-&gt;1-&gt;2输出: 1-&gt;2示例 2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3 直接法：链表是有序的，所以直接更改当前结点的 next 指针，跳过下一个结点并直接指向下一个结点之后的结点即可。 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: Lis","keywords":null,"cover":"/cn/posts/26939/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif","content":null,"raw":null,"categories":null,"tags":null},{"title":"记一次CVE-2018-0802漏洞的简单利用","slug":null,"date":"2020-06-21T16:00:00.000Z","updated":"2020-06-21T16:00:00.000Z","comments":null,"path":"api/articles/release/2020-6-21-simple-CVE-2018-0802-office-2010.json","excerpt":"受影响的版本 Microsoft Office 2007 Service Pack 3 Microsoft Office 2010 Service Pack 2 (32-bit editions) Microsoft Office 2010 Service Pack 2 (64-bit editions) Microsoft Office 2013 Service Pack 1 (32-bit editions) Microsoft Office 2013 Service Pack 1 (64-bit editions) Microsoft Office 2016 (32-bit edition) Microsoft Office 2016 (64-bit edition) Microsoft Office 2016 Click-to-Run (C2R) for 32-bit editions Microsoft Office 2016 Click-to-Run (C2R) for 64-bit editions Microsoft Office Compatibility Pack ","keywords":null,"cover":"/cn/posts/63237/image-20200622204154770.png","content":null,"raw":null,"categories":null,"tags":null},{"title":"使用vscode快速搭建单片机开发环境","slug":null,"date":"2020-06-09T16:00:00.000Z","updated":"2020-06-09T16:00:00.000Z","comments":null,"path":"api/articles/release/2020-06-02-esp8266-vscode-development-environment.json","excerpt":"摘要：本文主要介绍了如何搭建以Visual Studio Code 和 PlatformIO为基础的单片机开发环境，并以esp8266开发板为例，通过在OLED显示屏上显示文字的一个例子介绍如何开发一个单片机程序。 本文主要使用的环境： 单片机开发板:Esp8266(CH340G) Visual Studio Code：1.45.1 PlatformIO：Core 4.3.4 Home 3.2.2 U8g2：2.28.6 一、硬件部分首先就是去某宝买一个esp8266开发板和显示屏，这里我买的是这个（不贴链接，不然有打广告嫌疑，自己去搜哈，有些卖家不送杜邦线的，可以提前问问） 按照卖家的说明将显示屏和开发板连接好 二、软件部分1. 安装Visual Studio Code 和 PlatformIOvscode: https://code.visualstudio.com/ 安装完成vscode启动，扩展页面下搜索platformio即可找到,选择第一个Platformio IDE，安装即可（这里需要耐心等待一会） 安装完成，等待vscode重新加载后，左下角会多一个小房子图标，点击后即","keywords":null,"cover":"/cn/posts/23513/10007.png","content":null,"raw":null,"categories":null,"tags":null},{"title":"永恒之蓝漏洞的简单利用","slug":null,"date":"2020-06-09T16:00:00.000Z","updated":"2020-06-09T16:00:00.000Z","comments":null,"path":"api/articles/release/2020-06-08-ms17-010-Simple-use.json","excerpt":"前言： 永恒之蓝是指2017年4月14日晚，黑客团体Shadow Brokers（影子经纪人）公布一大批网络攻击工具，其中包含“永恒之蓝”工具，“永恒之蓝”利用Windows系统的SMB漏洞可以获取系统最高权限。5月12日，不法分子通过改造“永恒之蓝”制作了wannacry勒索病毒，英国、俄罗斯、整个欧洲以及中国国内多个高校校内网、大型企业内网和政府机构专网中招，被勒索支付高额赎金才能解密恢复文件。 详见Microsoft 安全公告：MS17-010 :https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2017/ms17-010 恶意代码会扫描开放445文件共享端口的Windows机器，无需用户任何操作，只要开机上网，不法分子就能在电脑和服务器中植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。 本文主要利用“永恒之蓝”漏洞（Microsoft 安全公告：MS17-010）对目标靶机进行攻击并拿到远程执行的权限，并通过获取远程靶机上的文件的例子讲解此漏洞的危害，提高大家的安全意识。 本文为科普性质","keywords":null,"cover":"/cn/posts/29143/image-20200622204008081.png","content":null,"raw":null,"categories":null,"tags":null},{"title":"编写我的第一个Linux 内核模块“hello_module","slug":null,"date":"2020-06-09T16:00:00.000Z","updated":"2020-06-09T16:00:00.000Z","comments":null,"path":"api/articles/release/2020-06-08-my-first-linux-kernel.json","excerpt":"前言： Linux 内 核 模 块 全 称 为 “ 动 态 可 加 载 内 核 模 块 (Loadable Kernel Module,LKM)”，是系统内核向外部提供的功能插口。作为宏内核结构，Linux 内核具有效率高的特点，但也有可扩展性和可维护性相对较差的不足，Linux 提供模块机制正是弥补这一缺陷。 模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。模块在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程是不同的。模块通常有一组函数和数据结构组成，用来实现某种文件系统、驱动程序或其它内核上层功能。 本文将介绍如何编写一个简单的内核模块以及如何传递参数给此模块。 一、 编写一个简单的内核模块1.编写模块程序编写如下简单代码，本示例中代码文件命名“hello_module.c”。 123456789101112131415161718192021//hello_module.c#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init","keywords":null,"cover":"/cn/posts/19043/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvZ1VlVzN0N0lQaWRPMkdyLnBuZw","content":null,"raw":null,"categories":null,"tags":null},{"title":"VMware虚拟机安装kali 2020.2","slug":null,"date":"2020-04-03T02:00:00.000Z","updated":"2020-04-03T02:00:00.000Z","comments":null,"path":"api/articles/release/2020-4-3-install-kali 2020.2.json","excerpt":"1.打开Kali官网下载镜像,这里直接选择VMware 2.解压然后在VMware中点击”文件-打开”导入虚拟机 3.点编辑设置打开虚拟化选项(没有此选项的点击升级此虚拟机,还没有的就检查BIOS设置) 4.点击开启此虚拟机,用户名和密码在虚拟机描述里有(2020版用户名和密码都是kali) 5.设置kali语言为中文 虚拟机默认语言为英文 设置步骤如下 (1)终端输入代码 1sudo dpkg-reconfigure locales 然后选择字符编码： en_US.UTF-8、zh_CN.GBK、zh_CN.UTF-8 （用空格选定） 接着选择字符： zh_CN.UTF-8 选定后回车确认 (2)接着输入如下代码安装字体,如果没有成功看(3) 12sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy (3)换阿里云源 12sudo vim /etc/apt/sources.list 或者图形化: 1sudo mousepad /etc/apt/sources.list 先备份原文并将这一段覆盖原文 123# a","keywords":null,"cover":"/cn/posts/55435/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDUvMjIvNnFYMk0zZWtpS0p4VzdBLnBuZw.png","content":null,"raw":null,"categories":null,"tags":null},{"title":"Linux内核的编译","slug":null,"date":"2020-03-03T02:00:00.000Z","updated":"2020-03-03T02:00:00.000Z","comments":null,"path":"api/articles/release/2020-3-3-Compilation-of-the-Linux-kernel.json","excerpt":"前言： 常见 Linux 内核编译有两种方式，一是直接在 Linux 系统上编译得到二进制文件，并对原有 Linux 内核进行替换，即更换 Linux 内核，此方法可能因新内核有 bug 导致系统奔溃，且难以返回原版本内核而不得不重装；第二种方法则是在模拟器中运行新的 Linux 内核，以避免对系统内核的修改。 BusyBox 是一个集成了三百多个最常用 Linux 命令和工具的软件，因为单独的 Linux 内核无任何用于用户交互的 UI，所以需要通过其它工具与新编译的Linux 内核交互。 QEMU 是以 GPL 许可证分发源码的模拟处理器，可用于模拟常见的硬件平台，常用于在 Linux 系统中建立虚拟机。 本文在阿里云 Ubuntu 18.04 64 位操作系统环境下编译 ARM Linux 内核。过程中主要是用交叉编译工具链 gcc-arm-linux-gnueabi 编译系统源码，并使用 QEMU 软件仿真硬件平台测试对象系统。 **建议使用 root 用户操作 ** 本文所使用的环境： 操作系统：4.15.0-96-generic #97-Ubuntu SMP Wed Apr","keywords":null,"cover":"/cn/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvbnZ6d0ViUDZjMzVObDh0LnBuZw.png","content":null,"raw":null,"categories":null,"tags":null}]}