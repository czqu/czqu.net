{"meta":{"title":"Czq's Blog","subtitle":"Praising suffering because of incompetence.","description":"Praising suffering because of incompetence.","author":"Paul Chen","url":"https://czqu.net","root":"/"},"pages":[{"title":"Categories","date":"2021-05-22T22:35:11.000Z","updated":"2021-05-22T22:35:11.000Z","comments":false,"path":"categories/index.html","permalink":"https://czqu.net/categories/index.html","excerpt":"","text":""},{"title":"Guestbook","date":"2021-05-22T20:24:10.000Z","updated":"2021-05-22T20:24:10.000Z","comments":true,"path":"guestbook/index.html","permalink":"https://czqu.net/guestbook/index.html","excerpt":"","text":"Welcome to my site! I'm glad you stopped by. Please take a moment to sign my guestbook and let me know what you think. Welcome to my Guestbook! I appreciate your comments and thoughts. However, I kindly ask that you refrain from posting any inappropriate content related to pornography, violence, racial discrimination, political sensitivity, or any other inappropriate content. Please ensure that your message content respects others and does not contain attacks, insults, or slanders. Let’s keep the Guestbook a friendly, supportive, and encouraging place. I reserve the right to delete any inappropriate content to ensure the positivity and health of the Guestbook. If you find any inappropriate messages, please notify me immediately, and I will deal with them as soon as possible."},{"title":"Links","date":"2018-12-12T21:25:30.000Z","updated":"2018-12-12T21:25:30.000Z","comments":true,"path":"links/index.html","permalink":"https://czqu.net/links/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-11-13T12:21:59.000Z","updated":"2020-11-13T12:21:59.000Z","comments":false,"path":"tags/index.html","permalink":"https://czqu.net/tags/index.html","excerpt":"","text":""},{"title":"","date":"2025-08-12T14:54:16.416Z","updated":"2025-08-12T14:54:16.416Z","comments":true,"path":"404/css/font-awesome.css","permalink":"https://czqu.net/404/css/font-awesome.css","excerpt":"","text":"/* build time:Tue Aug 12 2025 14:54:40 GMT+0000 (Coordinated Universal Time)*/ /*! * Font Awesome 4.7.0 by @davegandy - http://fontawesome.io - @fontawesome * License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License) */@font-face{font-family:FontAwesome;src:url(../fonts/fontawesome-webfont.eot?v=4.7.0);src:url(../fonts/fontawesome-webfont.eot?#iefix&v=4.7.0) format('embedded-opentype'),url(../fonts/fontawesome-webfont.woff2?v=4.7.0) format('woff2'),url(../fonts/fontawesome-webfont.woff?v=4.7.0) format('woff'),url(../fonts/fontawesome-webfont.ttf?v=4.7.0) format('truetype'),url(../fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular) format('svg');font-weight:400;font-style:normal}.fa{display:inline-block;font:normal normal normal 14px/1 FontAwesome;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.fa-lg{font-size:1.33333333em;line-height:.75em;vertical-align:-15%}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-fw{width:1.28571429em;text-align:center}.fa-ul{padding-left:0;margin-left:2.14285714em;list-style-type:none}.fa-ul>li{position:relative}.fa-li{position:absolute;left:-2.14285714em;width:2.14285714em;top:.14285714em;text-align:center}.fa-li.fa-lg{left:-1.85714286em}.fa-border{padding:.2em .25em .15em;border:solid .08em #eee;border-radius:.1em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left{margin-right:.3em}.fa.fa-pull-right{margin-left:.3em}.pull-right{float:right}.pull-left{float:left}.fa.pull-left{margin-right:.3em}.fa.pull-right{margin-left:.3em}.fa-spin{-webkit-animation:fa-spin 2s infinite linear;animation:fa-spin 2s infinite linear}.fa-pulse{-webkit-animation:fa-spin 1s infinite steps(8);animation:fa-spin 1s infinite steps(8)}@-webkit-keyframes fa-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}@keyframes fa-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}.fa-rotate-90{-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg)}.fa-rotate-180{-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg)}.fa-rotate-270{-webkit-transform:rotate(270deg);-ms-transform:rotate(270deg);transform:rotate(270deg)}.fa-flip-horizontal{-webkit-transform:scale(-1,1);-ms-transform:scale(-1,1);transform:scale(-1,1)}.fa-flip-vertical{-webkit-transform:scale(1,-1);-ms-transform:scale(1,-1);transform:scale(1,-1)}:root .fa-flip-horizontal,:root .fa-flip-vertical,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-rotate-90{filter:none}.fa-stack{position:relative;display:inline-block;width:2em;height:2em;line-height:2em;vertical-align:middle}.fa-stack-1x,.fa-stack-2x{position:absolute;left:0;width:100%;text-align:center}.fa-stack-1x{line-height:inherit}.fa-stack-2x{font-size:2em}.fa-inverse{color:#fff}.fa-glass:before{content:\"\\f000\"}.fa-music:before{content:\"\\f001\"}.fa-search:before{content:\"\\f002\"}.fa-envelope-o:before{content:\"\\f003\"}.fa-heart:before{content:\"\\f004\"}.fa-star:before{content:\"\\f005\"}.fa-star-o:before{content:\"\\f006\"}.fa-user:before{content:\"\\f007\"}.fa-film:before{content:\"\\f008\"}.fa-th-large:before{content:\"\\f009\"}.fa-th:before{content:\"\\f00a\"}.fa-th-list:before{content:\"\\f00b\"}.fa-check:before{content:\"\\f00c\"}.fa-close:before,.fa-remove:before,.fa-times:before{content:\"\\f00d\"}.fa-search-plus:before{content:\"\\f00e\"}.fa-search-minus:before{content:\"\\f010\"}.fa-power-off:before{content:\"\\f011\"}.fa-signal:before{content:\"\\f012\"}.fa-cog:before,.fa-gear:before{content:\"\\f013\"}.fa-trash-o:before{content:\"\\f014\"}.fa-home:before{content:\"\\f015\"}.fa-file-o:before{content:\"\\f016\"}.fa-clock-o:before{content:\"\\f017\"}.fa-road:before{content:\"\\f018\"}.fa-download:before{content:\"\\f019\"}.fa-arrow-circle-o-down:before{content:\"\\f01a\"}.fa-arrow-circle-o-up:before{content:\"\\f01b\"}.fa-inbox:before{content:\"\\f01c\"}.fa-play-circle-o:before{content:\"\\f01d\"}.fa-repeat:before,.fa-rotate-right:before{content:\"\\f01e\"}.fa-refresh:before{content:\"\\f021\"}.fa-list-alt:before{content:\"\\f022\"}.fa-lock:before{content:\"\\f023\"}.fa-flag:before{content:\"\\f024\"}.fa-headphones:before{content:\"\\f025\"}.fa-volume-off:before{content:\"\\f026\"}.fa-volume-down:before{content:\"\\f027\"}.fa-volume-up:before{content:\"\\f028\"}.fa-qrcode:before{content:\"\\f029\"}.fa-barcode:before{content:\"\\f02a\"}.fa-tag:before{content:\"\\f02b\"}.fa-tags:before{content:\"\\f02c\"}.fa-book:before{content:\"\\f02d\"}.fa-bookmark:before{content:\"\\f02e\"}.fa-print:before{content:\"\\f02f\"}.fa-camera:before{content:\"\\f030\"}.fa-font:before{content:\"\\f031\"}.fa-bold:before{content:\"\\f032\"}.fa-italic:before{content:\"\\f033\"}.fa-text-height:before{content:\"\\f034\"}.fa-text-width:before{content:\"\\f035\"}.fa-align-left:before{content:\"\\f036\"}.fa-align-center:before{content:\"\\f037\"}.fa-align-right:before{content:\"\\f038\"}.fa-align-justify:before{content:\"\\f039\"}.fa-list:before{content:\"\\f03a\"}.fa-dedent:before,.fa-outdent:before{content:\"\\f03b\"}.fa-indent:before{content:\"\\f03c\"}.fa-video-camera:before{content:\"\\f03d\"}.fa-image:before,.fa-photo:before,.fa-picture-o:before{content:\"\\f03e\"}.fa-pencil:before{content:\"\\f040\"}.fa-map-marker:before{content:\"\\f041\"}.fa-adjust:before{content:\"\\f042\"}.fa-tint:before{content:\"\\f043\"}.fa-edit:before,.fa-pencil-square-o:before{content:\"\\f044\"}.fa-share-square-o:before{content:\"\\f045\"}.fa-check-square-o:before{content:\"\\f046\"}.fa-arrows:before{content:\"\\f047\"}.fa-step-backward:before{content:\"\\f048\"}.fa-fast-backward:before{content:\"\\f049\"}.fa-backward:before{content:\"\\f04a\"}.fa-play:before{content:\"\\f04b\"}.fa-pause:before{content:\"\\f04c\"}.fa-stop:before{content:\"\\f04d\"}.fa-forward:before{content:\"\\f04e\"}.fa-fast-forward:before{content:\"\\f050\"}.fa-step-forward:before{content:\"\\f051\"}.fa-eject:before{content:\"\\f052\"}.fa-chevron-left:before{content:\"\\f053\"}.fa-chevron-right:before{content:\"\\f054\"}.fa-plus-circle:before{content:\"\\f055\"}.fa-minus-circle:before{content:\"\\f056\"}.fa-times-circle:before{content:\"\\f057\"}.fa-check-circle:before{content:\"\\f058\"}.fa-question-circle:before{content:\"\\f059\"}.fa-info-circle:before{content:\"\\f05a\"}.fa-crosshairs:before{content:\"\\f05b\"}.fa-times-circle-o:before{content:\"\\f05c\"}.fa-check-circle-o:before{content:\"\\f05d\"}.fa-ban:before{content:\"\\f05e\"}.fa-arrow-left:before{content:\"\\f060\"}.fa-arrow-right:before{content:\"\\f061\"}.fa-arrow-up:before{content:\"\\f062\"}.fa-arrow-down:before{content:\"\\f063\"}.fa-mail-forward:before,.fa-share:before{content:\"\\f064\"}.fa-expand:before{content:\"\\f065\"}.fa-compress:before{content:\"\\f066\"}.fa-plus:before{content:\"\\f067\"}.fa-minus:before{content:\"\\f068\"}.fa-asterisk:before{content:\"\\f069\"}.fa-exclamation-circle:before{content:\"\\f06a\"}.fa-gift:before{content:\"\\f06b\"}.fa-leaf:before{content:\"\\f06c\"}.fa-fire:before{content:\"\\f06d\"}.fa-eye:before{content:\"\\f06e\"}.fa-eye-slash:before{content:\"\\f070\"}.fa-exclamation-triangle:before,.fa-warning:before{content:\"\\f071\"}.fa-plane:before{content:\"\\f072\"}.fa-calendar:before{content:\"\\f073\"}.fa-random:before{content:\"\\f074\"}.fa-comment:before{content:\"\\f075\"}.fa-magnet:before{content:\"\\f076\"}.fa-chevron-up:before{content:\"\\f077\"}.fa-chevron-down:before{content:\"\\f078\"}.fa-retweet:before{content:\"\\f079\"}.fa-shopping-cart:before{content:\"\\f07a\"}.fa-folder:before{content:\"\\f07b\"}.fa-folder-open:before{content:\"\\f07c\"}.fa-arrows-v:before{content:\"\\f07d\"}.fa-arrows-h:before{content:\"\\f07e\"}.fa-bar-chart-o:before,.fa-bar-chart:before{content:\"\\f080\"}.fa-twitter-square:before{content:\"\\f081\"}.fa-facebook-square:before{content:\"\\f082\"}.fa-camera-retro:before{content:\"\\f083\"}.fa-key:before{content:\"\\f084\"}.fa-cogs:before,.fa-gears:before{content:\"\\f085\"}.fa-comments:before{content:\"\\f086\"}.fa-thumbs-o-up:before{content:\"\\f087\"}.fa-thumbs-o-down:before{content:\"\\f088\"}.fa-star-half:before{content:\"\\f089\"}.fa-heart-o:before{content:\"\\f08a\"}.fa-sign-out:before{content:\"\\f08b\"}.fa-linkedin-square:before{content:\"\\f08c\"}.fa-thumb-tack:before{content:\"\\f08d\"}.fa-external-link:before{content:\"\\f08e\"}.fa-sign-in:before{content:\"\\f090\"}.fa-trophy:before{content:\"\\f091\"}.fa-github-square:before{content:\"\\f092\"}.fa-upload:before{content:\"\\f093\"}.fa-lemon-o:before{content:\"\\f094\"}.fa-phone:before{content:\"\\f095\"}.fa-square-o:before{content:\"\\f096\"}.fa-bookmark-o:before{content:\"\\f097\"}.fa-phone-square:before{content:\"\\f098\"}.fa-twitter:before{content:\"\\f099\"}.fa-facebook-f:before,.fa-facebook:before{content:\"\\f09a\"}.fa-github:before{content:\"\\f09b\"}.fa-unlock:before{content:\"\\f09c\"}.fa-credit-card:before{content:\"\\f09d\"}.fa-feed:before,.fa-rss:before{content:\"\\f09e\"}.fa-hdd-o:before{content:\"\\f0a0\"}.fa-bullhorn:before{content:\"\\f0a1\"}.fa-bell:before{content:\"\\f0f3\"}.fa-certificate:before{content:\"\\f0a3\"}.fa-hand-o-right:before{content:\"\\f0a4\"}.fa-hand-o-left:before{content:\"\\f0a5\"}.fa-hand-o-up:before{content:\"\\f0a6\"}.fa-hand-o-down:before{content:\"\\f0a7\"}.fa-arrow-circle-left:before{content:\"\\f0a8\"}.fa-arrow-circle-right:before{content:\"\\f0a9\"}.fa-arrow-circle-up:before{content:\"\\f0aa\"}.fa-arrow-circle-down:before{content:\"\\f0ab\"}.fa-globe:before{content:\"\\f0ac\"}.fa-wrench:before{content:\"\\f0ad\"}.fa-tasks:before{content:\"\\f0ae\"}.fa-filter:before{content:\"\\f0b0\"}.fa-briefcase:before{content:\"\\f0b1\"}.fa-arrows-alt:before{content:\"\\f0b2\"}.fa-group:before,.fa-users:before{content:\"\\f0c0\"}.fa-chain:before,.fa-link:before{content:\"\\f0c1\"}.fa-cloud:before{content:\"\\f0c2\"}.fa-flask:before{content:\"\\f0c3\"}.fa-cut:before,.fa-scissors:before{content:\"\\f0c4\"}.fa-copy:before,.fa-files-o:before{content:\"\\f0c5\"}.fa-paperclip:before{content:\"\\f0c6\"}.fa-floppy-o:before,.fa-save:before{content:\"\\f0c7\"}.fa-square:before{content:\"\\f0c8\"}.fa-bars:before,.fa-navicon:before,.fa-reorder:before{content:\"\\f0c9\"}.fa-list-ul:before{content:\"\\f0ca\"}.fa-list-ol:before{content:\"\\f0cb\"}.fa-strikethrough:before{content:\"\\f0cc\"}.fa-underline:before{content:\"\\f0cd\"}.fa-table:before{content:\"\\f0ce\"}.fa-magic:before{content:\"\\f0d0\"}.fa-truck:before{content:\"\\f0d1\"}.fa-pinterest:before{content:\"\\f0d2\"}.fa-pinterest-square:before{content:\"\\f0d3\"}.fa-google-plus-square:before{content:\"\\f0d4\"}.fa-google-plus:before{content:\"\\f0d5\"}.fa-money:before{content:\"\\f0d6\"}.fa-caret-down:before{content:\"\\f0d7\"}.fa-caret-up:before{content:\"\\f0d8\"}.fa-caret-left:before{content:\"\\f0d9\"}.fa-caret-right:before{content:\"\\f0da\"}.fa-columns:before{content:\"\\f0db\"}.fa-sort:before,.fa-unsorted:before{content:\"\\f0dc\"}.fa-sort-desc:before,.fa-sort-down:before{content:\"\\f0dd\"}.fa-sort-asc:before,.fa-sort-up:before{content:\"\\f0de\"}.fa-envelope:before{content:\"\\f0e0\"}.fa-linkedin:before{content:\"\\f0e1\"}.fa-rotate-left:before,.fa-undo:before{content:\"\\f0e2\"}.fa-gavel:before,.fa-legal:before{content:\"\\f0e3\"}.fa-dashboard:before,.fa-tachometer:before{content:\"\\f0e4\"}.fa-comment-o:before{content:\"\\f0e5\"}.fa-comments-o:before{content:\"\\f0e6\"}.fa-bolt:before,.fa-flash:before{content:\"\\f0e7\"}.fa-sitemap:before{content:\"\\f0e8\"}.fa-umbrella:before{content:\"\\f0e9\"}.fa-clipboard:before,.fa-paste:before{content:\"\\f0ea\"}.fa-lightbulb-o:before{content:\"\\f0eb\"}.fa-exchange:before{content:\"\\f0ec\"}.fa-cloud-download:before{content:\"\\f0ed\"}.fa-cloud-upload:before{content:\"\\f0ee\"}.fa-user-md:before{content:\"\\f0f0\"}.fa-stethoscope:before{content:\"\\f0f1\"}.fa-suitcase:before{content:\"\\f0f2\"}.fa-bell-o:before{content:\"\\f0a2\"}.fa-coffee:before{content:\"\\f0f4\"}.fa-cutlery:before{content:\"\\f0f5\"}.fa-file-text-o:before{content:\"\\f0f6\"}.fa-building-o:before{content:\"\\f0f7\"}.fa-hospital-o:before{content:\"\\f0f8\"}.fa-ambulance:before{content:\"\\f0f9\"}.fa-medkit:before{content:\"\\f0fa\"}.fa-fighter-jet:before{content:\"\\f0fb\"}.fa-beer:before{content:\"\\f0fc\"}.fa-h-square:before{content:\"\\f0fd\"}.fa-plus-square:before{content:\"\\f0fe\"}.fa-angle-double-left:before{content:\"\\f100\"}.fa-angle-double-right:before{content:\"\\f101\"}.fa-angle-double-up:before{content:\"\\f102\"}.fa-angle-double-down:before{content:\"\\f103\"}.fa-angle-left:before{content:\"\\f104\"}.fa-angle-right:before{content:\"\\f105\"}.fa-angle-up:before{content:\"\\f106\"}.fa-angle-down:before{content:\"\\f107\"}.fa-desktop:before{content:\"\\f108\"}.fa-laptop:before{content:\"\\f109\"}.fa-tablet:before{content:\"\\f10a\"}.fa-mobile-phone:before,.fa-mobile:before{content:\"\\f10b\"}.fa-circle-o:before{content:\"\\f10c\"}.fa-quote-left:before{content:\"\\f10d\"}.fa-quote-right:before{content:\"\\f10e\"}.fa-spinner:before{content:\"\\f110\"}.fa-circle:before{content:\"\\f111\"}.fa-mail-reply:before,.fa-reply:before{content:\"\\f112\"}.fa-github-alt:before{content:\"\\f113\"}.fa-folder-o:before{content:\"\\f114\"}.fa-folder-open-o:before{content:\"\\f115\"}.fa-smile-o:before{content:\"\\f118\"}.fa-frown-o:before{content:\"\\f119\"}.fa-meh-o:before{content:\"\\f11a\"}.fa-gamepad:before{content:\"\\f11b\"}.fa-keyboard-o:before{content:\"\\f11c\"}.fa-flag-o:before{content:\"\\f11d\"}.fa-flag-checkered:before{content:\"\\f11e\"}.fa-terminal:before{content:\"\\f120\"}.fa-code:before{content:\"\\f121\"}.fa-mail-reply-all:before,.fa-reply-all:before{content:\"\\f122\"}.fa-star-half-empty:before,.fa-star-half-full:before,.fa-star-half-o:before{content:\"\\f123\"}.fa-location-arrow:before{content:\"\\f124\"}.fa-crop:before{content:\"\\f125\"}.fa-code-fork:before{content:\"\\f126\"}.fa-chain-broken:before,.fa-unlink:before{content:\"\\f127\"}.fa-question:before{content:\"\\f128\"}.fa-info:before{content:\"\\f129\"}.fa-exclamation:before{content:\"\\f12a\"}.fa-superscript:before{content:\"\\f12b\"}.fa-subscript:before{content:\"\\f12c\"}.fa-eraser:before{content:\"\\f12d\"}.fa-puzzle-piece:before{content:\"\\f12e\"}.fa-microphone:before{content:\"\\f130\"}.fa-microphone-slash:before{content:\"\\f131\"}.fa-shield:before{content:\"\\f132\"}.fa-calendar-o:before{content:\"\\f133\"}.fa-fire-extinguisher:before{content:\"\\f134\"}.fa-rocket:before{content:\"\\f135\"}.fa-maxcdn:before{content:\"\\f136\"}.fa-chevron-circle-left:before{content:\"\\f137\"}.fa-chevron-circle-right:before{content:\"\\f138\"}.fa-chevron-circle-up:before{content:\"\\f139\"}.fa-chevron-circle-down:before{content:\"\\f13a\"}.fa-html5:before{content:\"\\f13b\"}.fa-css3:before{content:\"\\f13c\"}.fa-anchor:before{content:\"\\f13d\"}.fa-unlock-alt:before{content:\"\\f13e\"}.fa-bullseye:before{content:\"\\f140\"}.fa-ellipsis-h:before{content:\"\\f141\"}.fa-ellipsis-v:before{content:\"\\f142\"}.fa-rss-square:before{content:\"\\f143\"}.fa-play-circle:before{content:\"\\f144\"}.fa-ticket:before{content:\"\\f145\"}.fa-minus-square:before{content:\"\\f146\"}.fa-minus-square-o:before{content:\"\\f147\"}.fa-level-up:before{content:\"\\f148\"}.fa-level-down:before{content:\"\\f149\"}.fa-check-square:before{content:\"\\f14a\"}.fa-pencil-square:before{content:\"\\f14b\"}.fa-external-link-square:before{content:\"\\f14c\"}.fa-share-square:before{content:\"\\f14d\"}.fa-compass:before{content:\"\\f14e\"}.fa-caret-square-o-down:before,.fa-toggle-down:before{content:\"\\f150\"}.fa-caret-square-o-up:before,.fa-toggle-up:before{content:\"\\f151\"}.fa-caret-square-o-right:before,.fa-toggle-right:before{content:\"\\f152\"}.fa-eur:before,.fa-euro:before{content:\"\\f153\"}.fa-gbp:before{content:\"\\f154\"}.fa-dollar:before,.fa-usd:before{content:\"\\f155\"}.fa-inr:before,.fa-rupee:before{content:\"\\f156\"}.fa-cny:before,.fa-jpy:before,.fa-rmb:before,.fa-yen:before{content:\"\\f157\"}.fa-rouble:before,.fa-rub:before,.fa-ruble:before{content:\"\\f158\"}.fa-krw:before,.fa-won:before{content:\"\\f159\"}.fa-bitcoin:before,.fa-btc:before{content:\"\\f15a\"}.fa-file:before{content:\"\\f15b\"}.fa-file-text:before{content:\"\\f15c\"}.fa-sort-alpha-asc:before{content:\"\\f15d\"}.fa-sort-alpha-desc:before{content:\"\\f15e\"}.fa-sort-amount-asc:before{content:\"\\f160\"}.fa-sort-amount-desc:before{content:\"\\f161\"}.fa-sort-numeric-asc:before{content:\"\\f162\"}.fa-sort-numeric-desc:before{content:\"\\f163\"}.fa-thumbs-up:before{content:\"\\f164\"}.fa-thumbs-down:before{content:\"\\f165\"}.fa-youtube-square:before{content:\"\\f166\"}.fa-youtube:before{content:\"\\f167\"}.fa-xing:before{content:\"\\f168\"}.fa-xing-square:before{content:\"\\f169\"}.fa-youtube-play:before{content:\"\\f16a\"}.fa-dropbox:before{content:\"\\f16b\"}.fa-stack-overflow:before{content:\"\\f16c\"}.fa-instagram:before{content:\"\\f16d\"}.fa-flickr:before{content:\"\\f16e\"}.fa-adn:before{content:\"\\f170\"}.fa-bitbucket:before{content:\"\\f171\"}.fa-bitbucket-square:before{content:\"\\f172\"}.fa-tumblr:before{content:\"\\f173\"}.fa-tumblr-square:before{content:\"\\f174\"}.fa-long-arrow-down:before{content:\"\\f175\"}.fa-long-arrow-up:before{content:\"\\f176\"}.fa-long-arrow-left:before{content:\"\\f177\"}.fa-long-arrow-right:before{content:\"\\f178\"}.fa-apple:before{content:\"\\f179\"}.fa-windows:before{content:\"\\f17a\"}.fa-android:before{content:\"\\f17b\"}.fa-linux:before{content:\"\\f17c\"}.fa-dribbble:before{content:\"\\f17d\"}.fa-skype:before{content:\"\\f17e\"}.fa-foursquare:before{content:\"\\f180\"}.fa-trello:before{content:\"\\f181\"}.fa-female:before{content:\"\\f182\"}.fa-male:before{content:\"\\f183\"}.fa-gittip:before,.fa-gratipay:before{content:\"\\f184\"}.fa-sun-o:before{content:\"\\f185\"}.fa-moon-o:before{content:\"\\f186\"}.fa-archive:before{content:\"\\f187\"}.fa-bug:before{content:\"\\f188\"}.fa-vk:before{content:\"\\f189\"}.fa-weibo:before{content:\"\\f18a\"}.fa-renren:before{content:\"\\f18b\"}.fa-pagelines:before{content:\"\\f18c\"}.fa-stack-exchange:before{content:\"\\f18d\"}.fa-arrow-circle-o-right:before{content:\"\\f18e\"}.fa-arrow-circle-o-left:before{content:\"\\f190\"}.fa-caret-square-o-left:before,.fa-toggle-left:before{content:\"\\f191\"}.fa-dot-circle-o:before{content:\"\\f192\"}.fa-wheelchair:before{content:\"\\f193\"}.fa-vimeo-square:before{content:\"\\f194\"}.fa-try:before,.fa-turkish-lira:before{content:\"\\f195\"}.fa-plus-square-o:before{content:\"\\f196\"}.fa-space-shuttle:before{content:\"\\f197\"}.fa-slack:before{content:\"\\f198\"}.fa-envelope-square:before{content:\"\\f199\"}.fa-wordpress:before{content:\"\\f19a\"}.fa-openid:before{content:\"\\f19b\"}.fa-bank:before,.fa-institution:before,.fa-university:before{content:\"\\f19c\"}.fa-graduation-cap:before,.fa-mortar-board:before{content:\"\\f19d\"}.fa-yahoo:before{content:\"\\f19e\"}.fa-google:before{content:\"\\f1a0\"}.fa-reddit:before{content:\"\\f1a1\"}.fa-reddit-square:before{content:\"\\f1a2\"}.fa-stumbleupon-circle:before{content:\"\\f1a3\"}.fa-stumbleupon:before{content:\"\\f1a4\"}.fa-delicious:before{content:\"\\f1a5\"}.fa-digg:before{content:\"\\f1a6\"}.fa-pied-piper-pp:before{content:\"\\f1a7\"}.fa-pied-piper-alt:before{content:\"\\f1a8\"}.fa-drupal:before{content:\"\\f1a9\"}.fa-joomla:before{content:\"\\f1aa\"}.fa-language:before{content:\"\\f1ab\"}.fa-fax:before{content:\"\\f1ac\"}.fa-building:before{content:\"\\f1ad\"}.fa-child:before{content:\"\\f1ae\"}.fa-paw:before{content:\"\\f1b0\"}.fa-spoon:before{content:\"\\f1b1\"}.fa-cube:before{content:\"\\f1b2\"}.fa-cubes:before{content:\"\\f1b3\"}.fa-behance:before{content:\"\\f1b4\"}.fa-behance-square:before{content:\"\\f1b5\"}.fa-steam:before{content:\"\\f1b6\"}.fa-steam-square:before{content:\"\\f1b7\"}.fa-recycle:before{content:\"\\f1b8\"}.fa-automobile:before,.fa-car:before{content:\"\\f1b9\"}.fa-cab:before,.fa-taxi:before{content:\"\\f1ba\"}.fa-tree:before{content:\"\\f1bb\"}.fa-spotify:before{content:\"\\f1bc\"}.fa-deviantart:before{content:\"\\f1bd\"}.fa-soundcloud:before{content:\"\\f1be\"}.fa-database:before{content:\"\\f1c0\"}.fa-file-pdf-o:before{content:\"\\f1c1\"}.fa-file-word-o:before{content:\"\\f1c2\"}.fa-file-excel-o:before{content:\"\\f1c3\"}.fa-file-powerpoint-o:before{content:\"\\f1c4\"}.fa-file-image-o:before,.fa-file-photo-o:before,.fa-file-picture-o:before{content:\"\\f1c5\"}.fa-file-archive-o:before,.fa-file-zip-o:before{content:\"\\f1c6\"}.fa-file-audio-o:before,.fa-file-sound-o:before{content:\"\\f1c7\"}.fa-file-movie-o:before,.fa-file-video-o:before{content:\"\\f1c8\"}.fa-file-code-o:before{content:\"\\f1c9\"}.fa-vine:before{content:\"\\f1ca\"}.fa-codepen:before{content:\"\\f1cb\"}.fa-jsfiddle:before{content:\"\\f1cc\"}.fa-life-bouy:before,.fa-life-buoy:before,.fa-life-ring:before,.fa-life-saver:before,.fa-support:before{content:\"\\f1cd\"}.fa-circle-o-notch:before{content:\"\\f1ce\"}.fa-ra:before,.fa-rebel:before,.fa-resistance:before{content:\"\\f1d0\"}.fa-empire:before,.fa-ge:before{content:\"\\f1d1\"}.fa-git-square:before{content:\"\\f1d2\"}.fa-git:before{content:\"\\f1d3\"}.fa-hacker-news:before,.fa-y-combinator-square:before,.fa-yc-square:before{content:\"\\f1d4\"}.fa-tencent-weibo:before{content:\"\\f1d5\"}.fa-qq:before{content:\"\\f1d6\"}.fa-wechat:before,.fa-weixin:before{content:\"\\f1d7\"}.fa-paper-plane:before,.fa-send:before{content:\"\\f1d8\"}.fa-paper-plane-o:before,.fa-send-o:before{content:\"\\f1d9\"}.fa-history:before{content:\"\\f1da\"}.fa-circle-thin:before{content:\"\\f1db\"}.fa-header:before{content:\"\\f1dc\"}.fa-paragraph:before{content:\"\\f1dd\"}.fa-sliders:before{content:\"\\f1de\"}.fa-share-alt:before{content:\"\\f1e0\"}.fa-share-alt-square:before{content:\"\\f1e1\"}.fa-bomb:before{content:\"\\f1e2\"}.fa-futbol-o:before,.fa-soccer-ball-o:before{content:\"\\f1e3\"}.fa-tty:before{content:\"\\f1e4\"}.fa-binoculars:before{content:\"\\f1e5\"}.fa-plug:before{content:\"\\f1e6\"}.fa-slideshare:before{content:\"\\f1e7\"}.fa-twitch:before{content:\"\\f1e8\"}.fa-yelp:before{content:\"\\f1e9\"}.fa-newspaper-o:before{content:\"\\f1ea\"}.fa-wifi:before{content:\"\\f1eb\"}.fa-calculator:before{content:\"\\f1ec\"}.fa-paypal:before{content:\"\\f1ed\"}.fa-google-wallet:before{content:\"\\f1ee\"}.fa-cc-visa:before{content:\"\\f1f0\"}.fa-cc-mastercard:before{content:\"\\f1f1\"}.fa-cc-discover:before{content:\"\\f1f2\"}.fa-cc-amex:before{content:\"\\f1f3\"}.fa-cc-paypal:before{content:\"\\f1f4\"}.fa-cc-stripe:before{content:\"\\f1f5\"}.fa-bell-slash:before{content:\"\\f1f6\"}.fa-bell-slash-o:before{content:\"\\f1f7\"}.fa-trash:before{content:\"\\f1f8\"}.fa-copyright:before{content:\"\\f1f9\"}.fa-at:before{content:\"\\f1fa\"}.fa-eyedropper:before{content:\"\\f1fb\"}.fa-paint-brush:before{content:\"\\f1fc\"}.fa-birthday-cake:before{content:\"\\f1fd\"}.fa-area-chart:before{content:\"\\f1fe\"}.fa-pie-chart:before{content:\"\\f200\"}.fa-line-chart:before{content:\"\\f201\"}.fa-lastfm:before{content:\"\\f202\"}.fa-lastfm-square:before{content:\"\\f203\"}.fa-toggle-off:before{content:\"\\f204\"}.fa-toggle-on:before{content:\"\\f205\"}.fa-bicycle:before{content:\"\\f206\"}.fa-bus:before{content:\"\\f207\"}.fa-ioxhost:before{content:\"\\f208\"}.fa-angellist:before{content:\"\\f209\"}.fa-cc:before{content:\"\\f20a\"}.fa-ils:before,.fa-shekel:before,.fa-sheqel:before{content:\"\\f20b\"}.fa-meanpath:before{content:\"\\f20c\"}.fa-buysellads:before{content:\"\\f20d\"}.fa-connectdevelop:before{content:\"\\f20e\"}.fa-dashcube:before{content:\"\\f210\"}.fa-forumbee:before{content:\"\\f211\"}.fa-leanpub:before{content:\"\\f212\"}.fa-sellsy:before{content:\"\\f213\"}.fa-shirtsinbulk:before{content:\"\\f214\"}.fa-simplybuilt:before{content:\"\\f215\"}.fa-skyatlas:before{content:\"\\f216\"}.fa-cart-plus:before{content:\"\\f217\"}.fa-cart-arrow-down:before{content:\"\\f218\"}.fa-diamond:before{content:\"\\f219\"}.fa-ship:before{content:\"\\f21a\"}.fa-user-secret:before{content:\"\\f21b\"}.fa-motorcycle:before{content:\"\\f21c\"}.fa-street-view:before{content:\"\\f21d\"}.fa-heartbeat:before{content:\"\\f21e\"}.fa-venus:before{content:\"\\f221\"}.fa-mars:before{content:\"\\f222\"}.fa-mercury:before{content:\"\\f223\"}.fa-intersex:before,.fa-transgender:before{content:\"\\f224\"}.fa-transgender-alt:before{content:\"\\f225\"}.fa-venus-double:before{content:\"\\f226\"}.fa-mars-double:before{content:\"\\f227\"}.fa-venus-mars:before{content:\"\\f228\"}.fa-mars-stroke:before{content:\"\\f229\"}.fa-mars-stroke-v:before{content:\"\\f22a\"}.fa-mars-stroke-h:before{content:\"\\f22b\"}.fa-neuter:before{content:\"\\f22c\"}.fa-genderless:before{content:\"\\f22d\"}.fa-facebook-official:before{content:\"\\f230\"}.fa-pinterest-p:before{content:\"\\f231\"}.fa-whatsapp:before{content:\"\\f232\"}.fa-server:before{content:\"\\f233\"}.fa-user-plus:before{content:\"\\f234\"}.fa-user-times:before{content:\"\\f235\"}.fa-bed:before,.fa-hotel:before{content:\"\\f236\"}.fa-viacoin:before{content:\"\\f237\"}.fa-train:before{content:\"\\f238\"}.fa-subway:before{content:\"\\f239\"}.fa-medium:before{content:\"\\f23a\"}.fa-y-combinator:before,.fa-yc:before{content:\"\\f23b\"}.fa-optin-monster:before{content:\"\\f23c\"}.fa-opencart:before{content:\"\\f23d\"}.fa-expeditedssl:before{content:\"\\f23e\"}.fa-battery-4:before,.fa-battery-full:before,.fa-battery:before{content:\"\\f240\"}.fa-battery-3:before,.fa-battery-three-quarters:before{content:\"\\f241\"}.fa-battery-2:before,.fa-battery-half:before{content:\"\\f242\"}.fa-battery-1:before,.fa-battery-quarter:before{content:\"\\f243\"}.fa-battery-0:before,.fa-battery-empty:before{content:\"\\f244\"}.fa-mouse-pointer:before{content:\"\\f245\"}.fa-i-cursor:before{content:\"\\f246\"}.fa-object-group:before{content:\"\\f247\"}.fa-object-ungroup:before{content:\"\\f248\"}.fa-sticky-note:before{content:\"\\f249\"}.fa-sticky-note-o:before{content:\"\\f24a\"}.fa-cc-jcb:before{content:\"\\f24b\"}.fa-cc-diners-club:before{content:\"\\f24c\"}.fa-clone:before{content:\"\\f24d\"}.fa-balance-scale:before{content:\"\\f24e\"}.fa-hourglass-o:before{content:\"\\f250\"}.fa-hourglass-1:before,.fa-hourglass-start:before{content:\"\\f251\"}.fa-hourglass-2:before,.fa-hourglass-half:before{content:\"\\f252\"}.fa-hourglass-3:before,.fa-hourglass-end:before{content:\"\\f253\"}.fa-hourglass:before{content:\"\\f254\"}.fa-hand-grab-o:before,.fa-hand-rock-o:before{content:\"\\f255\"}.fa-hand-paper-o:before,.fa-hand-stop-o:before{content:\"\\f256\"}.fa-hand-scissors-o:before{content:\"\\f257\"}.fa-hand-lizard-o:before{content:\"\\f258\"}.fa-hand-spock-o:before{content:\"\\f259\"}.fa-hand-pointer-o:before{content:\"\\f25a\"}.fa-hand-peace-o:before{content:\"\\f25b\"}.fa-trademark:before{content:\"\\f25c\"}.fa-registered:before{content:\"\\f25d\"}.fa-creative-commons:before{content:\"\\f25e\"}.fa-gg:before{content:\"\\f260\"}.fa-gg-circle:before{content:\"\\f261\"}.fa-tripadvisor:before{content:\"\\f262\"}.fa-odnoklassniki:before{content:\"\\f263\"}.fa-odnoklassniki-square:before{content:\"\\f264\"}.fa-get-pocket:before{content:\"\\f265\"}.fa-wikipedia-w:before{content:\"\\f266\"}.fa-safari:before{content:\"\\f267\"}.fa-chrome:before{content:\"\\f268\"}.fa-firefox:before{content:\"\\f269\"}.fa-opera:before{content:\"\\f26a\"}.fa-internet-explorer:before{content:\"\\f26b\"}.fa-television:before,.fa-tv:before{content:\"\\f26c\"}.fa-contao:before{content:\"\\f26d\"}.fa-500px:before{content:\"\\f26e\"}.fa-amazon:before{content:\"\\f270\"}.fa-calendar-plus-o:before{content:\"\\f271\"}.fa-calendar-minus-o:before{content:\"\\f272\"}.fa-calendar-times-o:before{content:\"\\f273\"}.fa-calendar-check-o:before{content:\"\\f274\"}.fa-industry:before{content:\"\\f275\"}.fa-map-pin:before{content:\"\\f276\"}.fa-map-signs:before{content:\"\\f277\"}.fa-map-o:before{content:\"\\f278\"}.fa-map:before{content:\"\\f279\"}.fa-commenting:before{content:\"\\f27a\"}.fa-commenting-o:before{content:\"\\f27b\"}.fa-houzz:before{content:\"\\f27c\"}.fa-vimeo:before{content:\"\\f27d\"}.fa-black-tie:before{content:\"\\f27e\"}.fa-fonticons:before{content:\"\\f280\"}.fa-reddit-alien:before{content:\"\\f281\"}.fa-edge:before{content:\"\\f282\"}.fa-credit-card-alt:before{content:\"\\f283\"}.fa-codiepie:before{content:\"\\f284\"}.fa-modx:before{content:\"\\f285\"}.fa-fort-awesome:before{content:\"\\f286\"}.fa-usb:before{content:\"\\f287\"}.fa-product-hunt:before{content:\"\\f288\"}.fa-mixcloud:before{content:\"\\f289\"}.fa-scribd:before{content:\"\\f28a\"}.fa-pause-circle:before{content:\"\\f28b\"}.fa-pause-circle-o:before{content:\"\\f28c\"}.fa-stop-circle:before{content:\"\\f28d\"}.fa-stop-circle-o:before{content:\"\\f28e\"}.fa-shopping-bag:before{content:\"\\f290\"}.fa-shopping-basket:before{content:\"\\f291\"}.fa-hashtag:before{content:\"\\f292\"}.fa-bluetooth:before{content:\"\\f293\"}.fa-bluetooth-b:before{content:\"\\f294\"}.fa-percent:before{content:\"\\f295\"}.fa-gitlab:before{content:\"\\f296\"}.fa-wpbeginner:before{content:\"\\f297\"}.fa-wpforms:before{content:\"\\f298\"}.fa-envira:before{content:\"\\f299\"}.fa-universal-access:before{content:\"\\f29a\"}.fa-wheelchair-alt:before{content:\"\\f29b\"}.fa-question-circle-o:before{content:\"\\f29c\"}.fa-blind:before{content:\"\\f29d\"}.fa-audio-description:before{content:\"\\f29e\"}.fa-volume-control-phone:before{content:\"\\f2a0\"}.fa-braille:before{content:\"\\f2a1\"}.fa-assistive-listening-systems:before{content:\"\\f2a2\"}.fa-american-sign-language-interpreting:before,.fa-asl-interpreting:before{content:\"\\f2a3\"}.fa-deaf:before,.fa-deafness:before,.fa-hard-of-hearing:before{content:\"\\f2a4\"}.fa-glide:before{content:\"\\f2a5\"}.fa-glide-g:before{content:\"\\f2a6\"}.fa-sign-language:before,.fa-signing:before{content:\"\\f2a7\"}.fa-low-vision:before{content:\"\\f2a8\"}.fa-viadeo:before{content:\"\\f2a9\"}.fa-viadeo-square:before{content:\"\\f2aa\"}.fa-snapchat:before{content:\"\\f2ab\"}.fa-snapchat-ghost:before{content:\"\\f2ac\"}.fa-snapchat-square:before{content:\"\\f2ad\"}.fa-pied-piper:before{content:\"\\f2ae\"}.fa-first-order:before{content:\"\\f2b0\"}.fa-yoast:before{content:\"\\f2b1\"}.fa-themeisle:before{content:\"\\f2b2\"}.fa-google-plus-circle:before,.fa-google-plus-official:before{content:\"\\f2b3\"}.fa-fa:before,.fa-font-awesome:before{content:\"\\f2b4\"}.fa-handshake-o:before{content:\"\\f2b5\"}.fa-envelope-open:before{content:\"\\f2b6\"}.fa-envelope-open-o:before{content:\"\\f2b7\"}.fa-linode:before{content:\"\\f2b8\"}.fa-address-book:before{content:\"\\f2b9\"}.fa-address-book-o:before{content:\"\\f2ba\"}.fa-address-card:before,.fa-vcard:before{content:\"\\f2bb\"}.fa-address-card-o:before,.fa-vcard-o:before{content:\"\\f2bc\"}.fa-user-circle:before{content:\"\\f2bd\"}.fa-user-circle-o:before{content:\"\\f2be\"}.fa-user-o:before{content:\"\\f2c0\"}.fa-id-badge:before{content:\"\\f2c1\"}.fa-drivers-license:before,.fa-id-card:before{content:\"\\f2c2\"}.fa-drivers-license-o:before,.fa-id-card-o:before{content:\"\\f2c3\"}.fa-quora:before{content:\"\\f2c4\"}.fa-free-code-camp:before{content:\"\\f2c5\"}.fa-telegram:before{content:\"\\f2c6\"}.fa-thermometer-4:before,.fa-thermometer-full:before,.fa-thermometer:before{content:\"\\f2c7\"}.fa-thermometer-3:before,.fa-thermometer-three-quarters:before{content:\"\\f2c8\"}.fa-thermometer-2:before,.fa-thermometer-half:before{content:\"\\f2c9\"}.fa-thermometer-1:before,.fa-thermometer-quarter:before{content:\"\\f2ca\"}.fa-thermometer-0:before,.fa-thermometer-empty:before{content:\"\\f2cb\"}.fa-shower:before{content:\"\\f2cc\"}.fa-bath:before,.fa-bathtub:before,.fa-s15:before{content:\"\\f2cd\"}.fa-podcast:before{content:\"\\f2ce\"}.fa-window-maximize:before{content:\"\\f2d0\"}.fa-window-minimize:before{content:\"\\f2d1\"}.fa-window-restore:before{content:\"\\f2d2\"}.fa-times-rectangle:before,.fa-window-close:before{content:\"\\f2d3\"}.fa-times-rectangle-o:before,.fa-window-close-o:before{content:\"\\f2d4\"}.fa-bandcamp:before{content:\"\\f2d5\"}.fa-grav:before{content:\"\\f2d6\"}.fa-etsy:before{content:\"\\f2d7\"}.fa-imdb:before{content:\"\\f2d8\"}.fa-ravelry:before{content:\"\\f2d9\"}.fa-eercast:before{content:\"\\f2da\"}.fa-microchip:before{content:\"\\f2db\"}.fa-snowflake-o:before{content:\"\\f2dc\"}.fa-superpowers:before{content:\"\\f2dd\"}.fa-wpexplorer:before{content:\"\\f2de\"}.fa-meetup:before{content:\"\\f2e0\"}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto} /* rebuild by neat */"},{"title":"","date":"2025-08-12T14:54:16.416Z","updated":"2025-08-12T14:54:16.416Z","comments":true,"path":"404/css/style.css","permalink":"https://czqu.net/404/css/style.css","excerpt":"","text":"/* build time:Tue Aug 12 2025 14:54:40 GMT+0000 (Coordinated Universal Time)*/ html{scroll-behavior:smooth}body,html{margin:0;padding:0;color:#585858}*{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif}.wrapper-full{width:100%;padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}.wrapper{width:100%;padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width:576px){.wrapper{max-width:540px}}@media (min-width:768px){.wrapper{max-width:720px}}@media (min-width:992px){.wrapper{max-width:960px}}@media (min-width:1200px){.wrapper{max-width:1140px}}.img-responsive{max-width:100%;display:block}.img-fluid{width:100%}.d-grid{display:grid}.d-flex{display:flex;display:-webkit-flex;flex-wrap:wrap}.text-center{text-align:center}.text-left{text-align:left}.text-right{text-align:right}button,input,select{-webkit-appearance:none;outline:0}.btn,button,select{cursor:pointer}a{text-decoration:none}iframe{border:none}h1,h2,h3,h4,h5,h6,ol,p,ul{margin:0;padding:0}.p-relative{position:relative}.p-absolute{position:absolute}.p-fixed{position:fixed}.p-sticky{position:-webkit-sticky;position:sticky}body a:hover,body button:hover{opacity:.8}a,h1,h2,h3,h4,h5,h6{color:#050404}p{color:#585858}.error-page .covers-main{background:url(../images/error.jpg) no-repeat center;background-size:cover;-webkit-background-size:cover;-moz-background-size:cover;-o-background-size:cover;-ms-background-size:cover;position:relative;z-index:0;min-height:100vh;align-items:center;display:grid;max-width:100%}.error-page .covers-main:before{content:\"\";background:rgba(16,16,16,.4);position:absolute;top:0;min-height:100%;left:0;right:0;z-index:-1}.error-page .main-cover{max-width:510px;margin:0 auto}.error-page a.logo{color:#fff;font-size:32px;font-weight:100;margin-bottom:1rem;display:inline-block;line-height:44px}.error-page .cover-para{color:#fff;line-height:120px;font-size:180px;margin-bottom:50px;font-weight:600}.error-page h4.cover-para span{font-size:150px}.error-page p.form-text{font-size:17px;line-height:25px;color:#eee}.error-page h5.form-title{color:#eee}.error-page a.back-button{border:none;font-weight:600;display:inline-block;font-size:16px;color:#fff;background:rgba(255,255,255,.16);text-align:center;padding:12px 18px;margin-top:4em;box-shadow:0 3px 4px 2px rgba(14,14,14,.04)}.copyright p{font-size:15px;color:#ccc;line-height:20px;margin-top:4rem}.copyright p a{color:#fff}@media screen and (max-width:568px){.error-page a.logo{font-size:35px}.error-page p.page-detail{font-size:18px}.error-page a.back-button{margin-top:3em}.error-page .cover-para{font-size:130px;margin-bottom:20px}.error-page .cover-para{font-size:160px}.error-page h4.cover-para span{font-size:130px}}@media screen and (max-width:384px){.error-page p.form-text{font-size:16px}.error-page .cover-para{font-size:130px}.error-page h4.cover-para span{font-size:110px}} /* rebuild by neat */"}],"posts":[{"title":"How to Install a Specific Version of Docker on CentOS","slug":"release/install-docker","date":"2023-05-02T21:02:00.000Z","updated":"2023-05-03T09:02:00.000Z","comments":true,"path":"posts/3776602279/","permalink":"https://czqu.net/posts/3776602279/","excerpt":"","text":"Docker is a popular containerization technology that allows you to quickly create, deploy, and run applications. However, sometimes you may need to install a specific version of Docker instead of the latest version. In this article, we’ll walk you through the steps to install a specific version of Docker on CentOS. Step 1: Install Necessary PackagesFirst, you need to install some necessary packages, including yum-utils, device-mapper-persistent-data, and lvm2. These packages will help you configure Docker storage drivers and LVM volumes. You can install these packages using the following command: 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 Step 2: Add Docker RepositoryNext, you need to add the Docker repository. You can add the Docker repository to your CentOS system using the following command: 1sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo Alternatively, if you’re in China, you can use the Aliyun mirror by running the following command: 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo This will add the YUM repository configuration file for the Docker repository. Step 3: Update YUM CacheOnce the Docker repository has been added to the system, you need to update the YUM cache to be able to install packages from the repository. You can update the YUM cache using the following command: 1yum makecache Step 4: Install Specific Version of DockerFinally, you can install the specific version of Docker that you need using the following command: 1yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io Where &lt;VERSION_STRING&gt; is the version number of the Docker version you want to install. For example, if you want to install Docker version 20.10.8, you can use the following command: 1yum install docker-ce-20.10.8 docker-ce-cli-20.10.8 containerd.io ConclusionIn this article, we’ve shown you how to install a specific version of Docker on CentOS. By following these four simple steps, you can successfully install the Docker version you need and start using Docker for containerized development and deployment. If you encounter any issues, please refer to the official Docker documentation or community support. Install Docker Engine on CentOS | Docker Documentation","categories":[{"name":"Backend Development","slug":"Backend-Development","permalink":"https://czqu.net/categories/Backend-Development/"}],"tags":[{"name":"Backend Development","slug":"Backend-Development","permalink":"https://czqu.net/tags/Backend-Development/"}]},{"title":"How to Get Log4j Log File Path in Java","slug":"release/log4j-get-log-path","date":"2023-03-20T22:02:00.000Z","updated":"2023-03-20T22:02:00.000Z","comments":true,"path":"posts/735037507/","permalink":"https://czqu.net/posts/735037507/","excerpt":"","text":"IntroductionLog4j is one of the widely used logging tools on the Java platform. It allows configuration of logging output to various destinations, such as console, file, and database. In real-world applications, it is often necessary to obtain the file path of the Log4j log file for viewing, analysis, and processing purposes. In this blog, we will discuss a method to obtain the Log4j log file path using Java code. Code exampleIn Log4j, a Logger instance can be used to get all of its Appenders using the getAppenders() method. An Appender is an abstract class with several concrete subclasses, such as ConsoleAppender, FileAppender, and RollingFileAppender. The FileAppender and RollingFileAppender subclasses are used to output logs to a file. To obtain the file path of a RollingFileAppender instance, we can traverse all the Appenders of a Logger instance, and check each Appender instance to see if it is a RollingFileAppender instance. If we find one, we can then obtain the file path by calling the getFileName() method of the RollingFileAppender instance. Here is an example code snippet that demonstrates this process: 1234567891011121314151617181920212223242526272829import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import org.apache.logging.log4j.core.Appender;import org.apache.logging.log4j.core.appender.RollingFileAppender;import java.util.Map;public class Log4jUtils { public static String getLogPath(Logger logger) { Map&lt;String, Appender&gt; appenderMap = ((org.apache.logging.log4j.core.Logger) logger).getAppenders(); if (appenderMap == null) { return \"\"; } for (Appender appender : appenderMap.values()) { if (appender instanceof RollingFileAppender) { return ((RollingFileAppender) appender).getFileName(); } } return \"\"; } public static void main(String[] args) { Logger logger = LogManager.getLogger(Log4jUtils.class); String logPath = getLogPath(logger); System.out.println(logPath); }} In this code, we first cast the Logger instance to the org.apache.logging.log4j.core.Logger type and then call the getAppenders() method to get all the Appenders. We then traverse each Appender instance and check if it is an instance of RollingFileAppender. If we find one, we obtain its file path by calling the getFileName() method. Conclusion In this blog, we have discussed a method to obtain the file path of a Log4j log file using Java code. By traversing the Appenders of a Logger instance and checking if it is a RollingFileAppender instance, we can obtain its file path. This method can be useful for viewing, analyzing, and processing Log4j log files.","categories":[{"name":"Backend Development","slug":"Backend-Development","permalink":"https://czqu.net/categories/Backend-Development/"}],"tags":[{"name":"Backend Development","slug":"Backend-Development","permalink":"https://czqu.net/tags/Backend-Development/"},{"name":"Java","slug":"Java","permalink":"https://czqu.net/tags/Java/"}]},{"title":"How to Execute JavaScript Code and Functions in Java","slug":"release/java-exute-js","date":"2023-03-16T12:38:00.000Z","updated":"2023-03-16T12:38:00.000Z","comments":true,"path":"posts/2250085940/","permalink":"https://czqu.net/posts/2250085940/","excerpt":"","text":"JavaScript is a popular scripting language used for developing dynamic and interactive web pages. While JavaScript is primarily used in web development, it can also be used in other areas such as server-side scripting, desktop applications, and mobile apps. In this blog, we will explore how to execute JavaScript code and functions in Java. To execute JavaScript code in Java, we can use the ScriptEngine class provided by the Java API. The ScriptEngine class is used to execute scripts written in various languages, including JavaScript. Here is a sample code that demonstrates how to execute JavaScript code in Java: 12345678910111213141516171819202122232425import javax.script.ScriptEngine;import javax.script.ScriptEngineManager;import javax.script.ScriptException;public class JavaScriptExecutor { public static void main(String[] args) { // Create a ScriptEngineManager object ScriptEngineManager manager = new ScriptEngineManager(); // Get the JavaScript engine ScriptEngine engine = manager.getEngineByName(\"javascript\"); try { // Execute JavaScript code String script = \"var a = 1 + 2; a;\"; Object result = engine.eval(script); // Print the result System.out.println(result); } catch (ScriptException e) { e.printStackTrace(); } }} In this example, we create a ScriptEngineManager object and get the JavaScript engine using the getEngineByName method. Then we execute the JavaScript code using the eval method of the ScriptEngine class and store the result in an Object variable. Finally, we print the result to the console. To execute JavaScript functions in Java, we can define the function in JavaScript code and then call it from our Java code using the ScriptEngine class. Here is a sample code that demonstrates how to execute JavaScript functions in Java: 12345678910111213141516171819202122232425262728import javax.script.ScriptEngine;import javax.script.ScriptEngineManager;import javax.script.ScriptException;public class JavaScriptFunctionExecutor { public static void main(String[] args) { // Create a ScriptEngineManager object ScriptEngineManager manager = new ScriptEngineManager(); // Get the JavaScript engine ScriptEngine engine = manager.getEngineByName(\"javascript\"); try { // Define a JavaScript function String script = \"function add(a, b) { return a + b; }\"; // Execute the JavaScript function and get the result engine.eval(script); Object result = engine.eval(\"add(1, 2)\"); // Print the result System.out.println(result); } catch (ScriptException e) { e.printStackTrace(); } }} In this example, we define a JavaScript function called add that takes two arguments and returns their sum. Then we execute the function using the eval method of the ScriptEngine class and store the result in an Object variable. Finally, we print the result to the console. In conclusion, the ScriptEngine class provided by the Java API allows us to execute JavaScript code and functions in Java. By leveraging the power of both languages, we can create more powerful and dynamic applications.","categories":[{"name":"Backend Development","slug":"Backend-Development","permalink":"https://czqu.net/categories/Backend-Development/"}],"tags":[{"name":"Backend Development","slug":"Backend-Development","permalink":"https://czqu.net/tags/Backend-Development/"},{"name":"Java","slug":"Java","permalink":"https://czqu.net/tags/Java/"}],"author":"Paul Chen"},{"title":"How to make braised pork trotters","slug":"release/how-to-make-braised-pork-trotters","date":"2023-03-12T09:18:00.000Z","updated":"2023-03-12T09:18:00.000Z","comments":true,"path":"posts/1037676127/","permalink":"https://czqu.net/posts/1037676127/","excerpt":"","text":"Braised pork trotters are a beloved dish in many Asian cuisines. It’s a rich, flavorful, and comforting dish that’s perfect for cold days or for any occasion. In this recipe, we’ll go through the steps of making a simple and delicious braised pork trotters dish. Ingredients 4 pork trotters 10g ginger slices 50ml Shaoxing wine 50ml light soy sauce 25ml dark soy sauce 20g rock sugar 2 star anise 1 piece cinnamon bark 2 bay leaves Salt to taste Water Instructions Clean the pork trotters: Rinse the pork trotters under cold water to remove any dirt or debris. Then, blanch the trotters in boiling water for a few minutes to get rid of any impurities. After that, rinse the trotters under cold water again. Boil the pork trotters: In a large pot, add the pork trotters, ginger slices, and Shaoxing wine. Cover the trotters with enough water and bring it to a boil over high heat. Once the water boils, reduce the heat to low and let the pork trotters simmer for 10 minutes. Skim off any foam that rises to the surface. Add the seasoning: Add the light soy sauce, dark soy sauce, rock sugar, star anise, cinnamon bark, and bay leaves. Stir the ingredients to combine, and bring the mixture to a boil again. Simmer the pork trotters: Once the mixture boils, reduce the heat to low and let the pork trotters simmer for 2 hours, or until the meat is tender and falls off the bone. Add salt to taste. Let the pork trotters cool: Turn off the heat and let the pork trotters cool in the pot. This will help them absorb more flavor. Serve: Once the pork trotters are cool, remove them from the pot and place them on a plate. You can serve them with steamed rice or your favorite vegetables. Tips for Making Braised Pork Trotters For a richer and thicker sauce, you can add cornstarch or potato starch to the sauce. You can also add other ingredients like garlic, scallions, or dried mushrooms to the pot for additional flavor. If you don’t have Shaoxing wine, you can substitute it with dry sherry or rice wine. ConclusionBraised pork trotters are a classic dish that’s hearty, flavorful, and easy to make. This dish is perfect for any occasion, and it’s sure to impress your family and friends. Follow this recipe and enjoy a delicious and satisfying meal!","categories":[{"name":"Recipe","slug":"Recipe","permalink":"https://czqu.net/categories/Recipe/"}],"tags":[{"name":"Life","slug":"Life","permalink":"https://czqu.net/tags/Life/"},{"name":"Recipe","slug":"Recipe","permalink":"https://czqu.net/tags/Recipe/"}]},{"title":"How to Retrieve User Addresses in a Spring Boot Application","slug":"release/get-ip-from-request","date":"2023-03-04T12:14:00.000Z","updated":"2023-03-04T12:14:00.000Z","comments":true,"path":"posts/1268933518/","permalink":"https://czqu.net/posts/1268933518/","excerpt":"","text":"When building a web application, it’s often necessary to retrieve the IP address of the user who is accessing the application. This information can be useful for various purposes, such as security, analytics, and customization. In this tutorial, we will explore how to retrieve both IPv4 and IPv6 addresses of a user in a Spring Boot application. Retrieving User IP AddressIn Spring Boot, we can retrieve the IP address of a user by injecting a HttpServletRequest object into our controller class and calling its getRemoteAddr() method. For example: 12345678910111213@RestControllerpublic class UserController { @Autowired private HttpServletRequest request; @GetMapping(\"/user/ip\") public String getUserIP() { String ipAddress = request.getRemoteAddr(); return ipAddress; }} In the above code, we have injected a HttpServletRequest object using the @Autowired annotation and defined a getUserIP() method that returns the IP address of the user. The getRemoteAddr() method of the HttpServletRequest object returns the IP address of the client or the last proxy that sent the request. However, this method may not always return the correct IP address. In some cases, the IP address may be the address of a proxy server or load balancer rather than the actual user’s IP address. To obtain the correct IP address, we can check for the X-Forwarded-For header, which is a standard header used by proxies to indicate the originating IP address of a client connecting to a web server through the proxy. Here’s an updated version of the code that checks for the X-Forwarded-For header: 12345678910111213141516@RestControllerpublic class UserController { @Autowired private HttpServletRequest request; @GetMapping(\"/user/ip\") public String getUserIP() { String ipAddress = request.getHeader(\"X-Forwarded-For\"); if (ipAddress == null || ipAddress.isEmpty() || \"unknown\".equalsIgnoreCase(ipAddress)) { ipAddress = request.getRemoteAddr(); } return ipAddress; }} In the above code, we first check for the X-Forwarded-For header using the getHeader() method of the HttpServletRequest object. If the header is not present or its value is empty or “unknown”, we fall back to the getRemoteAddr() method to obtain the IP address.","categories":[{"name":"Backend Development","slug":"Backend-Development","permalink":"https://czqu.net/categories/Backend-Development/"}],"tags":[{"name":"Backend Development","slug":"Backend-Development","permalink":"https://czqu.net/tags/Backend-Development/"}],"author":"Paul Chen"},{"title":"Java Thread Context: How to Determine Whether You're in a Request Context","slug":"release/Java-Thread-Context-Request-Context","date":"2023-03-04T11:14:00.000Z","updated":"2023-03-04T11:14:00.000Z","comments":true,"path":"posts/2685105031/","permalink":"https://czqu.net/posts/2685105031/","excerpt":"","text":"IntroductionWhen developing Java web applications, it is often necessary to check whether the current thread is in a request context. A request context is a context that holds information about a single HTTP request and is typically used in web applications. In this blog post, we will explore how to determine whether the current thread is in a request context using Spring Framework’s RequestContextHolder class. The RequestContextHolder ClassThe RequestContextHolder class is a utility class provided by Spring Framework that allows you to bind the current HTTP request and response to the current thread. It provides access to the current request and response objects and allows you to access request attributes. Checking if the Current Thread is in a Request ContextTo check if the current thread is in a request context, we can use the RequestContextHolder.getRequestAttributes() method. This method returns the current request attributes associated with the current thread. If there are no request attributes associated with the current thread, it means that the current thread is not in a request context. Here’s an example implementation of a RequestContextChecker class that uses RequestContextHolder to check if the current thread is in a request context: 12345678910import org.springframework.web.context.request.RequestAttributes;import org.springframework.web.context.request.RequestContextHolder;public class RequestContextChecker { public static boolean isCurrentThreadInRequestContext() { RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes(); return requestAttributes != null; }} In the code above, the isCurrentThreadInRequestContext() method calls RequestContextHolder.getRequestAttributes() to get the request attributes associated with the current thread. If there are request attributes associated with the current thread, the method returns true. Otherwise, it returns false. ConclusionIn this post, we’ve seen how to check if the current thread is in a request context using Spring Framework’s RequestContextHolder class. By using RequestContextHolder.getRequestAttributes(), we can determine if the current thread is in a request context and take appropriate actions based on the result. It’s important to note that this method is only applicable to web applications that use Spring Framework. For other types of request contexts, you may need to use a different method to determine if the current thread is in a request context.","categories":[{"name":"Backend Development","slug":"Backend-Development","permalink":"https://czqu.net/categories/Backend-Development/"}],"tags":[{"name":"Backend Development","slug":"Backend-Development","permalink":"https://czqu.net/tags/Backend-Development/"},{"name":"Trap","slug":"Trap","permalink":"https://czqu.net/tags/Trap/"}],"author":"Paul Chen"},{"title":"Wireshark Basic Usage","slug":"release/2020-4-1-basic use of wireshark","date":"2023-03-04T00:56:00.000Z","updated":"2023-03-04T00:56:00.000Z","comments":true,"path":"posts/20069/","permalink":"https://czqu.net/posts/20069/","excerpt":"","text":"一、IntroductionWireshark is currently one of the most widely used network packet analysis software in the world. The function of network packet analysis software is to listen to network packets and display the most detailed network packet information as much as possible. Wireshark uses Winpcap as the interface to directly exchange data packets with the network card. The following figure shows the initial interface after successfully installing Winpcap and Wireshark: In the initial interface of Wireshark, the fluctuating line represents the fluctuation of the information transmitted by the network card. Click the start icon in the upper left corner to enter the packet capture page shown in the following figure: 二、Packet Capture and AnalysisThis example demonstrates packet capture using the curl and ping commands.Start capturing with Wireshark, and then, as shown in the following figure, use the curl and ping commands in the terminal to interact with the target address: ​ From the response packets of ping, we can see that we received 7 response packets. The IP address of Baidu here is 14.215.177.39. Returning to Wireshark, filter the packets by IP address in the filter, as shown in the following figure is the result of filtering the packets. The filter command is: 1ip.addr ==14.215.177.39 1.TCP Three-Way Handshake AnalysisViewing the packets, in the above figure, packets 1-3 are using the TCP protocol, and packet 4 is using the HTTP protocol, which is a clear sign of the TCP three-way handshake. The first three packets are the process of the TCP three-way handshake. The following figure shows the detailed packet contents of the TCP three-way handshake, which can be compared with the packet flag bits of the TCP three-way handshake. 2.ICMP Protocol AnalysisThe ping command belongs to the ICMP protocol. Viewing the ICMP packets in the filtered packets, we can observe 14 packets. As mentioned earlier, 7 response packets were received for the ping destination address. ICMP packets have two modes: request and response. See the following figure for details:： The ICMP Request and Reply message formats are as follows: Request： Reply： Type indicates the type of ICMP message, 8 for request messages and 0 for reply messages; Code = 0; CheckSum is the checksum from the ICMP header (starting with Type) to the end of the data (ending with the entire packet); Identifier is the identifier set by the host, usually set to the process ID. The identifier in the response message is the same as the identifier in the original message; Sequence Number is the sequence number set by the host, usually set to an increasing sequence starting from 0. The sequence number in the response message is the same as the sequence number in the original message; Data is the data set by the host. The data in the response message is the same as the data in the original message; Note: The Identifier and Sequence Number fields are divided into [BE] and [LE]. [BE] is for Linux content, and [LE] is for Windows content. Since this experiment was conducted in a Linux environment, only the [BE] content needs to be viewed. Request Message Header ： Reply Message Header： 三、Introduction to Wireshark filtersOne of the core features of Wireshark is the use of filters. There are three states for display filters: red, yellow, and green. Red means that the display filter expression is incorrect, yellow means that the filter expression can filter packets but may result in unpredictable results, and green means that the filter expression is correct. Wireshark filters are divided into two types: display filters and capture filters. Display filters filter captured packets based on filtering rules, while capture filters only capture packets that meet the filtering rules that have been set in advance. Capture Filter： As shown in the following figure is the capture filter settings. ： The reason for setting a capture filter is to target situations where the network traffic is very large, such as several gigabytes per second, and most of the traffic is not the data that the analyst is interested in. In this case, a capture filter can be used to capture only the specified data. Useless data can not only interfere with analysis, but also waste storage space and copying time. Display filter： The following image shows the setting of a display filter ： Common syntax of display filters: Protocol filter, such as http, icmp, etc; Filter by specific port: tcp.port eq 80, displays packets with port 80 whether it is a source or destination port. To filter by the source port, use tcp.srcport eq 80, and to filter by the destination port, use tcp.dstport eq 80; Filter by source IP address: ip.src eq 192.168.1.107, and to filter by the destination, use ip.dst eq 192.168.1.107. To filter by both source and destination, use ip.addr eq 192.168.1.107. MAC address filtering follows the same logic; Filter packets containing a specific string domain name, such as http.host contains “moe”; Multiple filter conditions can be used together, for example, to simultaneously filter for http protocol and port 80, use http &amp;&amp; tcp.port == 80. Combination symbols include AND/&amp;&amp;, OR/||, and NOT/!; The syntax of capture filters is slightly different from display filters, and some examples are as follows: Filter by specific protocol: http Filter by specific port: port 80 Filter by specific IP address: host 192.168.0.115 Filter by specific domain name: host www.example.com","categories":[],"tags":[{"name":"Information Security","slug":"Information-Security","permalink":"https://czqu.net/tags/Information-Security/"}],"author":"Paul Chen"},{"title":"The issue of SSL certificate being unable to issue due to the CNAME record pointing to Vercel affecting the CAA record.","slug":"release/vercel导致的SSL证书无法签发的问题_en","date":"2023-03-04T00:14:00.000Z","updated":"2023-03-05T07:36:00.000Z","comments":true,"path":"posts/3655275721/","permalink":"https://czqu.net/posts/3655275721/","excerpt":"","text":"SolutionThe most drastic solution is to directly pause all DNS related to Vercel.Or, first pause the resolution of the second-level domain to Vercel, that is, pause example.com-&gt;Vercel,and then pause the Vercel of the affected subdomain, that is, pause a.example.com-&gt;Vercel. ProblemToday, Alibaba Cloud informed me that an SSL certificate for one of my domains was about to expire. As an experienced developer, I opened the Alibaba Cloud console to apply for a new certificate. However, something strange happened. Previously, the certificate could be issued within a minute, but this time it took a long time and it still didn’t work. I decided to take a nap and try again later. When I woke up and opened the Alibaba Cloud console, I found that it still wasn’t successful. At this point, I still suspected that it was Alibaba Cloud’s problem. So I applied again using Freessl, but it still wasn’t successful in the afternoon. The result of the test using myssl.com is as follows: Region Match China Not match (Validation failed. Your CAA configuration doesn’t allow the current CA to issue certificates for you. Please modify to: symantec.com or digicert.com) Hong Kong Not match (Validation failed. Your CAA configuration doesn’t allow the current CA to issue certificates for you. Please modify to: symantec.com or digicert.com) United States Not match (Validation failed. Your CAA configuration doesn’t allow the current CA to issue certificates for you. Please modify to: symantec.com or digicert.com) I haven’t set up any CAA records! I thought it couldn’t be a DNS cache issue, right? But I still went to the Alibaba Cloud console to temporarily stop resolving all DNS records. As a result, it actually worked! After investigation, I found that the problem was caused by the CNAME record pointing to Vercel. How could Vercel have the permission to set CAA records for me?! ReasonAfter some searching, I finally figured out the reason, which was caused by the CAA record. CAA (Certificate Authority Authorization) is a new additional field that can be added to DNS records to create CAA resource records through DNS mechanism, which can limit the connection between the domain name issuing the certificate and the CA (certificate authority). Unauthorized third parties attempting to obtain SSL/TLS certificates for the domain name through other CAs will be rejected. By setting a CAA record for the domain name, website owners can authorize specific CAs to issue certificates for their domain name, thereby preventing HTTPS certificate errors and improving website security. An additional piece of knowledge is that CNAME records can affect CAA records： CAA record checking continues for CNAME records pointing to a different domain. In this example, www.example.com points to www.example.net, which also has CAA records: 123456(Example 7 / www.example.com)Domain Record type Flags Tag Value www.example.com. CNAME www.example.netwww.example.net. CAA 0 issue \";\"(Result: CAA failed) The first record redirects the CAA check to www.example.net. This CAA record can prevent any CA from issuing a certificate, so the certificate authority cannot issue a certificate for www.example.com. If the domain being pointed to (www.example.net) does not have a CAA record, then the CAA record check will climb up to the parent domain (example.com). 123456(Example 8 / www.example.com)Domain Record type Flags Tag Value www.example.com. CNAME www.example.netexample.com. CAA 0 issue \"amazon.com\"(Result: CAA passed) In plain language, it means that because we set a CNAME record to point to Vercel, and Vercel set a CAA record, it affected our domain’s CAA record. After using a tool to check, we confirmed that this was indeed the case.： 123456789101112131415161718192021222324252627282930{ \"canIssue\": false, \"status\": \"IssueMismatch\", \"domain\": \"czqu.net\", \"queryAt\": \"Sep 30, 2021 11:21:55 AM\", \"elapsed\": 1, \"caaRecordSet\": [ { \"domain\": \"czqu.net\", \"caaRecords\": [ { \"issuerCritical\": 0, \"tag\": \"issue\", \"value\": \"letsencrypt.org\", \"type\": 257, \"dclass\": 1, \"ttl\": 60 }, { \"issuerCritical\": 0, \"tag\": \"issue\", \"value\": \"globalsign.com\", \"type\": 257, \"dclass\": 1, \"ttl\": 60 } ] } ]}","categories":[],"tags":[{"name":"Backend Development","slug":"Backend-Development","permalink":"https://czqu.net/tags/Backend-Development/"},{"name":"Trap","slug":"Trap","permalink":"https://czqu.net/tags/Trap/"}],"author":"Paul Chen"},{"title":"How to Fix Redmi Bluetooth Earphones with One-Sided Sound Issue","slug":"release/solve-the-problem-The-Redmi-Bluetooth","date":"2023-03-03T10:00:00.000Z","updated":"2023-03-03T10:00:00.000Z","comments":true,"path":"posts/56389/","permalink":"https://czqu.net/posts/56389/","excerpt":"","text":"Introduction If you’re experiencing an issue with your Bluetooth earphones where only one side has sound, you might have been searching for solutions online. Unfortunately, not all online advice is reliable. To help fellow users, I’m sharing my tested solution to this problem. Solution Unpair your earphones from your phone. With both earphones turned on, press and hold the power button for 5 seconds until they turn off. Release the button once they turn off. (Both earphones’ lights should not be on during this process. Skip this step if your earphones are already turned off.) Press and hold both earphones again. When the LED lights start flashing white, keep pressing until they flash red and white twice. (This step is crucial as it clears the previous configuration information on the earphones. Remember to unpair and turn off Bluetooth on your phone.) Turn on the right earphone first and then the left. (Make sure the earphones are inside the charging case. Taking out the right earphone will automatically turn it on, so start with the right one first.) The right earphone should start flashing quickly. When the left earphone stops flashing, the earphones are paired successfully. Pair the earphones with your phone again through the Bluetooth settings. By following these steps, you should be able to fix the one-sided sound issue on your Redmi Bluetooth earphones.","categories":[{"name":"Life Hacks","slug":"Life-Hacks","permalink":"https://czqu.net/categories/Life-Hacks/"}],"tags":[{"name":"Life Hacks","slug":"Life-Hacks","permalink":"https://czqu.net/tags/Life-Hacks/"}],"author":"coq"},{"title":"LeetCode 46. Permutations","slug":"release/leetcode-46","date":"2023-03-01T23:16:00.000Z","updated":"2023-03-01T23:16:00.000Z","comments":true,"path":"posts/3587124311/","permalink":"https://czqu.net/posts/3587124311/","excerpt":"","text":"Question:Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. Example 1: 12Input: nums = [1,2,3]Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example 2: 12Input: nums = [0,1]Output: [[0,1],[1,0]] Example 3: 12Input: nums = [1]Output: [[1]] Constraints: 1 &lt;= nums.length &lt;= 6 -10 &lt;= nums[i] &lt;= 10 All the integers of nums are unique. Solution:Given an array of distinct integers nums, return all possible permutations of its elements. You can return the answer in any order. Algorithm The problem can be solved by recursively generating all permutations of the array. For a given array nums, the algorithm works as follows: If the length of nums is 1, return a list containing nums. For each element in nums, generate all permutations of the remaining elements using recursion. This can be done by creating a new array without the current element, and calling the permutation function recursively with the new array. For each permutation generated in step 2, add the current element to the beginning of the permutation. Return the list of all permutations generated in step 3. Java Implementation Here’s the Java implementation of the algorithm: 1234567891011121314151617181920212223class Solution { public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); permute(nums, new boolean[nums.length], new ArrayList&lt;&gt;(), res); return res; } private void permute(int[] nums, boolean[] used, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res) { if (cur.size() == nums.length) { res.add(new ArrayList&lt;&gt;(cur)); return; } for (int i = 0; i &lt; nums.length; i++) { if (!used[i]) { cur.add(nums[i]); used[i] = true; permute(nums, used, cur, res); cur.remove(cur.size() - 1); used[i] = false; } } }} The permute() function takes an array nums, and returns a list of all permutations of its elements. The function uses a helper function permute() to generate the permutations recursively. The permute() function takes the following arguments: nums: the array of integers to be permuted used: a boolean array indicating which elements of nums have already been used in the current permutation cur: a list representing the current permutation being generated res: the list of all permutations generated so far Python Implementation Here’s the Python implementation of the algorithm: 12345678910class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: if len(nums) == 1: return [nums] res = [] for i in range(len(nums)): sub_res = self.permute(nums[:i] + nums[i+1:]) for j in sub_res: res.append([nums[i]] + j) return res The permute() function takes an array nums, and returns a list of all permutations of its elements. The function uses recursion to generate the permutations. The permute() function takes the following arguments: nums: the array of integers to be permuted Time Complexity The time complexity of the algorithm is O(n!), where n is the length of the input array. This is because there are n! permutations of n distinct elements, and the algorithm generates each permutation once. Space Complexity The space complexity of the algorithm is O(n^2), where n is the length of the input array. This is because the algorithm generates n! permutations, each of which has length n. The algorithm uses additional space to store the list of permutations generated so far.","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://czqu.net/categories/LeetCode/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://czqu.net/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://czqu.net/tags/LeetCode/"}]},{"title":"Solutions to exercises and projects in the textbook C Programming: A Modern Approach, 2nd Edition","slug":"release/C-Programming-A-Modern-Approach-key","date":"2020-11-13T12:46:33.000Z","updated":"2020-11-13T12:46:33.000Z","comments":true,"path":"posts/28638/","permalink":"https://czqu.net/posts/28638/","excerpt":"","text":"Chapter 2Answers to Selected Exercises2. [was #2] (a) The program contains one directive (#include) and four statements (three calls of printf and one return). (b) 123Parkinson's Law:Work expands so as to fill the timeavailable for its completion. 3. [was #4] 1234567891011121314#include &lt;stdio.h&gt; int main(void){ int height = 8, length = 12, width = 10, volume; volume = height * length * width; printf(\"Dimensions: %dx%dx%d\\n\", length, width, height); printf(\"Volume (cubic inches): %d\\n\", volume); printf(\"Dimensional weight (pounds): %d\\n\", (volume + 165) / 166); return 0;} 4. [was #6] Here’s one possible program: 1234567891011121314151617#include &lt;stdio.h&gt; int main(void){ int i, j, k; float x, y, z; printf(\"Value of i: %d\\n\", i); printf(\"Value of j: %d\\n\", j); printf(\"Value of k: %d\\n\", k); printf(\"Value of x: %g\\n\", x); printf(\"Value of y: %g\\n\", y); printf(\"Value of z: %g\\n\", z); return 0;} When compiled using GCC and then executed, this program produced the following output: 123456Value of i: 5618848Value of j: 0Value of k: 6844404Value of x: 3.98979e-34Value of y: 9.59105e-39Value of z: 9.59105e-39 The values printed depend on many factors, so the chance that you’ll get exactly these numbers is small. 5. [was #10] (a) is not legal because 100_bottles begins with a digit. 8. [was #12] There are 14 tokens: a, =, (, 3, *, q, -, p, *, p, ), /, 3, and ;. Answers to Selected Programming Projects4. [was #8; modified] 12345678910111213#include &lt;stdio.h&gt; int main(void){ float original_amount, amount_with_tax; printf(\"Enter an amount: \"); scanf(\"%f\", &amp;original_amount); amount_with_tax = original_amount * 1.05f; printf(\"With tax added: $%.2f\\n\", amount_with_tax); return 0;} The amount_with_tax variable is unnecessary. If we remove it, the program is slightly shorter: 123456789101112#include &lt;stdio.h&gt; int main(void){ float original_amount; printf(\"Enter an amount: \"); scanf(\"%f\", &amp;original_amount); printf(\"With tax added: $%.2f\\n\", original_amount * 1.05f); return 0;} Chapter 3 Answers to Selected Exercises 2. [was #2] (a) printf(“%-8.1e”, x); (b) printf(“%10.6e”, x); (c) printf(“%-8.3f”, x); (d) printf(“%6.0f”, x); 5. [was #8] The values of x, i, and y will be 12.3, 45, and .6, respectively. Answers to Selected Programming Projects 1. [was #4; modified] #include &lt;stdio.h&gt; int main(void) { int month, day, year; printf(“Enter a date (mm/dd/yyyy): “); scanf(“%d/%d/%d”, &amp;month, &amp;day, &amp;year); printf(“You entered the date %d%.2d%.2d\\n”, year, month, day); return 0; } 3. [was #6; modified] #include &lt;stdio.h&gt; int main(void) { int prefix, group, publisher, item, check_digit; printf(“Enter ISBN: “); scanf(“%d-%d-%d-%d-%d”, &amp;prefix, &amp;group, &amp;publisher, &amp;item, &amp;check_digit); printf(“GS1 prefix: %d\\n”, prefix); printf(“Group identifier: %d\\n”, group); printf(“Publisher code: %d\\n”, publisher); printf(“Item number: %d\\n”, item); printf(“Check digit: %d\\n”, check_digit); /* The five printf calls can be combined as follows: printf(“GS1 prefix: %d\\nGroup identifier: %d\\nPublisher code: %d\\nItem number: %d\\nCheck digit: %d\\n”, ​ prefix, group, publisher, item, check_digit); */ return 0; } Chapter 4 Answers to Selected Exercises 2. [was #2] Not in C89. Suppose that i is 9 and j is 7. The value of (-i)/j could be either –1 or –2, depending on the implementation. On the other hand, the value of -(i/j) is always –1, regardless of the implementation. In C99, on the other hand, the value of (-i)/j must be equal to the value of -(i/j). 9. [was #6] (a) 63 8 (b) 3 2 1 (c) 2 -1 3 (d) 0 0 0 13. [was #8] The expression ++i is equivalent to (i += 1). The value of both expressions is i after the increment has been performed. Answers to Selected Programming Projects 2. [was #4] #include &lt;stdio.h&gt; int main(void) { int n; printf(“Enter a three-digit number: “); scanf(“%d”, &amp;n); printf(“The reversal is: %d%d%d\\n”, n % 10, (n / 10) % 10, n / 100); return 0; } Chapter 5 Answers to Selected Exercises 2. [was #2] (a) 1 (b) 1 (c) 1 (d) 1 4. [was #4] (i &gt; j) - (i &lt; j) 6. [was #12] Yes, the statement is legal. When n is equal to 5, it does nothing, since 5 is not equal to –9. 10. [was #16] The output is onetwo since there are no break statements after the cases. Answers to Selected Programming Projects 2. [was #6] #include &lt;stdio.h&gt; int main(void) { int hours, minutes; printf(“Enter a 24-hour time: “); scanf(“%d:%d”, &amp;hours, &amp;minutes); printf(“Equivalent 12-hour time: “); if (hours == 0) printf(“12:%.2d AM\\n”, minutes); else if (hours &lt; 12) printf(“%d:%.2d AM\\n”, hours, minutes); else if (hours == 12) printf(“%d:%.2d PM\\n”, hours, minutes); else printf(“%d:%.2d PM\\n”, hours - 12, minutes); return 0; } 4. [was #8; modified] #include &lt;stdio.h&gt; int main(void) { int speed; printf(“Enter a wind speed in knots: “); scanf(“%d”, &amp;speed); if (speed &lt; 1) printf(“Calm\\n”); else if (speed &lt;= 3) printf(“Light air\\n”); else if (speed &lt;= 27) printf(“Breeze\\n”); else if (speed &lt;= 47) printf(“Gale\\n”); else if (speed &lt;= 63) printf(“Storm\\n”); else printf(“Hurricane\\n”); return 0; } 6. [was #10] #include &lt;stdio.h&gt; int main(void) { int check_digit, d, i1, i2, i3, i4, i5, j1, j2, j3, j4, j5, first_sum, second_sum, total; printf(“Enter the first (single) digit: “); scanf(“%1d”, &amp;d); printf(“Enter first group of five digits: “); scanf(“%1d%1d%1d%1d%1d”, &amp;i1, &amp;i2, &amp;i3, &amp;i4, &amp;i5); printf(“Enter second group of five digits: “); scanf(“%1d%1d%1d%1d%1d”, &amp;j1, &amp;j2, &amp;j3, &amp;j4, &amp;j5); printf(“Enter the last (single) digit: “); scanf(“%1d”, &amp;check_digit); first_sum = d + i2 + i4 + j1 + j3 + j5; second_sum = i1 + i3 + i5 + j2 + j4; total = 3 * first_sum + second_sum; if (check_digit == 9 - ((total - 1) % 10)) printf(“VALID\\n”); else printf(“NOT VALID\\n”); return 0; } 10. [was #14] #include &lt;stdio.h&gt; int main(void) { int grade; printf(“Enter numerical grade: “); scanf(“%d”, &amp;grade); if (grade &lt; 0 || grade &gt; 100) { printf(“Illegal grade\\n”); return 0; } switch (grade / 10) { case 10: case 9: printf(“Letter grade: A\\n”); ​ break; case 8: printf(“Letter grade: B\\n”); ​ break; case 7: printf(“Letter grade: C\\n”); ​ break; case 6: printf(“Letter grade: D\\n”); ​ break; case 5: case 4: case 3: case 2: case 1: case 0: printf(“Letter grade: F\\n”); ​ break; } return 0; } Chapter 6Answers to Selected Exercises4. [was #10] (c) is not equivalent to (a) and (b), because i is incremented before the loop body is executed. 10. [was #12] Consider the following while loop: 12345while (…) { … continue; …} The equivalent code using goto would have the following appearance: 123456while (…) { … goto loop_end; … loop_end: ; /* null statement */} 12. [was #14] 123for (d = 2; d * d &lt;= n; d++) if (n % d == 0) break; The if statement that follows the loop will need to be modified as well: 1234if (d * d &lt;= n) printf(\"%d is divisible by %d\\n\", n, d);else printf(\"%d is prime\\n\", n); 14. [was #16] The problem is the semicolon at the end of the first line. If we remove it, the statement is now correct: 12if (n % 2 == 0) printf(\"n is even\\n\"); Answers to Selected Programming Projects2. [was #2] 12345678910111213141516171819#include &lt;stdio.h&gt; int main(void){ int m, n, remainder; printf(\"Enter two integers: \"); scanf(\"%d%d\", &amp;m, &amp;n); while (n != 0) { remainder = m % n; m = n; n = remainder; } printf(\"Greatest common divisor: %d\\n\", m); return 0;} 4. [was #4] 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt; int main(void){ float commission, value; printf(\"Enter value of trade: \"); scanf(\"%f\", &amp;value); while (value != 0.0f) { if (value &lt; 2500.00f) commission = 30.00f + .017f * value; else if (value &lt; 6250.00f) commission = 56.00f + .0066f * value; else if (value &lt; 20000.00f) commission = 76.00f + .0034f * value; else if (value &lt; 50000.00f) commission = 100.00f + .0022f * value; else if (value &lt; 500000.00f) commission = 155.00f + .0011f * value; else commission = 255.00f + .0009f * value; if (commission &lt; 39.00f) commission = 39.00f; printf(\"Commission: $%.2f\\n\\n\", commission); printf(\"Enter value of trade: \"); scanf(\"%f\", &amp;value); } return 0;} 6. [was #6] 1234567891011121314#include &lt;stdio.h&gt; int main(void){ int i, n; printf(\"Enter limit on maximum square: \"); scanf(\"%d\", &amp;n); for (i = 2; i * i &lt;= n; i += 2) printf(\"%d\\n\", i * i); return 0;} 8. [was #8] 123456789101112131415161718192021222324#include &lt;stdio.h&gt; int main(void){ int i, n, start_day; printf(\"Enter number of days in month: \"); scanf(\"%d\", &amp;n); printf(\"Enter starting day of the week (1=Sun, 7=Sat): \"); scanf(\"%d\", &amp;start_day); /* print any leading \"blank dates\" */ for (i = 1; i &lt; start_day; i++) printf(\" \"); /* now print the calendar */ for (i = 1; i &lt;= n; i++) { printf(\"%3d\", i); if ((start_day + i - 1) % 7 == 0) printf(\"\\n\"); } return 0;} Chapter 7Answers to Selected Exercises3. [was #4] (b) is not legal. 4. [was #6] (d) is illegal, since printf requires a string, not a character, as its first argument. 10. [was #14] unsigned int, because the (int) cast applies only to j, not j * k. 12. [was #16] The value of i is converted to float and added to f, then the result is converted to double and stored in d. 14. [was #18] No. Converting f to int will fail if the value stored in f exceeds the largest value of type int. Answers to Selected Programming Projects1. [was #2] short int values are usually stored in 16 bits, causing failure at 182. int and long int values are usually stored in 32 bits, with failure occurring at 46341. 2. [was #8] 123456789101112131415161718192021222324#include &lt;stdio.h&gt; int main(void){ int i, n; char ch; printf(\"This program prints a table of squares.\\n\"); printf(\"Enter number of entries in table: \"); scanf(\"%d\", &amp;n); ch = getchar(); /* dispose of new-line character following number of entries */ /* could simply be getchar(); */ for (i = 1; i &lt;= n; i++) { printf(\"%10d%10d\\n\", i, i * i); if (i % 24 == 0) { printf(\"Press Enter to continue...\"); ch = getchar(); /* or simply getchar(); */ } } return 0;} 5. [was #10] 1234567891011121314151617181920212223242526272829303132#include &lt;ctype.h&gt;#include &lt;stdio.h&gt; int main(void){ int sum = 0; char ch; printf(\"Enter a word: \"); while ((ch = getchar()) != '\\n') switch (toupper(ch)) { case 'D': case 'G': sum += 2; break; case 'B': case 'C': case 'M': case 'P': sum += 3; break; case 'F': case 'H': case 'V': case 'W': case 'Y': sum += 4; break; case 'K': sum += 5; break; case 'J': case 'X': sum += 8; break; case 'Q': case 'Z': sum += 10; break; default: sum++; break; } printf(\"Scrabble value: %d\\n\", sum); return 0;} 6. [was #12] 12345678910111213#include &lt;stdio.h&gt; int main(void){ printf(\"Size of int: %d\\n\", (int) sizeof(int)); printf(\"Size of short: %d\\n\", (int) sizeof(short)); printf(\"Size of long: %d\\n\", (int) sizeof(long)); printf(\"Size of float: %d\\n\", (int) sizeof(float)); printf(\"Size of double: %d\\n\", (int) sizeof(double)); printf(\"Size of long double: %d\\n\", (int) sizeof(long double)); return 0;} Since the type of a sizeof expression may vary from one implementation to another, it’s necessary in C89 to cast sizeof expressions to a known type before printing them. The sizes of the basic types are small numbers, so it’s safe to cast them to int. (In general, however, it’s best to cast sizeof expressions to unsigned long and print them using %lu.) In C99, we can avoid the cast by using the %zu conversion specification. Chapter 8Answers to Selected Exercises1. [was #4] The problem with sizeof(a) / sizeof(t) is that it can’t easily be checked for correctness by someone reading the program. (The reader would have to locate the declaration of a and make sure that its elements have type t.) 2. [was #8] To use a digit d (in character form) as a subscript into the array a, we would write a[d-'0']. This assumes that digits have consecutive codes in the underlying character set, which is true of ASCII and other popular character sets. 7. [was #10] 12345678910const int segments[10][7] = {{1, 1, 1, 1, 1, 1}, {0, 1, 1}, {1, 1, 0, 1, 1, 0, 1}, {1, 1, 1, 1, 0, 0, 1}, {0, 1, 1, 0, 0, 1, 1}, {1, 0, 1, 1, 0, 1, 1}, {1, 0, 1, 1, 1, 1, 1}, {1, 1, 1}, {1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 0, 1, 1}}; Answers to Selected Programming Projects2. [was #2] 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt; int main(void){ int digit_count[10] = {0}; int digit; long n; printf(\"Enter a number: \"); scanf(\"%ld\", &amp;n); while (n &gt; 0) { digit = n % 10; digit_count[digit]++; n /= 10; } printf (\"Digit: \"); for (digit = 0; digit &lt;= 9; digit++) printf(\"%3d\", digit); printf(\"\\nOccurrences:\"); for (digit = 0; digit &lt;= 9; digit++) printf(\"%3d\", digit_count[digit]); printf(\"\\n\"); return 0;} 5. [was #6] 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt; #define NUM_RATES ((int) (sizeof(value) / sizeof(value[0])))#define INITIAL_BALANCE 100.00 int main(void){ int i, low_rate, month, num_years, year; double value[5]; printf(\"Enter interest rate: \"); scanf(\"%d\", &amp;low_rate); printf(\"Enter number of years: \"); scanf(\"%d\", &amp;num_years); printf(\"\\nYears\"); for (i = 0; i &lt; NUM_RATES; i++) { printf(\"%6d%%\", low_rate + i); value[i] = INITIAL_BALANCE; } printf(\"\\n\"); for (year = 1; year &lt;= num_years; year++) { printf(\"%3d \", year); for (i = 0; i &lt; NUM_RATES; i++) { for (month = 1; month &lt;= 12; month++) value[i] += ((double) (low_rate + i) / 12) / 100.0 * value[i]; printf(\"%7.2f\", value[i]); } printf(\"\\n\"); } return 0;} 8. [was #12] 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt; #define NUM_QUIZZES 5#define NUM_STUDENTS 5 int main(void){ int grades[NUM_STUDENTS][NUM_QUIZZES]; int high, low, quiz, student, total; for (student = 0; student &lt; NUM_STUDENTS; student++) { printf(\"Enter grades for student %d: \", student + 1); for (quiz = 0; quiz &lt; NUM_QUIZZES; quiz++) scanf(\"%d\", &amp;grades[student][quiz]); } printf(\"\\nStudent Total Average\\n\"); for (student = 0; student &lt; NUM_STUDENTS; student++) { printf(\"%4d \", student + 1); total = 0; for (quiz = 0; quiz &lt; NUM_QUIZZES; quiz++) total += grades[student][quiz]; printf(\"%3d %3d\\n\", total, total / NUM_QUIZZES); } printf(\"\\nQuiz Average High Low\\n\"); for (quiz = 0; quiz &lt; NUM_QUIZZES; quiz++) { printf(\"%3d \", quiz + 1); total = 0; high = 0; low = 100; for (student = 0; student &lt; NUM_STUDENTS; student++) { total += grades[student][quiz]; if (grades[student][quiz] &gt; high) high = grades[student][quiz]; if (grades[student][quiz] &lt; low) low = grades[student][quiz]; } printf(\"%3d %3d %3d\\n\", total / NUM_STUDENTS, high, low); } return 0;} Chapter 9Answers to Selected Exercises2. [was #2] 1234int check(int x, int y, int n){ return (x &gt;= 0 &amp;&amp; x &lt;= n - 1 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= n - 1);} 4. [was #4] 1234567891011121314int day_of_year(int month, int day, int year){ int num_days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; int day_count = 0, i; for (i = 1; i &lt; month; i++) day_count += num_days[i-1]; /* adjust for leap years, assuming they are divisible by 4 */ if (year % 4 == 0 &amp;&amp; month &gt; 2) day_count++; return day_count + day;} Using the expression year % 4 == 0 to test for leap years is not completely correct. Centuries are special cases: if a year is a multiple of 100, then it must also be a multiple of 400 in order to be a leap year. The correct test is 1year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0) 6. [was #6; modified] 123456789int digit(int n, int k){ int i; for (i = 1; i &lt; k; i++) n /= 10; return n % 10;} 8. [was #8] (a) and (b) are valid prototypes. (c) is illegal, since it doesn’t specify the type of the parameter. (d) incorrectly specifies that f returns an int value in C89; in C99, omitting the return type is illegal. 10. [was #10] (a) 12345678910int largest(int a[], int n){ int i, max = a[0]; for (i = 1; i &lt; n; i++) if (a[i] &gt; max) max = a[i]; return max;} (b) 123456789int average(int a[], int n){ int i, avg = 0; for (i = 0; i &lt; n; i++) avg += a[i]; return avg / n;} (c) 12345678910int num_positive(int a[], int n){ int i, count = 0; for (i = 0; i &lt; n; i++) if (a[i] &gt; 0) count++; return count;} 15. [was #12; modified] 12345678910111213141516double median(double x, double y, double z){ double result; if (x &lt;= y) if (y &lt;= z) result = y; else if (x &lt;= z) result = z; else result = x; else { if (z &lt;= y) result = y; else if (x &lt;= z) result = x; else result = z; } return result;} 17. [was #14] 123456789int fact(int n){ int i, result = 1; for (i = 2; i &lt;= n; i++) result *= i; return result;} 19. [was #16] The following program tests the pb function: 12345678910111213141516171819202122232425#include &lt;stdio.h&gt; void pb(int n); int main(void){ int n; printf(\"Enter a number: \"); scanf(\"%d\", &amp;n); printf(\"Output of pb: \"); pb(n); printf(\"\\n\"); return 0;} void pb(int n){ if (n != 0) { pb(n / 2); putchar('0' + n % 2); }} pb prints the binary representation of the argument n, assuming that n is greater than 0. (We also assume that digits have consecutive codes in the underlying character set.) For example: 12Enter a number: 53Output of pb: 110101 A trace of pb‘s execution would look like this: pb(53) finds that 53 is not equal to 0, so it calls pb(26), which finds that 26 is not equal to 0, so it calls pb(13), which finds that 13 is not equal to 0, so it calls pb(6), which finds that 6 is not equal to 0, so it calls pb(3), which finds that 3 is not equal to 0, so it calls pb(1), which finds that 1 is not equal to 0, so it calls pb(0), which finds that 0 is equal to 0, so it returns, causing pb(1) to print 1 and return, causing pb(3) to print 1 and return, causing pb(6) to print 0 and return, causing pb(13) to print 1 and return, causing pb(26) to print 0 and return, causing pb(53) to print 1 and return. Chapter 10Answers to Selected Exercises1. [was #2] (a) a, b, and c are visible. (b) a, and d are visible. (c) a, d, and e are visible. (d) a and f are visible. Answers to Selected Programming Projects3. [was #4] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;stdbool.h&gt; /* C99 only */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #define NUM_CARDS 5#define RANK 0#define SUIT 1 /* external variables */int hand[NUM_CARDS][2];/* 0 1 ____ ____ 0 |____|____| 1 |____|____| 2 |____|____| 3 |____|____| 4 |____|____| rank suit*/ bool straight, flush, four, three;int pairs; /* can be 0, 1, or 2 */ /* prototypes */void read_cards(void);void analyze_hand(void);void print_result(void); /********************************************************** * main: Calls read_cards, analyze_hand, and print_result * * repeatedly. * **********************************************************/int main(void){ for (;;) { read_cards(); analyze_hand(); print_result(); }} /********************************************************** * read_cards: Reads the cards into the external variable * * hand; checks for bad cards and duplicate * * cards. * **********************************************************/void read_cards(void){ char ch, rank_ch, suit_ch; int i, rank, suit; bool bad_card, duplicate_card; int cards_read = 0; while (cards_read &lt; NUM_CARDS) { bad_card = false; printf(\"Enter a card: \"); rank_ch = getchar(); switch (rank_ch) { case '0': exit(EXIT_SUCCESS); case '2': rank = 0; break; case '3': rank = 1; break; case '4': rank = 2; break; case '5': rank = 3; break; case '6': rank = 4; break; case '7': rank = 5; break; case '8': rank = 6; break; case '9': rank = 7; break; case 't': case 'T': rank = 8; break; case 'j': case 'J': rank = 9; break; case 'q': case 'Q': rank = 10; break; case 'k': case 'K': rank = 11; break; case 'a': case 'A': rank = 12; break; default: bad_card = true; } suit_ch = getchar(); switch (suit_ch) { case 'c': case 'C': suit = 0; break; case 'd': case 'D': suit = 1; break; case 'h': case 'H': suit = 2; break; case 's': case 'S': suit = 3; break; default: bad_card = true; } while ((ch = getchar()) != '\\n') if (ch != ' ') bad_card = true; if (bad_card) { printf(\"Bad card; ignored.\\n\"); continue; } duplicate_card = false; for (i = 0; i &lt; cards_read; i++) if (hand[i][RANK] == rank &amp;&amp; hand[i][SUIT] == suit) { printf(\"Duplicate card; ignored.\\n\"); duplicate_card = true; break; } if (!duplicate_card) { hand[cards_read][RANK] = rank; hand[cards_read][SUIT] = suit; cards_read++; } }} /********************************************************** * analyze_hand: Determines whether the hand contains a * * straight, a flush, four-of-a-kind, * * and/or three-of-a-kind; determines the * * number of pairs; stores the results into * * the external variables straight, flush, * * four, three, and pairs. * **********************************************************/void analyze_hand(void){ int rank, suit, card, pass, run; straight = true; flush = true; four = false; three = false; pairs = 0; /* sort cards by rank */ for (pass = 1; pass &lt; NUM_CARDS; pass++) for (card = 0; card &lt; NUM_CARDS - pass; card++) { rank = hand[card][RANK]; suit = hand[card][SUIT]; if (hand[card+1][RANK] &lt; rank) { hand[card][RANK] = hand[card+1][RANK]; hand[card][SUIT] = hand[card+1][SUIT]; hand[card+1][RANK] = rank; hand[card+1][SUIT] = suit; } } /* check for flush */ suit = hand[0][SUIT]; for (card = 1; card &lt; NUM_CARDS; card++) if (hand[card][SUIT] != suit) flush = false; /* check for straight */ for (card = 0; card &lt; NUM_CARDS - 1; card++) if (hand[card][RANK] + 1 != hand[card+1][RANK]) straight = false; /* check for 4-of-a-kind, 3-of-a-kind, and pairs by looking for \"runs\" of cards with identical ranks */ card = 0; while (card &lt; NUM_CARDS) { rank = hand[card][RANK]; run = 0; do { run++; card++; } while (card &lt; NUM_CARDS &amp;&amp; hand[card][RANK] == rank); switch (run) { case 2: pairs++; break; case 3: three = true; break; case 4: four = true; break; } }} /********************************************************** * print_result: Prints the classification of the hand, * * based on the values of the external * * variables straight, flush, four, three, * * and pairs. * **********************************************************/void print_result(void){ if (straight &amp;&amp; flush) printf(\"Straight flush\"); else if (four) printf(\"Four of a kind\"); else if (three &amp;&amp; pairs == 1) printf(\"Full house\"); else if (flush) printf(\"Flush\"); else if (straight) printf(\"Straight\"); else if (three) printf(\"Three of a kind\"); else if (pairs == 2) printf(\"Two pairs\"); else if (pairs == 1) printf(\"Pair\"); else printf(\"High card\"); printf(\"\\n\\n\");} 5. [was #6] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;stdbool.h&gt; /* C99 only */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #define NUM_RANKS 13#define NUM_SUITS 4#define NUM_CARDS 5 /* external variables */int num_in_rank[NUM_RANKS];int num_in_suit[NUM_SUITS];bool straight, flush, four, three;int pairs; /* can be 0, 1, or 2 */ /* prototypes */void read_cards(void);void analyze_hand(void);void print_result(void); /********************************************************** * main: Calls read_cards, analyze_hand, and print_result * * repeatedly. * **********************************************************/int main(void){ for (;;) { read_cards(); analyze_hand(); print_result(); }} /********************************************************** * read_cards: Reads the cards into the external * * variables num_in_rank and num_in_suit; * * checks for bad cards and duplicate cards. * **********************************************************/void read_cards(void){ bool card_exists[NUM_RANKS][NUM_SUITS]; char ch, rank_ch, suit_ch; int rank, suit; bool bad_card; int cards_read = 0; for (rank = 0; rank &lt; NUM_RANKS; rank++) { num_in_rank[rank] = 0; for (suit = 0; suit &lt; NUM_SUITS; suit++) card_exists[rank][suit] = false; } for (suit = 0; suit &lt; NUM_SUITS; suit++) num_in_suit[suit] = 0; while (cards_read &lt; NUM_CARDS) { bad_card = false; printf(\"Enter a card: \"); rank_ch = getchar(); switch (rank_ch) { case '0': exit(EXIT_SUCCESS); case '2': rank = 0; break; case '3': rank = 1; break; case '4': rank = 2; break; case '5': rank = 3; break; case '6': rank = 4; break; case '7': rank = 5; break; case '8': rank = 6; break; case '9': rank = 7; break; case 't': case 'T': rank = 8; break; case 'j': case 'J': rank = 9; break; case 'q': case 'Q': rank = 10; break; case 'k': case 'K': rank = 11; break; case 'a': case 'A': rank = 12; break; default: bad_card = true; } suit_ch = getchar(); switch (suit_ch) { case 'c': case 'C': suit = 0; break; case 'd': case 'D': suit = 1; break; case 'h': case 'H': suit = 2; break; case 's': case 'S': suit = 3; break; default: bad_card = true; } while ((ch = getchar()) != '\\n') if (ch != ' ') bad_card = true; if (bad_card) printf(\"Bad card; ignored.\\n\"); else if (card_exists[rank][suit]) printf(\"Duplicate card; ignored.\\n\"); else { num_in_rank[rank]++; num_in_suit[suit]++; card_exists[rank][suit] = true; cards_read++; } }} /********************************************************** * analyze_hand: Determines whether the hand contains a * * straight, a flush, four-of-a-kind, * * and/or three-of-a-kind; determines the * * number of pairs; stores the results into * * the external variables straight, flush, * * four, three, and pairs. * **********************************************************/void analyze_hand(void){ int num_consec = 0; int rank, suit; straight = false; flush = false; four = false; three = false; pairs = 0; /* check for flush */ for (suit = 0; suit &lt; NUM_SUITS; suit++) if (num_in_suit[suit] == NUM_CARDS) flush = true; /* check for straight */ rank = 0; while (num_in_rank[rank] == 0) rank++; for (; rank &lt; NUM_RANKS &amp;&amp; num_in_rank[rank] &gt; 0; rank++) num_consec++; if (num_consec == NUM_CARDS) { straight = true; return; } /* check for ace-low straight */ if (num_consec == NUM_CARDS - 1 &amp;&amp; num_in_rank[0] &gt; 0 &amp;&amp; num_in_rank[NUM_RANKS-1] &gt; 0) { straight = true; return; } /* check for 4-of-a-kind, 3-of-a-kind, and pairs */ for (rank = 0; rank &lt; NUM_RANKS; rank++) { if (num_in_rank[rank] == 4) four = true; if (num_in_rank[rank] == 3) three = true; if (num_in_rank[rank] == 2) pairs++; }} /********************************************************** * print_result: Prints the classification of the hand, * * based on the values of the external * * variables straight, flush, four, three, * * and pairs. * **********************************************************/void print_result(void){ if (straight &amp;&amp; flush) printf(\"Straight flush\"); else if (four) printf(\"Four of a kind\"); else if (three &amp;&amp; pairs == 1) printf(\"Full house\"); else if (flush) printf(\"Flush\"); else if (straight) printf(\"Straight\"); else if (three) printf(\"Three of a kind\"); else if (pairs == 2) printf(\"Two pairs\"); else if (pairs == 1) printf(\"Pair\"); else printf(\"High card\"); printf(\"\\n\\n\");} Chapter 11Answers to Selected Exercises2. [was #2] (e), (f), and (i) are legal. (a) is illegal because p is a pointer to an integer and i is an integer. (b) is illegal because *p is an integer and &amp;i is a pointer to an integer. (c) is illegal because &amp;p is a pointer to a pointer to an integer and q is a pointer to an integer. (d) is illegal for reasons similar to (c). (g) is illegal because p is a pointer to an integer and *q is an integer. (h) is illegal because *p is an integer and q is a pointer to an integer. 4. [was #4; modified] 12345678void swap(int *p, int *q){ int temp; temp = *p; *p = *q; *q = temp;} 6. [was #6] 1234567891011121314151617181920void find_two_largest(int a[], int n, int *largest, int *second_largest){ int i; if (a[0] &gt; a[1]) { *largest = a[0]; *second_largest = a[1]; } else { *largest = a[1]; *second_largest = a[0]; } for (i = 2; i &lt; n; i++) if (a[i] &gt; *largest) { *second_largest = *largest; *largest = a[i]; } else if (a[i] &gt; *second_largest) *second_largest = a[i];} Chapter 12Answers to Selected Exercises2. [was #2] The statement is illegal because pointers cannot be added. Here’s a legal statement that has the desired effect: 1middle = low + (high - low) / 2; The value of (high - low) / 2 is an integer, not a pointer, so it can legally be added to low. 4. [was #6] 12345678910111213141516int *top_ptr; void make_empty(void){ top_ptr = &amp;contents[0];} bool is_empty(void){ return top_ptr == &amp;contents[0];} bool is_full(void){ return top_ptr == &amp;contents[STACK_SIZE];} 6. [was #10; modified] 123456789int sum_array(const int a[], int n){ int *p, sum; sum = 0; for (p = a; p &lt; a + n; p++) sum += *p; return sum;} 13. [was #12; modified] 12345678910111213#define N 10 double ident[N][N], *p;int num_zeros = N; for (p = &amp;ident[0][0]; p &lt;= &amp;ident[N-1][N-1]; p++) if (num_zeros == N) { *p = 1.0; num_zeros = 0; } else { *p = 0.0; num_zeros++; } 15. [was #14] 1234int *p; for (p = temperatures[i]; p &lt; temperatures[i] + 24; p++) printf(\"%d \", *p); Answers to Selected Programming Projects1. [was #4] (a) 1234567891011121314151617181920212223#include &lt;stdio.h&gt; #define MSG_LEN 80 /* maximum length of message */ int main(void){ char msg[MSG_LEN]; int i; printf(\"Enter a message: \"); for (i = 0; i &lt; MSG_LEN; i++) { msg[i] = getchar(); if (msg[i] == '\\n') break; } printf(\"Reversal is: \"); for (i--; i &gt;= 0; i--) putchar(msg[i]); putchar('\\n'); return 0;} (b) 12345678910111213141516171819202122#include &lt;stdio.h&gt; #define MSG_LEN 80 /* maximum length of message */ int main(void){ char msg[MSG_LEN], *p; printf(\"Enter a message: \"); for (p = &amp;msg[0]; p &lt; &amp;msg[MSG_LEN]; p++) { *p = getchar(); if (*p == '\\n') break; } printf(\"Reversal is: \"); for (p--; p &gt;= &amp;msg[0]; p--) putchar(*p); putchar('\\n'); return 0;} 3. [was #8] 12345678910111213141516171819202122#include &lt;stdio.h&gt; #define MSG_LEN 80 /* maximum length of message */ int main(void){ char msg[MSG_LEN], *p; printf(\"Enter a message: \"); for (p = msg; p &lt; msg + MSG_LEN; p++) { *p = getchar(); if (*p == '\\n') break; } printf(\"Reversal is: \"); for (p--; p &gt;= msg; p--) putchar(*p); putchar('\\n'); return 0;} Chapter 13Answers to Selected Exercises2. [was #2] (a) Illegal; p is not a character. (b) Legal; output is a. (c) Legal; output is abc. (d) Illegal; *p is not a pointer. 4. [was #4] (a) 123456789101112int read_line(char str[], int n){ int ch, i = 0; while ((ch = getchar()) != '\\n') if (i == 0 &amp;&amp; isspace(ch)) ; /* ignore */ else if (i &lt; n) str[i++] = ch; str[i] = '\\0'; return i;} (b) 12345678910int read_line(char str[], int n){ int ch, i = 0; while (!isspace(ch = getchar())) if (i &lt; n) str[i++] = ch; str[i] = '\\0'; return i;} (c) 123456789101112int read_line(char str[], int n){ int ch, i = 0; do { ch = getchar(); if (i &lt; n) str[i++] = ch; } while (ch != '\\n'); str[i] = '\\0'; return i;} (d) 12345678910111213int read_line(char str[], int n){ int ch, i; for (i = 0; i &lt; n; i++) { ch = getchar(); if (ch == '\\n') break; str[i] = ch; } str[i] = '\\0'; return i;} 6. [was #6] 12345678void censor(char s[]){ int i; for (i = 0; s[i] != '\\0'; i++) if (s[i] == 'f' &amp;&amp; s[i+1] == 'o' &amp;&amp; s[i+2] =='o') s[i] = s[i+1] = s[i+2] = 'x';} Note that the short-circuit evaluation of &amp;&amp; prevents the if statement from testing characters that follow the null character. 8. [was #10] tired-or-wired? 10. [was #12] The value of q is undefined, so the call of strcpy attempts to copy the string pointed to by p into some unknown area of memory. Exercise 2 in Chapter 17 discusses how to write this function correctly. 15. [was #8] (a) 3 (b) 0 (c) The length of the longest prefix of the string s that consists entirely of characters from the string t. Or, equivalently, the position of the first character in s that is not also in t. 16. [was #16] 123456789int count_spaces(const char *s){ int count = 0; while (*s) if (*s++ == ' ') count++; return count;} Answers to Selected Programming Projects1. [was #14] 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;string.h&gt; #define WORD_LEN 20 void read_line(char str[], int n); int main(void){ char smallest_word[WORD_LEN+1], largest_word[WORD_LEN+1], current_word[WORD_LEN+1]; printf(\"Enter word: \"); read_line(current_word, WORD_LEN); strcpy(smallest_word, strcpy(largest_word, current_word)); while (strlen(current_word) != 4) { printf(\"Enter word: \"); read_line(current_word, WORD_LEN); if (strcmp(current_word, smallest_word) &lt; 0) strcpy(smallest_word, current_word); if (strcmp(current_word, largest_word) &gt; 0) strcpy(largest_word, current_word); } printf(\"\\nSmallest word: %s\\n\", smallest_word); printf(\"Largest word: %s\\n\", largest_word); return 0;} void read_line(char str[], int n){ int ch, i = 0; while ((ch = getchar()) != '\\n') if (i &lt; n) str[i++] = ch; str[i] = '\\0';} 4. [was #18] 123456789101112#include &lt;stdio.h&gt; int main(int argc, char *argv[]){ int i; for (i = argc - 1; i &gt; 0; i--) printf(\"%s \", argv[i]); printf(\"\\n\"); return 0;} 6. [was #20] 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt; #define NUM_PLANETS 9 int string_equal(const char *s, const char *t); int main(int argc, char *argv[]){ char *planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Pluto\"}; int i, j; for (i = 1; i &lt; argc; i++) { for (j = 0; j &lt; NUM_PLANETS; j++) if (string_equal(argv[i], planets[j])) { printf(\"%s is planet %d\\n\", argv[i], j + 1); break; } if (j == NUM_PLANETS) printf(\"%s is not a planet\\n\", argv[i]); } return 0;} int string_equal(const char *s, const char *t){ int i; for (i = 0; toupper(s[i]) == toupper(t[i]); i++) if (s[i] == '\\0') return 1; return 0;} Chapter 14Answers to Selected Exercises2. [was #2] #define NELEMS(a) ((int) (sizeof(a) / sizeof(a[0]))) 4. [was #4] (a) One problem stems from the lack of parentheses around the replacement list. For example, the statement 1a = 1/AVG(b, c); will be replaced by 1a = 1/(b+c)/2; Even if we add the missing parentheses, though, the macro still has problems, because it needs parentheses around x and y in the replacement list. The preprocessor will turn the statement 1a = AVG(b&lt;c, c&gt;d); into 1a = ((b&lt;c+c&gt;d)/2); which is equivalent to 1a = ((b&lt;(c+c)&gt;d)/2); Here’s the final (corrected) version of the macro: 1#define AVG(x,y) (((x)+(y))/2) (b) The problem is the lack of parentheses around the replacement list. For example, 1a = 1/AREA(b, c); becomes 1a = 1/(b)*(c); Here’s the corrected macro: 1#define AREA(x,y) ((x)*(y)) 5. [was #6] (a) The call of putchar expands into the following statement: 1putchar(('a'&lt;=(s[++i])&amp;&amp;(s[++i])&lt;='z'?(s[++i])-'a'+'A':(s[++i]))); The character a is less than or equal to s[1] (which is b), yielding a true condition. The character s[2] (which is c) is less than or equal to z, which is also true. The value printed is s[3]-'a'+'A', which is D (assuming that the character set is ASCII). (b) The character a is not less than or equal to s[1] (which is 1) so the test condition is false. The value printed is s[2], which is 2. 7. [was #8] (a) 1234long long_max(long x, long y){ return x &gt; y ? x : y;} The preprocessor would actually put all the tokens on one line, but this version is more readable. (b) The problem with types such as unsigned long is that they require two words, which prevents GENERIC_MAX from creating the desired function name. For example, GENERIC_MAX(unsigned long) would expand into 1234unsigned long unsigned long_max(unsigned long x, unsigned long y){ return x &gt; y ? x : y;} (c) To make GENERIC_MAX work with any basic type, use a type definition to rename the type: 1typedef unsigned long ULONG; We can now write GENERIC_MAX(ULONG). 12. [was #10] (c) and (e) will fail, since M is defined. 14. [was #12; modified] Here’s what the program will look like after preprocessing: 1234567891011121314151617181920212223242526272829303132Blank lineBlank lineBlank lineBlank lineBlank lineBlank lineBlank line int main(void){ int a[= 10], i, j, k, m; Blank line i = j;Blank lineBlank lineBlank line i = 10 * j+1; i = (x,y) x-y(j, k); i = ((((j)*(j)))*(((j)*(j)))); i = (((j)*(j))*(j)); i = jk; puts(\"i\" \"j\"); Blank line i = SQR(j);Blank line i = (j); return 0;} Some preprocessors delete white-space characters at the beginning of a line, so your results may vary. Three lines will cause errors when the program is compiled. Two contain syntax errors: 12int a[= 10], i, j, k, m;i = (x,y) x-y(j, k); The third refers to an undefined variable: 1i = jk; Chapter 15Answers to Selected Exercises2. [was #2] (b). Function definitions should not be put in a header file. If a function definition appears in a header file that is included by two (or more) source files, the program can’t be linked, since the linker will see two copies of the function. 6. [was #8] (a) main.c, f1.c, and f2.c. (b) f1.c (assuming that f1.h is not affected by the change). (c) main.c, f1.c, and f2.c, since all three include f1.h. (d) f1.c and f2.c, since both include f2.h. Chapter 16Answers to Selected Exercises2. [was #2; modified] (a) 123struct { double real, imaginary;} c1, c2, c3; (b) 123struct { double real, imaginary;} c1 = {0.0, 1.0}, c2 = {1.0, 0.0}, c3; (c) Only one statement is necessary: 1c1 = c2; (d) 12c3.real = c1.real + c2.real;c3.imaginary = c1.imaginary + c2.imaginary; 4. [was #4; modified] (a) 123typedef struct { double real, imaginary;} Complex; (b) Complex c1, c2, c3; (c) 12345678Complex make_complex(double real, double imaginary){ Complex c; c.real = real; c.imaginary = imaginary; return c;} (d) 12345678Complex add_complex(Complex c1, Complex c2){ Complex c3; c3.real = c1.real + c2.real; c3.imaginary = c1.imaginary + c2.imaginary; return c3;} 11. [was #10; modified] The a member will occupy 8 bytes, the union e will take 8 bytes (the largest member, c, is 8 bytes long), and the array f will require 4 bytes, so the total space allocated for s will be 20 bytes. 14. [was #12; modified] (a) 1234567double area(struct shape s){ if (s.shape_kind == RECTANGLE) return s.u.rectangle.height * s.u.rectangle.width; else return 3.14159 * s.u.circle.radius * s.u.circle.radius;} (b) 12345678struct shape move(struct shape s, int x, int y){ struct shape new_shape = s; new_shape.center.x += x; new_shape.center.y += y; return new_shape;} (c) 123456789101112struct shape scale(struct shape s, double c){ struct shape new_shape = s; if (new_shape.shape_kind == RECTANGLE) { new_shape.u.rectangle.height *= c; new_shape.u.rectangle.width *= c; } else new_shape.u.circle.radius *= c; return new_shape;} 15. [was #14] (a) enum week_days {MON, TUE, WED, THU, FRI, SAT, SUN}; (b) typedef enum {MON, TUE, WED, THU, FRI, SAT, SUN} Week_days; 17. [was #16] All the statements are legal, since C allows integers and enumeration values to be mixed without restriction. Only (a), (d), and (e) are safe. (b) is not meaningful if i has a value other than 0 or 1. (c) will not yield a meaningful result if b has the value 1. Answers to Selected Programming Projects1. [was #6; modified] 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt; #define COUNTRY_COUNT \\ ((int) (sizeof(country_codes) / sizeof(country_codes[0]))) struct dialing_code { char *country; int code;}; const struct dialing_code country_codes[] = {{\"Argentina\", 54}, {\"Bangladesh\", 880}, {\"Brazil\", 55}, {\"Burma (Myanmar)\", 95}, {\"China\", 86}, {\"Colombia\", 57}, {\"Congo, Dem. Rep. of\", 243}, {\"Egypt\", 20}, {\"Ethiopia\", 251}, {\"France\", 33}, {\"Germany\", 49}, {\"India\", 91}, {\"Indonesia\", 62}, {\"Iran\", 98}, {\"Italy\", 39}, {\"Japan\", 81}, {\"Mexico\", 52}, {\"Nigeria\", 234}, {\"Pakistan\", 92}, {\"Philippines\", 63}, {\"Poland\", 48}, {\"Russia\", 7}, {\"South Africa\", 27}, {\"South Korea\", 82}, {\"Spain\", 34}, {\"Sudan\", 249}, {\"Thailand\", 66}, {\"Turkey\", 90}, {\"Ukraine\", 380}, {\"United Kingdom\", 44}, {\"United States\", 1}, {\"Vietnam\", 84}}; int main(void){ int code, i; printf(\"Enter dialing code: \"); scanf(\"%d\", &amp;code); for (i = 0; i &lt; COUNTRY_COUNT; i++) if (code == country_codes[i].code) { printf(\"The country with dialing code %d is %s\\n\", code, country_codes[i].country); return 0; } printf(\"No corresponding country found\\n\"); return 0;} 3. [was #8] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;stdio.h&gt;#include \"readline.h\" #define NAME_LEN 25#define MAX_PARTS 100 struct part { int number; char name[NAME_LEN+1]; int on_hand;}; int find_part(int number, const struct part inv[], int np);void insert(struct part inv[], int *np);void search(const struct part inv[], int np);void update(struct part inv[], int np);void print(const struct part inv[], int np); /********************************************************** * main: Prompts the user to enter an operation code, * * then calls a function to perform the requested * * action. Repeats until the user enters the * * command 'q'. Prints an error message if the user * * enters an illegal code. * **********************************************************/int main(void){ char code; struct part inventory[MAX_PARTS]; int num_parts = 0; for (;;) { printf(\"Enter operation code: \"); scanf(\" %c\", &amp;code); while (getchar() != '\\n') /* skips to end of line */ ; switch (code) { case 'i': insert(inventory, &amp;num_parts); break; case 's': search(inventory, num_parts); break; case 'u': update(inventory, num_parts); break; case 'p': print(inventory, num_parts); break; case 'q': return 0; default: printf(\"Illegal code\\n\"); } printf(\"\\n\"); }} /********************************************************** * find_part: Looks up a part number in the inv array. * * Returns the array index if the part number * * is found; otherwise, returns -1. * **********************************************************/int find_part(int number, const struct part inv[], int np){ int i; for (i = 0; i &lt; np; i++) if (inv[i].number == number) return i; return -1;} /********************************************************** * insert: Prompts the user for information about a new * * part and then inserts the part into the inv * * array. Prints an error message and returns * * prematurely if the part already exists or the * * array is full. * **********************************************************/void insert(struct part inv[], int *np){ int part_number; if (*np == MAX_PARTS) { printf(\"Database is full; can't add more parts.\\n\"); return; } printf(\"Enter part number: \"); scanf(\"%d\", &amp;part_number); if (find_part(part_number, inv, *np) &gt;= 0) { printf(\"Part already exists.\\n\"); return; } inv[*np].number = part_number; printf(\"Enter part name: \"); read_line(inv[*np].name, NAME_LEN); printf(\"Enter quantity on hand: \"); scanf(\"%d\", &amp;inv[*np].on_hand); (*np)++;} /********************************************************** * search: Prompts the user to enter a part number, then * * looks up the part in the inv array. If the * * part exists, prints the name and quantity on * * hand; if not, prints an error message. * **********************************************************/void search(const struct part inv[], int np){ int i, number; printf(\"Enter part number: \"); scanf(\"%d\", &amp;number); i = find_part(number, inv, np); if (i &gt;= 0) { printf(\"Part name: %s\\n\", inv[i].name); printf(\"Quantity on hand: %d\\n\", inv[i].on_hand); } else printf(\"Part not found.\\n\");} /********************************************************** * update: Prompts the user to enter a part number. * * Prints an error message if the part can't be * * found in the inv array; otherwise, prompts the * * user to enter change in quantity on hand and * * updates the array. * **********************************************************/void update(struct part inv[], int np){ int i, number, change; printf(\"Enter part number: \"); scanf(\"%d\", &amp;number); i = find_part(number, inv, np); if (i &gt;= 0) { printf(\"Enter change in quantity on hand: \"); scanf(\"%d\", &amp;change); inv[i].on_hand += change; } else printf(\"Part not found.\\n\");} /********************************************************** * print: Prints a listing of all parts in the inv array, * * showing the part number, part name, and * * quantity on hand. Parts are printed in the * * order in which they were entered into the * * array. * **********************************************************/void print(const struct part inv[], int np){ int i; printf(\"Part Number Part Name \" \"Quantity on Hand\\n\"); for (i = 0; i &lt; np; i++) printf(\"%7d %-25s%11d\\n\", inv[i].number, inv[i].name, inv[i].on_hand);} Chapter 17Answers to Selected Exercises2. [was #2; modified] 12345678910char *duplicate(const char *s){ char *temp = malloc(strlen(s) + 1); if (temp == NULL) return NULL; strcpy(temp, s); return temp;} 5. [was #6] (b) and (c) are legal. (a) is illegal because it tries to reference a member of d without mentioning d. (d) is illegal because it uses -&gt; instead of . to reference the c member of d. 7. [was #8] The first call of free will release the space for the first node in the list, making p a dangling pointer. Executing p = p-&gt;next to advance to the next node will have an undefined effect. Here’s a correct way to write the loop, using a temporary pointer that points to the node being deleted: 12345678struct node *temp; p = first;while (p != NULL) { temp = p; p = p-&gt;next; free(temp);} 8. [was #10; modified] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdbool.h&gt; /* C99 only */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"stack.h\" struct node { int value; struct node *next;}; struct node *top = NULL; void make_empty(void){ struct node *temp; while (top != NULL) { temp = top; top = top-&gt;next; free(temp); }} bool is_empty(void){ return top == NULL;} bool push(int i){ struct node *new_node; new_node = malloc(sizeof(struct node)); if (new_node == NULL) return false; new_node-&gt;value = i; new_node-&gt;next = top; top = new_node; return true;} int pop(void){ struct node *temp; int i; if (is_empty()) { printf(\"*** Stack underflow; program terminated. ***\\n\"); exit(EXIT_FAILURE); } i = top-&gt;value; temp = top; top = top-&gt;next; free(temp); return i;} 15. [was #12] The output of the program is 1Answer: 3 The program tests the values of f2(0), f2(1), f2(2), and so on, stopping when f2 returns zero. It then prints the argument that was passed to f2 to make it return zero. 17. [was #14] Assuming that compare is the name of the comparison function, the following call of qsort will sort the last 50 elements of a: 1qsort(&amp;a[50], 50, sizeof(a[0]), compare); Answers to Selected Programming Projects1. [was #4] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"readline.h\" #define NAME_LEN 25#define INITIAL_PARTS 10 struct part { int number; char name[NAME_LEN+1]; int on_hand;}; struct part *inventory;int num_parts = 0; /* number of parts currently stored */int max_parts = INITIAL_PARTS; /* size of inventory array */ int find_part(int number);void insert(void);void search(void);void update(void);void print(void); /********************************************************** * main: Prompts the user to enter an operation code, * * then calls a function to perform the requested * * action. Repeats until the user enters the * * command 'q'. Prints an error message if the user * * enters an illegal code. * **********************************************************/int main(void){ char code; inventory = malloc(max_parts * sizeof(struct part)); if (inventory == NULL) { printf(\"Can't allocate initial inventory space.\\n\"); exit(EXIT_FAILURE); } for (;;) { printf(\"Enter operation code: \"); scanf(\" %c\", &amp;code); while (getchar() != '\\n') /* skips to end of line */ ; switch (code) { case 'i': insert(); break; case 's': search(); break; case 'u': update(); break; case 'p': print(); break; case 'q': return 0; default: printf(\"Illegal code\\n\"); } printf(\"\\n\"); }} /********************************************************** * find_part: Looks up a part number in the inventory * * array. Returns the array index if the part * * number is found; otherwise, returns -1. * **********************************************************/int find_part(int number){ int i; for (i = 0; i &lt; num_parts; i++) if (inventory[i].number == number) return i; return -1;} /********************************************************** * insert: Prompts the user for information about a new * * part and then inserts the part into the * * database. Prints an error message and returns * * prematurely if the part already exists or the * * database is full. * **********************************************************/void insert(void){ int part_number; struct part *temp; if (num_parts == max_parts) { max_parts *= 2; temp = realloc(inventory, max_parts * sizeof(struct part)); if (temp == NULL) { printf(\"Insufficient memory; can't add more parts.\\n\"); return; } inventory = temp; } printf(\"Enter part number: \"); scanf(\"%d\", &amp;part_number); if (find_part(part_number) &gt;= 0) { printf(\"Part already exists.\\n\"); return; } inventory[num_parts].number = part_number; printf(\"Enter part name: \"); read_line(inventory[num_parts].name, NAME_LEN); printf(\"Enter quantity on hand: \"); scanf(\"%d\", &amp;inventory[num_parts].on_hand); num_parts++;} /********************************************************** * search: Prompts the user to enter a part number, then * * looks up the part in the database. If the part * * exists, prints the name and quantity on hand; * * if not, prints an error message. * **********************************************************/void search(void){ int i, number; printf(\"Enter part number: \"); scanf(\"%d\", &amp;number); i = find_part(number); if (i &gt;= 0) { printf(\"Part name: %s\\n\", inventory[i].name); printf(\"Quantity on hand: %d\\n\", inventory[i].on_hand); } else printf(\"Part not found.\\n\");} /********************************************************** * update: Prompts the user to enter a part number. * * Prints an error message if the part doesn't * * exist; otherwise, prompts the user to enter * * change in quantity on hand and updates the * * database. * **********************************************************/void update(void){ int i, number, change; printf(\"Enter part number: \"); scanf(\"%d\", &amp;number); i = find_part(number); if (i &gt;= 0) { printf(\"Enter change in quantity on hand: \"); scanf(\"%d\", &amp;change); inventory[i].on_hand += change; } else printf(\"Part not found.\\n\");} /********************************************************** * print: Prints a listing of all parts in the database, * * showing the part number, part name, and * * quantity on hand. Parts are printed in the * * order in which they were entered into the * * database. * **********************************************************/void print(void){ int i; printf(\"Part Number Part Name \" \"Quantity on Hand\\n\"); for (i = 0; i &lt; num_parts; i++) printf(\"%7d %-25s%11d\\n\", inventory[i].number, inventory[i].name, inventory[i].on_hand);} 2. [was #16] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"readline.h\" #define NAME_LEN 25#define MAX_PARTS 100 struct part { int number; char name[NAME_LEN+1]; int on_hand;} inventory[MAX_PARTS]; int num_parts = 0; /* number of parts currently stored */ int find_part(int number);void insert(void);void search(void);void update(void);void print(void);int compare_parts(const void *p, const void *q); /********************************************************** * main: Prompts the user to enter an operation code, * * then calls a function to perform the requested * * action. Repeats until the user enters the * * command 'q'. Prints an error message if the user * * enters an illegal code. * **********************************************************/int main(void){ char code; for (;;) { printf(\"Enter operation code: \"); scanf(\" %c\", &amp;code); while (getchar() != '\\n') /* skips to end of line */ ; switch (code) { case 'i': insert(); break; case 's': search(); break; case 'u': update(); break; case 'p': print(); break; case 'q': return 0; default: printf(\"Illegal code\\n\"); } printf(\"\\n\"); }} /********************************************************** * find_part: Looks up a part number in the inventory * * array. Returns the array index if the part * * number is found; otherwise, returns -1. * **********************************************************/int find_part(int number){ int i; for (i = 0; i &lt; num_parts; i++) if (inventory[i].number == number) return i; return -1;} /********************************************************** * insert: Prompts the user for information about a new * * part and then inserts the part into the * * database. Prints an error message and returns * * prematurely if the part already exists or the * * database is full. * **********************************************************/void insert(void){ int part_number; if (num_parts == MAX_PARTS) { printf(\"Database is full; can't add more parts.\\n\"); return; } printf(\"Enter part number: \"); scanf(\"%d\", &amp;part_number); if (find_part(part_number) &gt;= 0) { printf(\"Part already exists.\\n\"); return; } inventory[num_parts].number = part_number; printf(\"Enter part name: \"); read_line(inventory[num_parts].name, NAME_LEN); printf(\"Enter quantity on hand: \"); scanf(\"%d\", &amp;inventory[num_parts].on_hand); num_parts++;} /********************************************************** * search: Prompts the user to enter a part number, then * * looks up the part in the database. If the part * * exists, prints the name and quantity on hand; * * if not, prints an error message. * **********************************************************/void search(void){ int i, number; printf(\"Enter part number: \"); scanf(\"%d\", &amp;number); i = find_part(number); if (i &gt;= 0) { printf(\"Part name: %s\\n\", inventory[i].name); printf(\"Quantity on hand: %d\\n\", inventory[i].on_hand); } else printf(\"Part not found.\\n\");} /********************************************************** * update: Prompts the user to enter a part number. * * Prints an error message if the part doesn't * * exist; otherwise, prompts the user to enter * * change in quantity on hand and updates the * * database. * **********************************************************/void update(void){ int i, number, change; printf(\"Enter part number: \"); scanf(\"%d\", &amp;number); i = find_part(number); if (i &gt;= 0) { printf(\"Enter change in quantity on hand: \"); scanf(\"%d\", &amp;change); inventory[i].on_hand += change; } else printf(\"Part not found.\\n\");} /********************************************************** * print: Sorts the inventory array by part number, then * * prints a listing of all parts in the database, * * showing the part number, part name, and * * quantity on hand. * **********************************************************/void print(void){ int i; qsort(inventory, num_parts, sizeof(struct part), compare_parts); printf(\"Part Number Part Name \" \"Quantity on Hand\\n\"); for (i = 0; i &lt; num_parts; i++) printf(\"%7d %-25s%11d\\n\", inventory[i].number, inventory[i].name, inventory[i].on_hand);} int compare_parts(const void *p, const void *q){ return ((struct part *) p)-&gt;number - ((struct part *) q)-&gt;number;} Chapter 18Answers to Selected Exercises2. [was #2] (a) extern (b) static (c) extern and static (when applied to a local variable) 4. [was #4] If f has never been called previously, the value of f(10) will be 0. If f has been called five times previously, the value of f(10) will be 50, since j is incremented once per call. 8. [was #6; modified] (a) x is an array of ten pointers to functions. Each function takes an int argument and returns a character. (b) x is a function that returns a pointer to an array of five integers. (c) x is a function with no arguments that returns a pointer to a function with an int argument that returns a pointer to a float value. (d) x is a function with two arguments. The first argument is an integer, and the second is a pointer to a function with an int argument and no return value. x returns a pointer to a function with an int argument and no return value. (Although this example may seem artificially complex, the signal function—part of the standard C library—has exactly this prototype. See p. 632 for a discussion of signal.) 10. [was #8] (a) char *(*p)(char *); (b) void *f(struct t *p, long int n)(void); (c) void (*a[])(void) = {insert, search, update, print}; (d) struct t (*b[10])(int, int); 13. [was #10] (a), (c), and (d) are legal. (b) is illegal; the initializer for a variable with static storage duration must be a constant expression, and i * i doesn’t qualify. 15. [was #12] (a). Variables with static storage duration are initialized to zero by default; variables with automatic storage duration have no default initial value. Chapter 19Answers to Selected Exercises2. [was #2; modified] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"stack.h\" #define PUBLIC /* empty */#define PRIVATE static struct node { int data; struct node *next;}; PRIVATE struct node *top = NULL; PRIVATE void terminate(const char *message){ printf(\"%s\\n\", message); exit(EXIT_FAILURE);} PUBLIC void make_empty(void){ while (!is_empty()) pop();} PUBLIC bool is_empty(void){ return top == NULL;} PUBLIC bool is_full(void){ return false;} PUBLIC void push(int i){ struct node *new_node = malloc(sizeof(struct node)); if (new_node == NULL) terminate(\"Error in push: stack is full.\"); new_node-&gt;data = i; new_node-&gt;next = top; top = new_node;} PUBLIC int pop(void){ struct node *old_top; int i; if (is_empty()) terminate(\"Error in pop: stack is empty.\"); old_top = top; i = top-&gt;data; top = top-&gt;next; free(old_top); return i;} 4. [was #4; modified] (a) Contents of stack.c file: 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"stack.h\" static void terminate(const char *message){ printf(\"%s\\n\", message); exit(EXIT_FAILURE);} void make_empty(Stack *s){ s-&gt;top = 0;} bool is_empty(const Stack *s){ return s-&gt;top == 0;} bool is_full(const Stack *s){ return s-&gt;top == STACK_SIZE;} void push(Stack *s, int i){ if (is_full(s)) terminate(\"Error in push: stack is full.\"); s-&gt;contents[s-&gt;top++] = i;} int pop(Stack *s){ if (is_empty(s)) terminate(\"Error in pop: stack is empty.\"); return s-&gt;contents[--s-&gt;top];} (b) Contents of stack.h file: 12345678910111213141516171819#ifndef STACK_H#define STACK_H #include &lt;stdbool.h&gt; /* C99 only */ struct node { int data; struct node *next;}; typedef struct node *Stack; void make_empty(Stack *s);bool is_empty(const Stack *s);bool is_full(const Stack *s);void push(Stack *s, int i);int pop(Stack *s); #endif Contents of stack.c file: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include \"stack.h\" static void terminate(const char *message){ printf(\"%s\\n\", message); exit(EXIT_FAILURE);} void make_empty(Stack *s){ while (!is_empty(s)) pop(s);} bool is_empty(const Stack *s){ return *s == NULL;} bool is_full(const Stack *s){ return false;} void push(Stack *s, int i){ struct node *new_node = malloc(sizeof(struct node)); if (new_node == NULL) terminate(\"Error in push: stack is full.\"); new_node-&gt;data = i; new_node-&gt;next = *s; *s = new_node;} int pop(Stack *s){ struct node *old_top; int i; if (is_empty(s)) terminate(\"Error in pop: stack is empty.\"); old_top = *s; i = (*s)-&gt;data; *s = (*s)-&gt;next; free(old_top); return i;} Chapter 20Answers to Selected Exercises2. [was #2] To toggle a bit in a variable i, apply the exclusive-or operator (^) to i and a mask with a 1 bit in the desired position, then store the result back into i. To toggle bit 4, for example, use the statement 1i = i ^ 0x0010; or, more concisely, 1i ^= 0x0010; 4. [was #4] `` 1#define MK_COLOR(r,g,b) ((long) (b) &lt;&lt; 16 | (g) &lt;&lt; 8 | (r)) 6. [was #6; modified] (a) 123456789101112131415161718192021#include &lt;stdio.h&gt; unsigned short swap_bytes(unsigned short i); int main(void){ unsigned short i; printf(\"Enter a hexadecimal number (up to four digits): \"); scanf(\"%hx\", &amp;i); printf(\"Number with bytes swapped: %hx\\n\", swap_bytes(i)); return 0;} unsigned short swap_bytes(unsigned short i){ unsigned short high_byte = i &lt;&lt; 8; unsigned short low_byte = i &gt;&gt; 8; return high_byte | low_byte;} (b) 1234unsigned short swap_bytes(unsigned short i){ return i &lt;&lt; 8 | i &gt;&gt; 8;} 8. [was #8] (a) The value of ~0 is a number containing all 1 bits. Shifting this number to the left by n places yields a result of the form 1…10…0, where there are n 0 bits. Applying the ~ operator to that number yields a result of the form 0…01…1, where there are n 1 bits. (b) It returns a bit-field within i of length n starting at position m. Positions are assumed to be numbered starting from the rightmost bit, which is position 0. 14. [was #9] 12345struct IEEE_float { unsigned int fraction: 23; /* members may need to be reversed */ unsigned int exponent: 8; unsigned int sign: 1;}; Chapter 21Answers to Selected Exercises7. [was #4] (a) &lt;time.h&gt; (b) &lt;ctype.h&gt; (c) &lt;limits.h&gt; (d) &lt;math.h&gt; (e) &lt;limits.h&gt; (f) &lt;float.h&gt; (g) &lt;string.h&gt; (h) &lt;stdio.h&gt; Chapter 22Answers to Selected Exercises2. [was #2] (a) \"rb+\" (b) \"a\" (c) \"rb\" (d) \"r\" 4. [was #4] (a) 00000083.736 (b) 00000029749. (c) 001.0549e+09 (d) 002.3522e-05 6. [was #6] printf(widget == 1 ? \"%d widget\" : \"%d widgets\", widget); 8. [was #8] No. The difference is that \"%1s\" will store a null character after it reads and stores a nonblank character; \" %c\" will store only the nonblank character. As a result, the two format strings must be used differently: 123456char c, s[2]; scanf(\" %c\", &amp;c); /* stores a nonblank character into c */scanf(\"%1s\", s); /* stores a nonblank character into s[0] and a null character into s[1] */ 10. [was #10] Revise the program’s while loop as follows: 12345while ((ch = getc(source_fp)) != EOF) if (putc(ch, dest_fp) == EOF) { fprintf(stderr, \"Error during writing; copy terminated\\n\"); exit(EXIT_FAILURE); } 14. [was #18] (a) 123456789101112131415161718char *fget_string(char *s, int n, FILE *stream){ int ch, len = 0; while (len &lt; n - 1) { if ((ch = getc(stream)) == EOF) { if (len == 0 || ferror(stream)) return NULL; break; } s[len++] = ch; if (ch == '\\n') break; } s[len] = '\\0'; return s;} (b) 12345678910int fput_string(const char *s, FILE *stream){ while (*s != '\\0') { if (putc(*s, stream) == EOF) return EOF; s++; } return 0;} 15. [was #22] (a) fseek(fp, n * 64L, SEEK_SET); (b) fseek(fp, -64L, SEEK_END); (c) fseek(fp, 64L, SEEK_CUR); (d) fseek(fp, -128L, SEEK_CUR); Answers to Selected Programming Projects2. [was #12] 12345678910111213141516171819202122232425#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char *argv[]){ FILE *fp; int ch; if (argc != 2) { fprintf(stderr, \"usage: toupper file\\n\"); exit(EXIT_FAILURE); } if ((fp = fopen(argv[1], \"r\")) == NULL) { fprintf(stderr, \"Can't open %s\\n\", argv[1]); exit(EXIT_FAILURE); } while ((ch = getc(fp)) != EOF) putchar(toupper(ch)); fclose(fp); return 0;} 4. [was #14] (a) 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char *argv[]){ FILE *fp; int count = 0; if (argc != 2) { fprintf(stderr, \"usage: cntchar file\\n\"); exit(EXIT_FAILURE); } if ((fp = fopen(argv[1], \"r\")) == NULL) { fprintf(stderr, \"Can't open %s\\n\", argv[1]); exit(EXIT_FAILURE); } while (getc(fp) != EOF) count++; printf(\"There are %d characters in %s\\n\", count, argv[1]); fclose(fp); return 0;} (b) 1234567891011121314151617181920212223242526272829303132333435#include &lt;ctype.h&gt;#include &lt;stdbool.h&gt; /* C99 only */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char *argv[]){ FILE *fp; int ch, count = 0; bool in_word; if (argc != 2) { fprintf(stderr, \"usage: cntword file\\n\"); exit(EXIT_FAILURE); } if ((fp = fopen(argv[1], \"r\")) == NULL) { fprintf(stderr, \"Can't open %s\\n\", argv[1]); exit(EXIT_FAILURE); } in_word = false; while ((ch = getc(fp)) != EOF) if (isspace(ch)) in_word = false; else if (!in_word) { in_word = true; count++; } printf(\"There are %d words in %s\\n\", count, argv[1]); fclose(fp); return 0;} (c) 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char *argv[]){ FILE *fp; int ch, count = 0; if (argc != 2) { fprintf(stderr, \"usage: cntline file\\n\"); exit(EXIT_FAILURE); } if ((fp = fopen(argv[1], \"r\")) == NULL) { fprintf(stderr, \"Can't open %s\\n\", argv[1]); exit(EXIT_FAILURE); } while((ch = getc(fp)) != EOF) if (ch == '\\n') count++; printf(\"There are %d lines in %s\\n\", count, argv[1]); fclose(fp); return 0;} 6. [was #16; modified] 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char *argv[]){ FILE *fp; int i, n, offset; unsigned char buffer[10]; if (argc != 2) { fprintf(stderr, \"usage: viewfile file\\n\"); exit(EXIT_FAILURE); } if ((fp = fopen(argv[1], \"rb\")) == NULL) { fprintf(stderr, \"Can't open %s\\n\", argv[1]); exit(EXIT_FAILURE); } printf(\"Offset Bytes Characters\\n\"); printf(\"------ ----------------------------- ----------\\n\"); for (offset = 0;; offset += 10) { n = fread(buffer, 1, 10, fp); if (n == 0) break; printf(\"%6d \", offset); for (i = 0; i &lt; n; i++) printf(\"%.2X \", buffer[i]); for (; i &lt; 10; i++) printf(\" \"); printf(\" \"); for (i = 0; i &lt; n; i++) { if (!isprint(buffer[i])) buffer[i] = '.'; printf(\"%c\", buffer[i]); } printf(\"\\n\"); } fclose(fp); return 0;} 9. [was #20] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; #define NAME_LEN 25 struct part { int number; char name[NAME_LEN + 1]; int on_hand;}; int main(int argc, char *argv[]){ FILE *in_fp1, *in_fp2, *out_fp; int num_read1, num_read2; struct part part1, part2; if (argc != 4) { fprintf(stderr, \"usage: merge infile1 infile2 outfile\\n\"); exit(EXIT_FAILURE); } if ((in_fp1 = fopen(argv[1], \"rb\")) == NULL) { fprintf(stderr, \"Can't open %s\\n\", argv[1]); exit(EXIT_FAILURE); } if ((in_fp2 = fopen(argv[2], \"rb\")) == NULL) { fprintf(stderr, \"Can't open %s\\n\", argv[2]); exit(EXIT_FAILURE); } if ((out_fp = fopen(argv[3], \"wb\")) == NULL) { fprintf(stderr, \"Can't open %s\\n\", argv[3]); exit(EXIT_FAILURE); } num_read1 = fread(&amp;part1, sizeof(struct part), 1, in_fp1); num_read2 = fread(&amp;part2, sizeof(struct part), 1, in_fp2); while (num_read1 == 1 &amp;&amp; num_read2 == 1) /* successfully read records from both files */ if (part1.number &lt; part2.number) { fwrite(&amp;part1, sizeof(struct part), 1, out_fp); num_read1 = fread(&amp;part1, sizeof(struct part), 1, in_fp1); } else if (part1.number &gt; part2.number) { fwrite(&amp;part2, sizeof(struct part), 1, out_fp); num_read2 = fread(&amp;part2, sizeof(struct part), 1, in_fp2); } else { /* part numbers are equal */ if (strcmp(part1.name, part2.name) != 0) fprintf(stderr, \"Names don't match for part %d; using the name %s\\n\", part1.number, part1.name); part1.on_hand += part2.on_hand; fwrite(&amp;part1, sizeof(struct part), 1, out_fp); num_read1 = fread(&amp;part1, sizeof(struct part), 1, in_fp1); num_read2 = fread(&amp;part2, sizeof(struct part), 1, in_fp2); } /* copy rest of file1 to output file */ while (num_read1 == 1) { fwrite(&amp;part1, sizeof(struct part), 1, out_fp); num_read1 = fread(&amp;part1, sizeof(struct part), 1, in_fp1); } /* copy rest of file2 to output file */ while (num_read2 == 1) { fwrite(&amp;part2, sizeof(struct part), 1, out_fp); num_read2 = fread(&amp;part2, sizeof(struct part), 1, in_fp2); } fclose(in_fp1); fclose(in_fp2); fclose(out_fp); return 0;} Chapter 23Answers to Selected Exercises1. [was #2; modified] 123456789double round_nearest(double x, int n){ double power = pow(10.0, n); if (x &lt; 0.0) return ceil(x * power - 0.5) / power; else return floor(x * power + 0.5) / power;} 6. [was #6] (a) memmove (b) memmove (we can’t use strcpy because its behavior is undefined when the source of the copy overlaps with the destination) (c) strncpy (d) memcpy 8. [was #8] 123456789101112int numchar(const char *s, char ch){ int count = 0; s = strchr(s, ch); while (s != NULL) { count++; s = strchr(s + 1, ch); } return count;} 10. [was #10] 1if (strstr(\"foo#bar#baz\", str) != NULL) … The assumptions are that str is at least three characters long and doesn’t contain the # character. 11. [was #12] memset(&amp;s[strlen(s)-n], '!', n); Answers to Selected Programming Projects2. [was #4; modified] 12345678910111213141516171819202122#include &lt;ctype.h&gt;#include &lt;stdbool.h&gt; /* C99 only */#include &lt;stdio.h&gt; int main(void){ bool nonblank_seen = false; int ch; while ((ch = getchar()) != EOF) { if (nonblank_seen) putchar(ch); else if (!isspace(ch)) { nonblank_seen = true; putchar(ch); } if (ch == '\\n') nonblank_seen = false; } return 0;} Chapter 24Answers to Selected Exercises4. [was #2] (a) 123456789101112double try_math_fcn(double (*f)(double), double x, const char *msg){ double result; errno = 0; result = (*f)(x); if (errno != 0) { perror(msg); exit(EXIT_FAILURE); } return result;} (b) 1#define TRY_MATH_FCN(f,x) try_math_fcn(f, x, \"Error in call of \" #f) 5. [was #4] 12345678910111213141516171819202122232425int main(void){ char code; for (;;) { setjmp(env); printf(\"Enter operation code: \"); scanf(\" %c\", &amp;code); while (getchar() != '\\n') /* skips to end of line */ ; switch (code) { case 'i': insert(); break; case 's': search(); break; case 'u': update(); break; case 'p': print(); break; case 'q': return 0; default: printf(\"Illegal code\\n\"); } printf(\"\\n\"); }} The jmp_buf variable env will need to be global, rather than local to main, so that the function performing the longjmp will be able to supply it as an argument. Chapter 25Answers to Selected Exercises6. [was #4; modified] 1234567while ((orig_char = getchar()) != EOF) ??&lt; new_char = orig_char ??' KEY; if (isprint(orig_char) &amp;&amp; isprint(new_char)) putchar(new_char); else putchar(orig_char);??&gt; Answers to Selected Programming Projects1. [was #2] 12345678910111213141516171819202122232425262728293031323334353637#include &lt;locale.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; int main(void){ char *temp, *C_locale; temp = setlocale(LC_ALL, NULL); /* \"C\" is the current locale by default */ if (temp == NULL) { printf(\"\\\"C\\\" locale information not available\\n\"); exit(EXIT_FAILURE); } C_locale = malloc(strlen(temp) + 1); if (C_locale == NULL) { printf(\"Can't allocate space to store locale information\\n\"); exit(EXIT_FAILURE); } strcpy(C_locale, temp); temp = setlocale(LC_ALL, \"\"); if (temp == NULL) { printf(\"Native locale information not available\\n\"); exit(EXIT_FAILURE); } if (strcmp(temp, C_locale) == 0) printf(\"Native locale is the same as the \\\"C\\\" locale\\n\"); else printf(\"Native locale is not the same as the \\\"C\\\" locale\\n\"); return 0;} Chapter 26Answers to Selected Exercises2. [was #2] 123456789101112131415161718192021222324252627282930313233343536373839void int_printf(const char *format, ...){ va_list ap; const char *p; int digit, i, power, temp; va_start(ap, format); for (p = format; *p != '\\0'; p++) { if (*p != '%') { putchar(*p); continue; } if (*++p == 'd') { i = va_arg(ap, int); if (i &lt; 0) { i = -i; putchar('-'); } temp = i; power = 1; while (temp &gt; 9) { temp /= 10; power *= 10; } do { digit = i / power; putchar(digit + '0'); i -= digit * power; power /= 10; } while (i &gt; 0); } } va_end(ap);} 7. [was #4] The statement converts the string that p points to into a long integer, storing the result in value. p is left pointing to the first character not included in the conversion. The base used for the conversion is 10. 9. [was #6] 1234double rand_double(void){ return (double) rand() / (RAND_MAX + 1);} Answers to Selected Programming Projects1. [was #8] (a) 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(void){ int count = 1000; while (count-- &gt; 0) printf(\"%d\", rand() &amp; 1); printf(\"\\n\"); return 0;} (b) For generating numbers in the range 0 to N - 1, the formula rand() / (RAND_MAX / N + 1) often gives better results than rand() % N. For example, if N is 2 and RAND_MAX is 32767, the formula works out to rand() / 16384, which yields 0 if the return value of rand is less than 16384 and 1 if it’s greater than or equal to 16384. 3. [was #10; modified] 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt; #define N 1000 int compare_ints(const void *p, const void *q); int main(void){ int a[N], i; clock_t start_clock; for (i = 0; i &lt; N; i++) a[i] = N - i; start_clock = clock(); qsort(a, N, sizeof(a[0]), compare_ints); printf(\"Time used to sort %d integers: %g sec.\\n\", N, (clock() - start_clock) / (double) CLOCKS_PER_SEC); return 0;} int compare_ints(const void *p, const void *q){ return *(int *)p - *(int *)q;} 4. [was #12] 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main(void){ struct tm t; int n; /* initialize unused members */ t.tm_sec = t.tm_min = t.tm_hour = 0; t.tm_isdst = -1; printf(\"Enter month (1-12): \"); scanf(\"%d\", &amp;t.tm_mon); t.tm_mon--; printf(\"Enter day (1-31): \"); scanf(\"%d\", &amp;t.tm_mday); printf(\"Enter year: \"); scanf(\"%d\", &amp;t.tm_year); t.tm_year -= 1900; printf(\"Enter number of days in future: \"); scanf(\"%d\", &amp;n); t.tm_mday += n; mktime(&amp;t); printf(\"\\nFuture date: %d/%d/%d\\n\", t.tm_mon + 1, t.tm_mday, t.tm_year + 1900); return 0;} 6. [was #14] (a) 123456789101112131415#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main(void){ time_t current = time(NULL); struct tm *ptr; char date_time[37]; ptr = localtime(&amp;current); strftime(date_time, sizeof(date_time), \"%A, %B %d, %Y %I:%M\", ptr); printf(\"%s%c\\n\", date_time, ptr-&gt;tm_hour &lt;= 11 ? 'a' : 'p'); return 0;} (b) 1234567891011121314#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main(void){ time_t current = time(NULL); char date_time[22]; strftime(date_time, sizeof(date_time), \"%a, %d %b %y %H:%M\", localtime(&amp;current)); puts(date_time); return 0;} (c) 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;time.h&gt; int main(void){ time_t current = time(NULL); struct tm *ptr; char date[9], time[12]; ptr = localtime(&amp;current); strftime(date, sizeof(date), \"%m/%d/%y\", ptr); strftime(time, sizeof(time), \"%I:%M:%S %p\", ptr); /* print date and time, suppressing leading zero in hours */ printf(\"%s %s\\n\", date, time[0] == '0' ? &amp;time[1] : time); return 0;}","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://czqu.net/tags/C/"}]}],"categories":[{"name":"Backend Development","slug":"Backend-Development","permalink":"https://czqu.net/categories/Backend-Development/"},{"name":"Recipe","slug":"Recipe","permalink":"https://czqu.net/categories/Recipe/"},{"name":"Life Hacks","slug":"Life-Hacks","permalink":"https://czqu.net/categories/Life-Hacks/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://czqu.net/categories/LeetCode/"}],"tags":[{"name":"Backend Development","slug":"Backend-Development","permalink":"https://czqu.net/tags/Backend-Development/"},{"name":"Java","slug":"Java","permalink":"https://czqu.net/tags/Java/"},{"name":"Life","slug":"Life","permalink":"https://czqu.net/tags/Life/"},{"name":"Recipe","slug":"Recipe","permalink":"https://czqu.net/tags/Recipe/"},{"name":"Trap","slug":"Trap","permalink":"https://czqu.net/tags/Trap/"},{"name":"Information Security","slug":"Information-Security","permalink":"https://czqu.net/tags/Information-Security/"},{"name":"Life Hacks","slug":"Life-Hacks","permalink":"https://czqu.net/tags/Life-Hacks/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://czqu.net/tags/LeetCode/"},{"name":"C","slug":"C","permalink":"https://czqu.net/tags/C/"}]}